program CODEGEN
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    
    uses "JSON/JSON"
    uses "JSON/Code"
    
    uses "CodeGen/Instructions"
    uses "CodeGen/CodeStream"
    
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/Parser"
    
    <string,variant> symbols;
    
    bool doInstrumenting;
    
    long codeSize = 0;
    writeCode(file hexeFile, <byte> code)
    {
        foreach (var b in code)
        {
            hexeFile.Append(b);
        }
    }
    <byte, <byte,uint> > sysCallHits;
    <byte, <byte,string> > sysCallLocations;
    <Instruction, uint> instructionHits;
    <Instruction, string> instructionLocations;
    
    exportStats(string instrumentingPath, <uint,uint> methodSizes)
    {
        string name;
        SysCalls.New();
        file statsFile = File.Create(instrumentingPath);
        statsFile.Append("SysCall,Overload,Hits,FirstUseLocation" + char(0x0A));
        foreach (var kv in sysCallHits)
        {
            byte iSysCall = kv.key;
            name = SysCalls.GetSysCallName(iSysCall);
            <byte, string> locations = sysCallLocations[iSysCall];
            foreach (var kv2 in kv.value)
            {
                uint iOverload = kv2.key;
                uint hits = kv2.value;
                string location = locations[iOverload];
                statsFile.Append(name + "," + iOverload.ToString() + "," + hits.ToString() + "," + location + char(0x0A));
            }  
        }
        statsFile.Append("" + char(0x0A));
        statsFile.Append("Instruction,Hits,FirstUseLocation" + char(0x0A));
        foreach (var kv in instructionHits)
        {
            Instruction instruction = kv.key;
            uint hits = kv.value;
            name = Instructions.ToString(instruction);
            string location = instructionLocations[instruction];
            statsFile.Append(name + "," + hits.ToString() + "," + location + char(0x0A));
        }
        statsFile.Append("" + char(0x0A));
        statsFile.Append("Method,Length,Arguments,ArgumentsSize,Locals,LocalsSize,Frameless" + char(0x0A));
        foreach (var kv in methodSizes)
        {
            name = Code.GetMethodName(kv.key);
            <string,variant> methodSymbols = Code.GetMethodSymbols(kv.key);
            uint argumentsBytes;
            uint argumentCount;
            uint localsBytes;
            uint localsCount;
            bool frameLess = true;
            if (methodSymbols.Contains("arguments"))
            {
                <string, <string> > argumentInfo = methodSymbols["arguments"];
                argumentCount = argumentInfo.Count;
                frameLess = frameLess && (argumentCount <= 1);
                foreach (var kv2 in argumentInfo)
                {
                    // kv2.key is offset
                    <string> argumentList = kv2.value; // <name,type,ref>
                    switch (argumentList[1])
                    {
                        case "char":
                        case "byte":
                        case "bool":
                        {
                            argumentsBytes++;
                        }
                        case "uint":
                        case "int":
                        {
                            argumentsBytes += 2;
                        }
                        case "delegate":
                        case "enum":   // TODO : enum8 ?
                        case "flags":  // TODO : flags8 ?
                        {
                            argumentsBytes += 2;
                        }
                        default:
                        {
                            Print(" A:" + argumentList[1]);
                            argumentsBytes += 2;
                        }
                    }
                }
                
            }
            if (methodSymbols.Contains("locals"))
            {
                <string, <string> > localInfo = methodSymbols["locals"];
                localsCount = localInfo.Count;
                frameLess = frameLess && (localsCount == 0);
                foreach (var kv2 in localInfo)
                {
                    // kv2.key is live address range like "0x0001-0x0007"
                    <string> localList = kv2.value; // <name, type, offset>
                    switch (localList[1])
                    {
                        case "char":
                        case "byte":
                        case "bool":
                        {
                            localsBytes++;
                        }
                        case "uint":
                        case "int":
                        {
                            localsBytes += 2;
                        }
                        case "delegate":
                        case "enum":   // TODO : enum8 ?
                        case "flags":  // TODO : flags8 ?
                        {
                            localsBytes += 2;
                        }
                        default:
                        {
                            Print(" L:" + localList[1]);
                            localsBytes += 2;
                        }
                    }
                }
            }
            
            uint size = kv.value;
            statsFile.Append(name + "," + size.ToString() + "," + argumentCount.ToString() + "," + argumentsBytes.ToString()
                                                          + "," + localsCount.ToString()   + "," + localsBytes.ToString() 
                                                          + "," + (frameLess ? "true" : "false")
                                                          + char(0x0A));   
        }
        
        
        statsFile.Flush();
    }
    
    instrumentSysCall(byte iSysCall, byte iOverload, string location)
    {
        <byte,uint> hits;
        <byte,string> locations;
        if (sysCallHits.Contains(iSysCall))
        {
            hits = sysCallHits[iSysCall];
            locations = sysCallLocations[iSysCall];
        }
        if (!hits.Contains(iOverload))
        {
            hits[iOverload] = 1;
            locations[iOverload] = location;
        }
        else
        {
            hits[iOverload] = hits[iOverload] + 1;
        }
        sysCallHits[iSysCall] = hits;
        sysCallLocations[iSysCall] = locations;
        
    }
    instrumentInstruction(Instruction instruction, string location)
    {
        if (!instructionHits.Contains(instruction))
        {
            instructionHits[instruction] = 1;
            instructionLocations[instruction] = location;
        }
        else
        {
            instructionHits[instruction] = instructionHits[instruction] + 1;
        }
    }
    
    instrument(<byte> code, uint methodIndex)
    {
        uint address = 0;
        loop
        {
            if (address == code.Count) { break; }
            uint operand;
            string location = "0x" + methodIndex.ToHexString(4) + ":0x" + address.ToHexString(4);
            Instruction instruction = Instructions.GetOperandAndNextAddress(code, ref address, ref operand);
            switch (instruction)
            {
                case Instruction.SYSCALL0:
                {
                    byte iSysCall = byte(operand & 0xFF);
                    instrumentSysCall(iSysCall, 0, location);
                }
                case Instruction.SYSCALL1:
                {
                    byte iSysCall = byte(operand & 0xFF);
                    instrumentSysCall(iSysCall, 1, location);
                }
                case Instruction.SYSCALL00:
                {
                    byte iSysCall = byte(operand & 0xFF);
                    instrumentSysCall(iSysCall, 0, location);
                    iSysCall = byte(operand >> 8);
                    instrumentSysCall(iSysCall, 0, location);
                }
                case Instruction.SYSCALL01:
                {
                    byte iSysCall = byte(operand & 0xFF);
                    instrumentSysCall(iSysCall, 0, location);
                    iSysCall = byte(operand >> 8);
                    instrumentSysCall(iSysCall, 1, location);
                }
                case Instruction.SYSCALL10:
                {
                    byte iSysCall = byte(operand & 0xFF);
                    instrumentSysCall(iSysCall, 1, location);
                    iSysCall = byte(operand >> 8);
                    instrumentSysCall(iSysCall, 0, location);
                }
                case Instruction.SYSCALLB0:
                {
                    byte iSysCall = byte(operand >> 8);
                    instrumentSysCall(iSysCall, 0, location);
                }
                case Instruction.SYSCALLB1:
                {
                    byte iSysCall = byte(operand >> 8);
                    instrumentSysCall(iSysCall, 0, location);
                }
                case Instruction.SYSCALL:
                {
                    byte iSysCall = byte(operand >> 8);
                    instrumentSysCall(iSysCall, 2, location); // probably not 0 or 1?
                }
                default:
                {
                    instrumentInstruction(instruction, location);
                }
            }
            
        }
    }
    
    badArguments()
    {
        PrintLn("Invalid arguments for CODEGEN:");
        PrintLn("  CODEGEN <code file>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
        PrintLn("    -ihex      : generate an Intel HEX file from the .hexe");
        PrintLn("    -i         : measure instruction and syscall usage");
    }
    
    byte hexCheckSum(string values)
    {
        uint sum = 0;
        for (uint i = 0; i < values.Length / 2; i++)
        {
            string substr = values.Substring(i * 2, 2);
            uint b = 0;
            if (UInt.TryParse("0x" + substr, ref b))
            {
            }
            sum = sum + b;
        }
        sum = sum % 256;
        byte chk = byte(sum);
        chk = ~chk;
        chk++;
        return chk;
    }
  
    emitBuffer(file ihexFile, uint address, string buffer)
    {
        uint bytes = buffer.Length / 2;
        string ln = bytes.ToHexString(2) + address.ToHexString(4) + "00" + buffer;
        byte chk = hexCheckSum(ln);
        ihexFile.Append(":" + ln + chk.ToHexString(2) + char(0x0A));
    }
    
    convertToIHex(string hexePath)
    {
        // https://en.wikipedia.org/wikie/Intel_HEX#Format
        // convert the .hexe into IHEX
        string extension = Path.GetExtension(hexePath);
        string ihexPath = hexePath.Replace(extension, ".ihex");
        if (File.Exists(ihexPath))
        {
            File.Delete(ihexPath);
        }
        
        File.Delete(ihexPath);
        file ihexFile = File.Create(ihexPath);
        file binFile = File.Open(hexePath);
        uint byteCount = 0;
        
        byte currentTick = 0;
        Parser.ProgressTick("i"); // convertToIHex
        
        string buffer;
        uint emitAddress = 0x0000;
        loop
        {
            byte cb = binFile.Read();
            
            if (!binFile.IsValid())
            {
                // done
                break;
            }
            buffer = buffer + cb.ToHexString(2);
            if (buffer.Length == 32)
            {
                emitBuffer(ihexFile, emitAddress, buffer);
                emitAddress = emitAddress + 16;
                buffer = "";
            }
            
            if (byteCount % 8192 == 0)
            {
                Parser.ProgressTick("i"); // convertToIHex
            }
            byteCount++;
            
        }
        if (buffer.Length != 0)
        {
            emitBuffer(ihexFile, emitAddress, buffer);
        }
        ihexFile.Append(":00000001FF" + char(0x0A)); // eof
        ihexFile.Flush();
    }
    
    Hopper()
    {
        bool success = false;
        loop
        {
            bool doIHex = false;
            <string> rawArgs = System.Arguments;
            <string> args;
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length >= 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        case "-ihex":
                        {
                            doIHex = true;
                        }
                        case "-i":
                        {
                            doInstrumenting = true;
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Count != 1)
            {
                badArguments();
                break;
            }
            string ext = ".code";
            string codePath = args[0];
            if (!File.Exists(ref codePath, ref ext, "/Debug/Obj/"))
            {
                badArguments();
            }
            
            long startTime = Millis;
            loop
            {
                string extension = Path.GetExtension(codePath);
                string hexePath  = codePath.Replace(extension, ".hexe");
                string symbolsPath = codePath.Replace(extension, ".sym");
                string instrumentingPath = codePath.Replace(extension, ".csv");
                
                hexePath = Path.GetFileName(hexePath);
                hexePath = Path.Combine("/Bin/", hexePath);
                File.Delete(hexePath);

                file hexeFile = File.Create(hexePath);
                if (!hexeFile.IsValid())
                {
                    PrintLn("Failed to create '" + hexePath + "'");
                    break;
                }

                Symbols.New();
                if (File.Exists(symbolsPath))
                {
                    if (Symbols.Import(symbolsPath, false))
                    {
                        CodeStream.InitializeSymbolShortcuts();
                    }
                }
                
                if (!ParseCode(codePath, true, doInstrumenting))
                {
                    break;
                }
                                
                byte versionLSB = 0x03; // extended code segment and flatstack
                hexeFile.Append(versionLSB);
                hexeFile.Append(byte(0));
                
                // figure out header table
                uint methodCount = Code.GetMethodCount();
                uint tableSize = ((methodCount-1) * 4);
                
                uint constOffset = tableSize+6;
                uint lsb = (constOffset & 0xFF);
                uint msb = (constOffset >> 8);
                
                // offset of location on constant data
                hexeFile.Append(byte(lsb));
                hexeFile.Append(byte(msb));
                
                <byte> constantData = Code.GetConstantData();
                
                uint mainOffset = constOffset + constantData.Count;
                
                lsb = (mainOffset & 0xFF);
                msb = (mainOffset >> 8);
                
                // offset of location on "main"
                hexeFile.Append(byte(lsb));
                hexeFile.Append(byte(msb));
                
                uint entryIndex = Code.GetEntryIndex();
                uint offset = Code.GetMethodSize(entryIndex);
                
                <uint, uint> methodSizes = Code.GetMethodSizes();
                foreach (var sz in methodSizes)
                {
                    uint index = sz.key;
                    if (index == entryIndex)
                    {
                        continue;
                    }
                    
                    lsb = (index & 0xFF);
                    msb = (index >> 8);
                    hexeFile.Append(byte(lsb));
                    hexeFile.Append(byte(msb));
                    
                    lsb = (offset & 0xFF);
                    msb = (offset >> 8);
                    hexeFile.Append(byte(lsb));
                    hexeFile.Append(byte(msb));
                    
                    offset = offset + sz.value;
                }
                Parser.ProgressTick("g"); // codegen
                
                // emit data
                writeCode(hexeFile, constantData);
                Parser.ProgressTick("g");  // codegen
                <byte> methodCode = Code.GetMethodCode(entryIndex);
                if (doInstrumenting)
                {
                    instrument(methodCode, entryIndex);
                }
                writeCode(hexeFile, methodCode);
                Parser.ProgressTick("g");  // codegen
                uint progressCount = 0;
                foreach (var sz in methodSizes)
                {
                    uint index = sz.key;
                    if (index == entryIndex)
                    {
                        continue;
                    }
                    methodCode = Code.GetMethodCode(index);
                    if (doInstrumenting)
                    {
                        instrument(methodCode, index);
                    }
                    writeCode(hexeFile, methodCode);   
                    if (progressCount % 64 == 0)
                    {
                        Parser.ProgressTick("g");  // codegen
                    }
                    progressCount++;
                }
                                
                hexeFile.Flush();
                
                if (doIHex)
                {
                    convertToIHex(hexePath);
                }
                if (doInstrumenting)
                {
                    exportStats(instrumentingPath, methodSizes);
                }
                
                if (!Parser.IsInteractive())
                {
                    codeSize = File.GetSize(hexePath);
                    codeSize -= mainOffset;
                    PrintLn();
                    Print("Success, " + codeSize.ToString() + " bytes of code, ", Colour.ProgressText, Colour.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() +"s", Colour.ProgressHighlight, Colour.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                success = true;
                break;
            }
            break;
        }
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }
    }
}
