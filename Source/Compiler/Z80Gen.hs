program Z80Gen
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    
    //#define INLINE_STACK_OPERATIONS
    #define INLINE_OTHER_INSTRUCTIONS
    
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    
    uses "JSON/JSON"
    uses "JSON/Code"
    
    uses "CodeGen/Instructions"
    uses "/Source/Compiler/Symbols"
    //uses "CodeGen/CodeStream"
    
    uses "CODEGEN/AsmZ80"
    
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/Parser"
    
    <string,variant> symbols;
    
    long codeSize = 0;
    <byte> output;
    <uint,uint> patches; // <callLocation,methodIndex>
    <uint,uint> methods; // <methodIndex,address>
    
    uint entryIndex;
    
    bool NoPackedInstructions { get { return false; } }
    
    Emit(OpCode opCode)
    {
        uint ui = uint(opCode);
        if ((ui & 0xFF00) != 0)
        {
            output.Append(byte(ui >> 8));
        }
        output.Append(byte(ui & 0xFF));
    }
    EmitByte(OpCode opCode, byte lsb)
    {
        Emit(opCode);
        EmitByte(lsb);
    }
    EmitOffset(OpCode opCode, int offset)
    {
        if (offset < 0)
        {
            offset += 256;
        }
        byte lsb = byte(offset);
        Emit(opCode);
        EmitByte(lsb);
    }
    EmitOffsetByte(OpCode opCode, int offset, byte msb)
    {
        if (offset < 0)
        {
            offset += 256;
        }
        byte lsb = byte(offset);
        Emit(opCode);
        EmitByte(lsb);
        EmitByte(msb);
    }
    EmitWord(OpCode opCode, uint operand)
    {
        Emit(opCode);
        EmitByte(byte(operand & 0xFF));
        EmitByte(byte(operand >> 8));
    }
    EmitByte(byte lsb)
    {
        output.Append(lsb);
    }
    EmitPushImmediate()
    {
        // assumes the immediate value is in BC   
        EmitByte(OpCode.LD_iIY_d_C, 0);
        Emit(OpCode.INC_IY);
        EmitByte(OpCode.LD_iIY_d_B, 0);
        Emit(OpCode.INC_IY);
#ifndef INLINE_STACK_OPERATIONS        
        Emit(OpCode.RET);
#endif
    }
    EmitPopAbsolute()
    {
        // assumes the address on the stack is in C
        Emit(OpCode.XOR_B);
        EmitWord(OpCode.LD_IX_nn, ValueStackAddress);
        Emit(OpCode.ADD_IX_BC);
        
        Emit(OpCode.DEC_IY);
        EmitByte(OpCode.LD_A_iIY_d, 0);
        EmitOffset(OpCode.LD_iIX_d_A, +1);
        Emit(OpCode.DEC_IY);
        EmitByte(OpCode.LD_A_iIY_d, 0);
        EmitOffset(OpCode.LD_iIX_d_A, +0);
        
#ifndef INLINE_STACK_OPERATIONS        
        Emit(OpCode.RET);
#endif
    }
    
    EmitPushAbsolute()
    {
        // assumes the address on the stack is in C
        Emit(OpCode.XOR_B);
        EmitWord(OpCode.LD_IX_nn, ValueStackAddress);
        Emit(OpCode.ADD_IX_BC);
        
        EmitOffset(OpCode.LD_A_iIX_d, +0);
        EmitByte(OpCode.LD_iIY_d_H, 0);
        Emit(OpCode.INC_IY);
        
        EmitOffset(OpCode.LD_A_iIX_d, +1);
        EmitByte(OpCode.LD_A_iIY_d, 0);
        Emit(OpCode.INC_IY);
        
#ifndef INLINE_STACK_OPERATIONS        
        Emit(OpCode.RET);
#endif
    }
    EmitPushOffset()
    {
        // assumes the offset from BP (DE) on the stack is in BC (both because it could be negative)
        EmitWord(OpCode.LD_IX_nn, ValueStackAddress);
        Emit(OpCode.ADD_IX_DE); // BP
        Emit(OpCode.ADD_IX_BC); // +offset
        
        EmitOffset(OpCode.LD_A_iIX_d, +0);
        EmitOffset(OpCode.LD_iIY_d_A, +0);
        Emit(OpCode.INC_IY);
        
        EmitOffset(OpCode.LD_A_iIX_d, +1);
        EmitOffset(OpCode.LD_iIY_d_A, +0);
        Emit(OpCode.INC_IY);
        
#ifndef INLINE_STACK_OPERATIONS        
        Emit(OpCode.RET);
#endif
    }
    EmitPopOffset()
    {
        // assumes the offset from BP (DE) on the stack is in BC (both because it could be negative)
        EmitWord(OpCode.LD_IX_nn, ValueStackAddress);
        Emit(OpCode.ADD_IX_DE); // BP
        Emit(OpCode.ADD_IX_BC); // +offset
                      
        Emit(OpCode.DEC_IY);
        EmitByte(OpCode.LD_A_iIY_d, 0);
        EmitOffset(OpCode.LD_iIX_d_A, +1);
        Emit(OpCode.DEC_IY);
        EmitByte(OpCode.LD_A_iIY_d, 0);
        EmitOffset(OpCode.LD_iIX_d_A, +0);
        
#ifndef INLINE_STACK_OPERATIONS        
        Emit(OpCode.RET);
#endif
    }
    
    EmitSysCalls()
    {
        // iSysCall is in C, iOverload is in A (0, 1 or 2)
        Emit(OpCode.RET);
    }
    uint compareInstruction(Instruction instruction, uint patchLocation)
    {
        if (patchLocation != 0)
        {
            uint offset = output.Count - patchLocation + 1;
            if (offset > 127) { Die(0x0B); }
            output.SetItem(patchLocation, byte(offset));
            
        }
        EmitByte(OpCode.CP_A_n, byte(instruction));
        patchLocation = output.Count+1;
        EmitByte(OpCode.JR_Z_e, 0);
        return patchLocation;
    }
    
    popBCAndHL() // top -> BC, next -> HL
    {
        EmitOffset(OpCode.LD_C_iIY_d, -2); // LSB
        EmitOffset(OpCode.LD_B_iIY_d, -1); // MSB
        Emit(OpCode.DEC_IY);
        Emit(OpCode.DEC_IY);
        EmitOffset(OpCode.LD_L_iIY_d, -2); // LSB
        EmitOffset(OpCode.LD_H_iIY_d, -1); // MSB   
    }
    
    popBCAndDE() // top -> BC, next -> DE
    {
        EmitOffset(OpCode.LD_C_iIY_d, -2); // LSB
        EmitOffset(OpCode.LD_B_iIY_d, -1); // MSB
        Emit(OpCode.DEC_IY);
        Emit(OpCode.DEC_IY);
        EmitOffset(OpCode.LD_E_iIY_d, -2); // LSB
        EmitOffset(OpCode.LD_D_iIY_d, -1); // MSB   
    }
        
    pushHL() // push HL
    {
        EmitOffset(OpCode.LD_iIY_d_L, -2); // LSB
        EmitOffset(OpCode.LD_iIY_d_H, -1); // MSB
    }
    pushBC() // push BC
    {
        EmitOffset(OpCode.LD_iIY_d_C, -2); // LSB
        EmitOffset(OpCode.LD_iIY_d_B, -1); // MSB
    }   
    pushA() // push A
    {
        EmitOffset(OpCode.LD_iIY_d_A, -2);        // LSB
        EmitOffsetByte(OpCode.LD_iIY_d_n, -1, 0); // MSB
    }
    
    
    utilityDivide() // BC = BC / DE, remainder in HL
    {
        // https://map.grauw.nl/articles/mult_div_shifts.php
        Emit(OpCode.AND_A); // clear carry
// Div16:
        EmitWord(OpCode.LD_HL_nn, 0);
        Emit(OpCode.LD_A_B);
        EmitByte(OpCode.LD_B_n, 8);
// Div16_Loop1:
        Emit(OpCode.RLA);
        Emit(OpCode.ADC_HL_HL);
        Emit(OpCode.SBC_HL_DE);
        EmitOffset(OpCode.JR_NC_e, +4); // Div16_NoAdd1
        Emit(OpCode.ADC_HL_DE);
// Div16_NoAdd1:
        EmitOffset(OpCode.DJNZ_e, -9);// Div16_Loop1
        Emit(OpCode.RLA);
        Emit(OpCode.CLP);
        Emit(OpCode.LD_B_A);
        Emit(OpCode.LD_A_C);
        Emit(OpCode.LD_C_B);
        EmitByte(OpCode.LD_B_n, 8);
// Div16_Loop2:
        Emit(OpCode.RLA);
        Emit(OpCode.ADC_HL_HL);
        Emit(OpCode.SBC_HL_DE);
        EmitOffset(OpCode.JR_NC_e, +4); // Div16_NoAdd2
        Emit(OpCode.ADC_HL_DE);
// Div16_NoAdd2:
        EmitOffset(OpCode.DJNZ_e, -9);// Div16_Loop2
        Emit(OpCode.RLA);
        Emit(OpCode.CLP);
        Emit(OpCode.LD_B_C);
        Emit(OpCode.LD_C_A); 
    }
    utilityMultiply() // DEHL=BC*DE
    {
        // https://tutorials.eeems.ca/Z80ASM/part4.htm
        EmitWord(OpCode.LD_HL_nn, 0);                          
        EmitByte(OpCode.LD_A_n, 16);
//Mul16Loop:
        Emit(OpCode.ADD_HL_HL);
        Emit(OpCode.RL_E);
        Emit(OpCode.RL_D);
        EmitOffset(OpCode.JR_NC_e, +6); // NoMul16:
        Emit(OpCode.ADD_HL_BC);
        EmitOffset(OpCode.JR_NC_e, +3); // NoMul16:
        Emit(OpCode.INC_DE);
//NoMul16:
        Emit(OpCode.DEC_A);
        EmitOffset(OpCode.JR_NZ_e, -12); // //Mul16Loop:
    }
    EmitENTERB()
    {
        // PUSH BP
        Emit(OpCode.PUSH_DE); 
        
        // BP <- SP (DE <- IY)
        Emit(OpCode.PUSH_IY);  
        Emit(OpCode.POP_DE);
        
        Emit(OpCode.LD_B_C);
        EmitOffsetByte(OpCode.LD_iIY_d_n, 0, 0);
        Emit(OpCode.INC_IY);
        EmitOffsetByte(OpCode.LD_iIY_d_n, 0, 0);
        Emit(OpCode.INC_IY);
        EmitOffset(OpCode.DJNZ_e, -6);
    }
    EmitADDB()
    {
        Emit(OpCode.LD_A_C);
        EmitOffset(OpCode.ADD_A_iIY_d, -2); // LSB
        EmitOffset(OpCode.LD_iIY_d_A, -2);
        EmitOffset(OpCode.JR_NC_e, 5);
        EmitOffset(OpCode.INC_iIY_d, -1);
    }
    EmitSUBB()
    {
        Emit(OpCode.XOR_B);
        EmitOffset(OpCode.LD_L_iIY_d, -2); // LSB
        EmitOffset(OpCode.LD_H_iIY_d, -1); // MSB
        Emit(OpCode.SBC_HL_BC);
        EmitOffset(OpCode.LD_iIY_d_L, -2); // LSB
        EmitOffset(OpCode.LD_iIY_d_H, -1); // MSB
    }
    EmitADD()
    {
        EmitOffset(OpCode.LD_B_iIY_d, -2); // LSB
        EmitOffset(OpCode.LD_C_iIY_d, -1); // MSB
        Emit(OpCode.DEC_IY);
        Emit(OpCode.DEC_IY);
        EmitOffset(OpCode.LD_L_iIY_d, -2); // LSB
        EmitOffset(OpCode.LD_H_iIY_d, -1); // MSB
        Emit(OpCode.ADC_HL_BC);
        EmitOffset(OpCode.LD_iIY_d_L, -2); // LSB
        EmitOffset(OpCode.LD_iIY_d_H, -1); // MSB
    }  
    EmitSUB()
    {
        Emit(OpCode.AND_A); // clear carry
        EmitOffset(OpCode.LD_C_iIY_d, -2); // LSB
        EmitOffset(OpCode.LD_B_iIY_d, -1); // MSB
        Emit(OpCode.DEC_IY);
        Emit(OpCode.DEC_IY);
        EmitOffset(OpCode.LD_L_iIY_d, -2); // LSB
        EmitOffset(OpCode.LD_H_iIY_d, -1); // MSB
        Emit(OpCode.SBC_HL_BC);
        EmitOffset(OpCode.LD_iIY_d_L, -2); // LSB
        EmitOffset(OpCode.LD_iIY_d_H, -1); // MSB
    }
    EmitMUL()
    {
        Emit(OpCode.PUSH_DE); // save BP
        popBCAndDE();         // top -> BC, next -> DE
        
        utilityMultiply(); // DEHL=BC*DE
        
        pushHL();            // push HL
        Emit(OpCode.POP_DE); // restore BP
    }
    EmitDIV()
    {
        Emit(OpCode.PUSH_DE); // save BP
        popBCAndDE();         // top -> BC, next -> DE
        
        utilityDivide(); // BC = BC / DE, remainder in HL
        
        pushBC();            // push BC
        Emit(OpCode.POP_DE); // restore BP
    }
    EmitMOD()
    {
        Emit(OpCode.PUSH_DE); // save BP
        popBCAndDE();         // top -> BC, next -> DE
        
        utilityDivide(); // BC = BC / DE, remainder in HL
        
        pushHL();            // push HL
        Emit(OpCode.POP_DE); // restore BP
    }
    
    


    // | Comparison | C flag | Z flag | Meaning                          |
    // |------------|--------|--------|----------------------------------|
    // | A < B      |   1    |   0    | A is less than B                 |
    // | A <= B     |   *    |   1    | A is less than or equal to B     |
    // | A > B      |   0    |   0    | A is greater than B              |
    // | A >= B     |   *    |   1    | A is greater than or equal to B  |
    // | A == B     |   *    |   1    | A is equal to B                  |
    // | A != B     |   *    |   0    | A is not equal to B              |
      
    
    EmitLE()
    {
        popBCAndHL(); // top -> BC, next -> HL 
        // LE: next = HL <= BC ? 1 : 0   
        
        // result = true
        EmitOffsetByte(OpCode.LD_iIY_d_n, -2, 1); // LSB
        EmitOffsetByte(OpCode.LD_iIY_d_n, -1, 0); // MSB
        
        // Compare BC and HL
        Emit(OpCode.LD_A_B);            // MSB     
        Emit(OpCode.CP_A_H);     
        EmitOffset(OpCode.JR_NC_e, +14); // B >= H -> Exit
        EmitOffset(OpCode.JR_Z_e,  +12); // B == H -> Exit

        Emit(OpCode.LD_A_C);            // LSB
        Emit(OpCode.CP_A_L);      
        EmitOffset(OpCode.JR_NC_e, +8); // C >= L -> Exit
        EmitOffset(OpCode.JR_Z_e,  +6); // C == L -> Exit

        // BC < HL -> HL > BC
        EmitOffsetByte(OpCode.LD_iIY_d_n, -2, 0); // LSB
// Exit:        
    }
    
    EmitInstructions()
    {
        uint patchLocation;
        
        // instruction is in A, operand (if any) is in C or BC
        
        // ENTERB - stack slot count is in C
        patchLocation = compareInstruction(Instruction.ENTERB, patchLocation);
        EmitENTERB();
        Emit(OpCode.RET);
        
        // ADDB - operand to add is in C
        patchLocation = compareInstruction(Instruction.ADDB, patchLocation);
        EmitADDB();
        Emit(OpCode.RET);
        
        // SUBB - operand to subtract is in C
        patchLocation = compareInstruction(Instruction.SUBB, patchLocation);
        EmitSUBB();
        Emit(OpCode.RET);
        
        // ADD: next = next + top
        patchLocation = compareInstruction(Instruction.ADD, patchLocation);
        EmitADD();
        Emit(OpCode.RET);
        
        // SUB: next = next + top
        patchLocation = compareInstruction(Instruction.ADD, patchLocation);
        EmitSUB();
        Emit(OpCode.RET);
        
        // MUL: next = next * top
        patchLocation = compareInstruction(Instruction.MUL, patchLocation);
        EmitMUL();
        Emit(OpCode.RET);
               
        // DIV: next = next / top
        patchLocation = compareInstruction(Instruction.DIV, patchLocation);
        EmitDIV();
        Emit(OpCode.RET);
        
        // MOD: next = next % top
        patchLocation = compareInstruction(Instruction.MOD, patchLocation);
        EmitMOD();
        Emit(OpCode.RET);
        
        // LE: next = next <= top ? 1 : 0
        patchLocation = compareInstruction(Instruction.LE, patchLocation);
        EmitLE();
        Emit(OpCode.RET);
                     
        // final patch
        uint offset = output.Count - patchLocation + 1;
        if (offset > 127) { Die(0x0B); }
        output.SetItem(patchLocation, byte(offset));
        
        Emit(OpCode.NOP); // just so we know we missed one
                                
        Emit(OpCode.RET);
    }
    
    writeSystem()
    {
        // exited    = false; - TODO : uses 0xFFFF as invalid address?
        // interruptsEnabled = true; - TODO
        
        // DataMemoryReset(); - TODO
        // External.TimerInitialize(); - TODO
        //
        //      sp = 0;
        // TODO Emit(OpCode.LD_IX_nn, uint(0));
        //      bp = 0;
        // TODO : Emit(OpCode.LD_IY_nn, uint(0));
        //      pc = 0;
        // TODO : Emit(OpCode.LD_BC_nn, uint(0));
        //      csp = 0;
        // since we are not using CSP, initialize hardware stack
        EmitWord(OpCode.LD_SP_nn, CallStackAddress + CallStackSize); // start pointing one byte beyond since it grows downward
               
        //      Error = 0; - TODO
        //      cnp = false;
        
        // placeholder content
        while (output.Count < 256)
        {
#ifndef INLINE_STACK_OPERATIONS  
            if (output.Count == 0x08) // RST_PopAbsolute
            {
                EmitWord(OpCode.JP_nn, 0x0040);
                continue;
            }
            else if (output.Count == 0x40) // RST_PopAbsolute
            {
                EmitPopAbsolute();
                continue;
            }
            else if (output.Count == 0x10) // RST_PushAbsolute
            {
                EmitWord(OpCode.JP_nn, 0x0058);
                continue;
            }
            else if (output.Count == 0x58) // RST_PushAbsolute
            {
                EmitPushAbsolute();
                continue;
            }
            else if (output.Count == 0x18) // RST_PushImmediate
            {
                EmitPushImmediate();
                continue;
            }
            else if (output.Count == 0x20) // RST_PushOffset
            {
                EmitWord(OpCode.JP_nn, 0x0070);
                continue;
            }
            else if (output.Count == 0x70) // RST_PushOffset
            {
                EmitPushOffset();
                continue;
            }
            else if (output.Count == 0x28) // RST_PopOffset
            {
                EmitWord(OpCode.JP_nn, 0x0088);
                continue;
            }
            else if (output.Count == 0x88) // RST_PopOffset
            {
                EmitPopOffset();
                continue;
            }
#endif      
        
            if (output.Count == 0x30) // RST_SysCall0
            {
                EmitWord(OpCode.JP_nn, 0x00A0);
                continue;
            }                
            else if (output.Count == 0x90) // RST_SysCall0
            {
                EmitSysCalls();
                uint targetAddress = output.Count;
                output.SetItem(0x38+1, byte(targetAddress & 0xFF));
                output.SetItem(0x38+2, byte(targetAddress >> 8));
                EmitInstructions();
                continue;
            }                
            else if (output.Count == 0x38) // RST_Instruction
            {
                EmitWord(OpCode.JP_nn, 0x0000); // to be patched
                continue;
            }
            Emit(OpCode.NOP);
        }
    }        
    
    writeMethod(uint methodIndex, <byte> code)
    {
        if (entryIndex == methodIndex)
        {
            writeSystem();
        }        
        uint methodAddress   = output.Count;
        methods[methodIndex] = methodAddress;
        
        //PrintLn(methodIndex.ToHexString(4) + ":");
        
        <uint,uint> instructionAddresses; // <hopperAddress,z80Address>
        
        <uint,int>  jumpPatches;          // <hopperAddress,jumpOffset>
        <uint,uint> jumpPatchLocations;   // <hopperAddress,patchAddress>
        
        uint index = 0;
        loop
        {
            if (index == code.Count) { break; }
            
            uint hopperAddress = index;
            instructionAddresses[hopperAddress] = output.Count;
            
            uint operand;
            Instruction instruction = Instructions.GetOperandAndNextAddress(code, ref index, ref operand);
            string instructionName = Instructions.ToString(instruction);
            
            
            bool isStackOffset;
            bool isAddressOffset;
            bool isRET;
            byte width = Instructions.GetKitchenSinkWidth(instruction, ref isStackOffset, ref isAddressOffset, ref isRET);
            
            if (width == 0)
            {
                // Examples: EQ, NOP, ADD ..
                switch (instruction)
                {
                    case Instruction.ENTER:
                    {
                        // PUSH BP
                        Emit(OpCode.PUSH_DE); 
                        
                        // BP <- SP (DE <- IY)
                        Emit(OpCode.PUSH_IY);  
                        Emit(OpCode.POP_DE);
                    }
                    case Instruction.RET0:
                    {
                         Emit(OpCode.POP_DE); // POP BP
                         Emit(OpCode.RET);
                    }
                    case Instruction.RETFAST:
                    {
                         Emit(OpCode.RET);
                    }
                    case Instruction.NOP:
                    {
                        Emit(OpCode.NOP);
                    }
                    case Instruction.PUSHI0:
                    {
                        EmitWord(OpCode.LD_BC_nn, uint(0));
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushImmediate();
#else
                        Emit(OpCode.RST_PushImmediate);
#endif                        
                    }
                    case Instruction.PUSHI1:
                    {
                        EmitWord(OpCode.LD_BC_nn, uint(1));
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushImmediate();
#else
                        Emit(OpCode.RST_PushImmediate);
#endif                        
                    }
                    case Instruction.PUSHIM1:
                    {
                        EmitWord(OpCode.LD_BC_nn, 0xFFFF);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushImmediate();
#else                        
                        Emit(OpCode.RST_PushImmediate);
#endif
                    }
                    case Instruction.PUSHLOCALB00:
                    {
                        EmitWord(OpCode.LD_BC_nn, 0);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushOffset();
#else                        
                        Emit(OpCode.RST_PushOffset);
#endif
                    }
                    case Instruction.PUSHLOCALB01:
                    {
                        EmitWord(OpCode.LD_BC_nn, 1);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushOffset();
#else                        
                        Emit(OpCode.RST_PushOffset);
#endif
                    }
                    case Instruction.POPLOCALB00:
                    {
                        EmitWord(OpCode.LD_BC_nn, 0);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPopOffset();
#else                        
                        Emit(OpCode.RST_PopOffset);
#endif
                    }
                    case Instruction.POPLOCALB01:
                    {
                        EmitWord(OpCode.LD_BC_nn, 1);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPopOffset();
#else                        
                        Emit(OpCode.RST_PopOffset);
#endif
                    }
                    default:
                    {
#ifdef INLINE_OTHER_INSTRUCTIONS
                        switch (instruction)
                        {
                            case Instruction.ADD:
                            {
                                EmitADD();
                            }
                            case Instruction.SUB:
                            {
                                EmitSUB();
                            }
                            case Instruction.MUL:
                            {
                                EmitMUL();
                            }
                            case Instruction.DIV:
                            {
                                EmitDIV();
                            }
                            case Instruction.MOD:
                            {
                                EmitMOD();
                            }
                            default:
                            {
                                EmitByte(OpCode.LD_A_n, byte(instruction));
                                Emit(OpCode.RST_Instruction);
                                Print(instructionName + " ");
                            }
                        }
#else                        
                        EmitByte(OpCode.LD_A_n, byte(instruction));
                        Emit(OpCode.RST_Instruction);
#endif
                        //Print(instructionName + " ");
                    }
                }
            }
            else if (width == 1)
            {
                switch (instruction)
                {
                    case Instruction.RETB:
                    {
                        if (operand == 1)
                        {
                            Emit(OpCode.DEC_IY);
                            Emit(OpCode.DEC_IY);
                            Emit(OpCode.POP_DE); // POP BP
                            Emit(OpCode.RET);
                        }
                        else
                        {
                            EmitByte(OpCode.LD_B_n, byte(operand));
                            Emit(OpCode.DEC_IY);
                            Emit(OpCode.DEC_IY);
                            EmitOffset(OpCode.DJNZ_e, -4);
                            
                            Emit(OpCode.POP_DE); // POP BP
                            Emit(OpCode.RET);
                        }
                    }
                    case Instruction.RETRESB:
                    {
                        EmitOffset(OpCode.LD_L_iIY_d, -2); // LSB
                        EmitOffset(OpCode.LD_H_iIY_d, -1); // MSB
                        
                        EmitByte(OpCode.LD_B_n, byte(operand));
                        Emit(OpCode.DEC_IY);
                        Emit(OpCode.DEC_IY);
                        EmitOffset(OpCode.DJNZ_e, -4);
    
                        EmitOffset(OpCode.LD_iIY_d_L, -2); // LSB
                        EmitOffset(OpCode.LD_iIY_d_H, -1); // MSB
                        
                        Emit(OpCode.POP_DE); // POP BP
                        Emit(OpCode.RET);
                    }
                    case Instruction.DECSP:
                    {
                        if (operand == 1)
                        {
                            Emit(OpCode.DEC_IY);
                            Emit(OpCode.DEC_IY);
                        }
                        else
                        {
                            EmitByte(OpCode.LD_B_n, byte(operand));
                            Emit(OpCode.DEC_IY);
                            Emit(OpCode.DEC_IY);
                            EmitOffset(OpCode.DJNZ_e, -4);
                        }
                    }
                    case Instruction.PUSHIB:
                    {
                        EmitWord(OpCode.LD_BC_nn, operand);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushImmediate();
#else                        
                        Emit(OpCode.RST_PushImmediate);   
#endif 
                    }
                    case Instruction.PUSHLOCALB:
                    {
                        if ((operand & 0x80) != 0)
                        {
                            operand |= 0xFF00;
                        }
                        EmitWord(OpCode.LD_BC_nn, operand);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushOffset();
#else                        
                        Emit(OpCode.RST_PushOffset);
#endif
                    }
                    case Instruction.POPLOCALB:
                    {
                        if ((operand & 0x80) != 0)
                        {
                            operand |= 0xFF00;
                        }
                        EmitWord(OpCode.LD_BC_nn, operand);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPopOffset();
#else                        
                        Emit(OpCode.RST_PopOffset);
#endif
                    }
                    case Instruction.PUSHGLOBALB:
                    {
                        EmitByte(OpCode.LD_C_n, byte(operand));
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushAbsolute();
#else                        
                        Emit(OpCode.RST_PushAbsolute);
#endif
                    }
                    case Instruction.POPGLOBALB:
                    {
                        EmitByte(OpCode.LD_C_n, byte(operand));
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushAbsolute();
#else                        
                        Emit(OpCode.RST_PopAbsolute);
#endif
                    }
                    case Instruction.JNZB:
                    {
                        Emit(OpCode.DEC_IY);   // SP--
                        EmitByte(OpCode.LD_A_iIY_d, 0); // A <- [SP]
                        Emit(OpCode.DEC_IY);   // SP--
                        EmitByte(OpCode.OR_A_iIY_d, 0); // A = A | [SP] -> Z?
                        
                        EmitOffset(OpCode.JR_Z_e, 5);
                        EmitWord(OpCode.JP_nn, uint(0));
                        int offset = byte(operand);
                        if (offset > 127)
                        {
                            offset -= 256;
                        }
                        jumpPatchLocations[hopperAddress] = output.Count - 2;
                        jumpPatches[hopperAddress]        = offset;
                    }
                    case Instruction.JZB:
                    {
                        Emit(OpCode.DEC_IY);   // SP--
                        EmitByte(OpCode.LD_A_iIY_d, 0); // A <- [SP]
                        Emit(OpCode.DEC_IY);   // SP--
                        EmitByte(OpCode.OR_A_iIY_d, 0); // A = A | [SP] -> Z?
                        
                        EmitOffset(OpCode.JR_NZ_e, 5);
                        EmitWord(OpCode.JP_nn, uint(0));
                        int offset = byte(operand);
                        if (offset > 127)
                        {
                            offset -= 256;
                        }
                        jumpPatchLocations[hopperAddress] = output.Count - 2;
                        jumpPatches[hopperAddress]        = offset;
                    }
                    case Instruction.JB:
                    {
                        EmitWord(OpCode.JP_nn, uint(0));
                        int offset = byte(operand);
                        if (offset > 127)
                        {
                            offset -= 256;
                        }
                        jumpPatchLocations[hopperAddress] = output.Count - 2;
                        jumpPatches[hopperAddress]        = offset;
                    }
                    case Instruction.SYSCALL0:
                    {
                        Emit(OpCode.XOR_A); // iOverload = 0;
                        EmitByte(OpCode.LD_C_n, byte(operand & 0xFF));
                        Emit(OpCode.RST_SysCall0);
                    }
                    case Instruction.CAST:
                    {
                        // NOP since we have no reference types and no type stack
                        Emit(OpCode.NOP);
                    }
                    case Instruction.JIXB:
                    {
                        Emit(OpCode.NOP);
                        PrintLn(instructionName + " not implemented");
                    }
                    
                    case Instruction.PUSHIBLE:
                    {
                        EmitWord(OpCode.LD_BC_nn, operand);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushImmediate();
#else                        
                        EmitByte(OpCode.LD_A_n, byte(Instruction.PUSHIB));
                        Emit(OpCode.RST_PushImmediate);   
#endif
#ifdef INLINE_OTHER_INSTRUCTIONS
                        EmitLE();
#else
                        EmitByte(OpCode.LD_A_n, byte(Instruction.LE));
                        Emit(OpCode.RST_Instruction);
#endif
                    }
                    
                    default:
                    {
#ifdef INLINE_OTHER_INSTRUCTIONS
                        switch (instruction)
                        {
                            case Instruction.ADDB:
                            {
                                EmitWord(OpCode.LD_BC_nn, operand);
                                EmitADDB();
                            }
                            case Instruction.SUBB:
                            {
                                EmitWord(OpCode.LD_BC_nn, operand);
                                EmitSUBB();
                            }
                            case Instruction.ENTERB:
                            {
                                EmitByte(OpCode.LD_C_n, byte(operand));
                                EmitENTERB();
                            }
                            case Instruction.PUSHIBLE:
                            {
                                EmitWord(OpCode.LD_BC_nn, operand);
#ifdef INLINE_STACK_OPERATIONS
                                EmitPushImmediate();
#else                        
                                EmitByte(OpCode.LD_A_n, byte(Instruction.PUSHIB));
                                Emit(OpCode.RST_PushImmediate);  
#endif 
                                EmitLE();
                            }
       
                            default:
                            {
                                EmitByte(OpCode.LD_A_n, byte(instruction));
                                EmitWord(OpCode.LD_BC_nn, operand);
                                Emit(OpCode.RST_Instruction);
                                Print(instructionName + ":" + operand.ToHexString(2) + " ");
                            }
                        }
#else                         
                        EmitByte(OpCode.LD_A_n, byte(instruction));
                        EmitWord(OpCode.LD_BC_nn, operand);
                        Emit(OpCode.RST_Instruction);
#endif                        
                        //Print(instructionName + ":" + operand.ToHexString(2) + " ");
                    }
                }
            }
            else if (width == 2)
            {
                
                switch (instruction)
                {
                    case Instruction.RET:
                    {
                        if (operand == 0)
                        {
                            Emit(OpCode.POP_DE); // POP BP
                            Emit(OpCode.RET);
                        }
                        else if (operand == 1)
                        {
                            Emit(OpCode.DEC_IY);
                            Emit(OpCode.DEC_IY);
                            Emit(OpCode.POP_DE); // POP BP
                            Emit(OpCode.RET);
                        }
                        else
                        {
                            if (operand > 255) { Die(0x0B); } // unlikely to happen
                            EmitByte(OpCode.LD_B_n, byte(operand & 0xFF));
                            Emit(OpCode.DEC_IY);
                            Emit(OpCode.DEC_IY);
                            EmitOffset(OpCode.DJNZ_e, -4);
                            
                            Emit(OpCode.POP_DE); // POP BP
                            Emit(OpCode.RET);
                        }
                    }
                    
                    case Instruction.SYSCALLB0:
                    {
                        EmitWord(OpCode.LD_BC_nn, operand & 0xFF);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushImmediate();
#else                        
                        Emit(OpCode.RST_PushImmediate);   
#endif                         
                        EmitByte(OpCode.LD_C_n, byte(operand >> 8));
                        Emit(OpCode.XOR_A); // iOverload = 0;
                        Emit(OpCode.RST_SysCall0);
                    }
                    
                    case Instruction.PUSHI:
                    {
                        EmitWord(OpCode.LD_BC_nn, operand);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushImmediate();
#else                        
                        Emit(OpCode.RST_PushImmediate);
#endif
                        
                    }
                    case Instruction.PUSHLOCAL:
                    {
                        if ((operand & 0x80) != 0)
                        {
                            operand |= 0xFF00;
                        }
                        EmitWord(OpCode.LD_BC_nn, operand);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushOffset();
#else                        
                        Emit(OpCode.RST_PushOffset);
#endif
                    }
                    case Instruction.PUSHLOCALBB:
                    {
                        uint address = operand & 0xFF;
                        if ((address & 0x80) != 0)
                        {
                            address |= 0xFF00;
                        }
                        EmitWord(OpCode.LD_BC_nn, address);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushOffset();
#else                                                
                        Emit(OpCode.RST_PushOffset);
#endif
                        
                        address = operand >> 8;
                        if ((address & 0x80) != 0)
                        {
                            address |= 0xFF00;
                        }
                        EmitWord(OpCode.LD_BC_nn, address);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushOffset();
#else                        
                        Emit(OpCode.RST_PushOffset);
#endif
                    }
                    case Instruction.POPLOCAL:
                    {
                        if ((operand & 0x80) != 0)
                        {
                            operand |= 0xFF00;
                        }
                        EmitWord(OpCode.LD_BC_nn, operand);
#ifdef INLINE_STACK_OPERATIONS
                        EmitPopOffset();
#else                        
                        Emit(OpCode.RST_PopOffset);
#endif
                    }
                    case Instruction.PUSHGLOBAL:
                    {
                        EmitByte(OpCode.LD_C_n, byte(operand & 0xFF)); // it is only an 8 bit stack!
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushAbsolute();
#else                        
                        Emit(OpCode.RST_PushAbsolute);
#endif
                    }
                    case Instruction.PUSHGLOBALBB:
                    {
                        EmitByte(OpCode.LD_C_n, byte(operand & 0xFF));
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushAbsolute();
#else                        
                        Emit(OpCode.RST_PushAbsolute);
#endif
                        EmitByte(OpCode.LD_C_n, byte(operand >> 8));
#ifdef INLINE_STACK_OPERATIONS
                        EmitPushAbsolute();
#else                        
                        Emit(OpCode.RST_PushAbsolute);
#endif
                    }
                    
                    case Instruction.J:
                    {
                        EmitWord(OpCode.JP_nn, uint(0));
                        jumpPatches[hopperAddress]        = Int.FromBytes(byte(operand & 0xFF), byte(operand >> 8));
                        jumpPatchLocations[hopperAddress] = output.Count - 2;
                    }
                    case Instruction.CALL:
                    {
                        EmitWord(OpCode.CALL_nn, uint(operand));
                        patches[output.Count-2] = operand;
                    }
                    
                    
                    default:
                    {
#ifdef INLINE_OTHER_INSTRUCTIONS
                        switch (instruction)
                        {
                            default:
                            {
                                EmitByte(OpCode.LD_A_n, byte(instruction));
                                EmitWord(OpCode.LD_BC_nn, operand);
                                Emit(OpCode.RST_Instruction);
                                Print(instructionName + ":" + operand.ToHexString(4) + " ");
                            }
                        }
#else                        
                        EmitByte(OpCode.LD_A_n, byte(instruction));
                        EmitWord(OpCode.LD_BC_nn, operand);
                        Emit(OpCode.RST_Instruction);
                        if ((instruction == Instruction.JIX)||(instruction == Instruction.JIXB))
                        {
                            PrintLn(instructionName + " not implemented");
                        }
                        //Print(instructionName + ":" + operand.ToHexString(4) + " ");
#endif
                    }
                }
            }
            else
            {
                //Other   = 0xFF, // 0x38
                
                // JIXB and JIXW
                PrintLn(instructionName + " not implemented");
            }
            //if (methodIndex == 0x0020)
            //{
            //    PrintLn((hopperAddress + 0x08CF).ToHexString(4) + "->" + (instructionAddresses[hopperAddress]).ToHexString(4));
            //}
        }
        
        // <uint,uint> instructionAddresses; // <hopperAddress,z80Address>
        // <uint,int>  jumpPatches;          // <hopperAddress,jumpOffset>
        // <uint,uint> jumpPatchLocations    // <hopperAddress,patchAddress>
        //PrintLn(methodIndex.ToString() + ":");
        foreach (var kv in jumpPatches)
        {
            
            uint hopperJumpLocation = kv.key;
            int  offset = kv.value;
            
            uint hopperJumpTarget = uint(int(hopperJumpLocation) + offset);
            if (!instructionAddresses.Contains(hopperJumpTarget))
            {
                PrintLn("Patch failed: " + hopperJumpLocation.ToHexString(4) + " " + offset.ToString() + " " + hopperJumpTarget.ToHexString(4));
            }
            else
            {
                uint targetAddress    = instructionAddresses[hopperJumpTarget];
                uint patchLocation    = jumpPatchLocations[hopperJumpLocation];
            
                // PATCH
                output.SetItem(patchLocation+0, byte(targetAddress & 0xFF));
                output.SetItem(patchLocation+1, byte(targetAddress >> 8));
            }
        }
        <string,string> debugInfo = Code.GetMethodDebugInfo(methodIndex);
        <string,string> z80DebugInfo;
        foreach (var kv in debugInfo)
        {
            string hopperAddress = kv.key;
            string lineNumber    = kv.value;
            uint hopperIndex;
            _ = UInt.TryParse(hopperAddress, ref hopperIndex);
            uint z80Index = instructionAddresses[hopperIndex];
            z80DebugInfo[z80Index.ToString()] = lineNumber;
        }
        // save the modified debugInfo
        Code.SetMethodDebugInfo(methodIndex, z80DebugInfo);
    }
        
    doCallPatches()
    {
        // <uint,uint> patches; // <callLocation,methodIndex>
        // <uint,uint> methods; // <methodIndex,address>
        foreach (var kv in patches)
        {
            uint patchAddress  = kv.key;
            uint targetMethod  = kv.value;
            uint targetAddress = methods[targetMethod];
            // PATCH
            output.SetItem(patchAddress+0, byte(targetAddress & 0xFF));
            output.SetItem(patchAddress+1, byte(targetAddress >> 8));
        }
        output.SetItem(0, byte(methods[entryIndex] & 0xFF));
        output.SetItem(1, byte(methods[entryIndex] >> 8));
    }
    
    badArguments()
    {
        PrintLn("Invalid arguments for Z80GEN:");
        PrintLn("  Z80GEN <code file>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
    }
    
    byte hexCheckSum(string values)
    {
        uint sum = 0;
        for (uint i = 0; i < values.Length / 2; i++)
        {
            string substr = values.Substring(i * 2, 2);
            uint b = 0;
            if (UInt.TryParse("0x" + substr, ref b))
            {
            }
            sum = sum + b;
        }
        sum = sum % 256;
        byte chk = byte(sum);
        chk = ~chk;
        chk++;
        return chk;
    }
    
    emitBuffer(file ihexFile, uint address, string buffer)
    {
        uint bytes = buffer.Length / 2;
        string ln = bytes.ToHexString(2) + address.ToHexString(4) + "00" + buffer;
        byte chk = hexCheckSum(ln);
        ihexFile.Append(":" + ln + chk.ToHexString(2) + char(0x0A));
    }
    
    writeIHex(file ihexFile, uint romAddress, <byte> output)
    {
        // https://en.wikipedia.org/wikie/Intel_HEX#Format
        
        uint byteCount = 0;
        uint index = 0;
        
        byte currentTick = 0;
        string progressTicks = "-\\|/-\\|/";
        
        string buffer;
        uint emitAddress = 0;
        loop
        {
            if (index == output.Count)
            {
                // done
                break;
            }
            byte cb = output[index]; index++;
            
            buffer = buffer + cb.ToHexString(2);
            if (buffer.Length == 32)
            {
                emitBuffer(ihexFile, emitAddress + romAddress, buffer);
                emitAddress = emitAddress + 16;
                buffer = "";
            }
            
            byteCount++;
            if (byteCount % 32 == 0)
            {
                Parser.ProgressTick("x");
            }
        }
        if (buffer.Length != 0)
        {
            emitBuffer(ihexFile, emitAddress + romAddress, buffer);
            buffer = "";
        }
        
        ihexFile.Append(":00000001FF" + char(0x0A)); // eof
        ihexFile.Flush();
    }
    
    Hopper()
    {
        bool success = false;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length >= 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Count != 1)
            {
                badArguments();
                break;
            }
            string ext = ".code";
            string codePath = args[0];
            if (!File.Exists(ref codePath, ref ext, "/Debug/Obj/"))
            {
                badArguments();
            }
            
            long startTime = Millis;
            loop
            {
                string extension = Path.GetExtension(codePath);
                string ihexPath  = codePath.Replace(extension, ".hex");
                string symbolsPath = codePath.Replace(extension, ".json");
                
                ihexPath = Path.GetFileName(ihexPath);
                ihexPath = Path.Combine("/Bin/", ihexPath);
                File.Delete(ihexPath);

                file ihexFile = File.Create(ihexPath);
                if (!ihexFile.IsValid())
                {
                    PrintLn("Failed to create '" + ihexPath + "'");
                    break;
                }

                Symbols.New();
                if (File.Exists(symbolsPath))
                {
                    if (Symbols.Import(symbolsPath, false))
                    {
                        CodeStream.InitializeSymbolShortcuts();
                    }
                }
                
                if (!ParseCode(codePath, true, true))
                {
                    break;
                }
                
                uint methodCount = Code.GetMethodCount();
                
                <byte> constantData = Code.GetConstantData();
                if (constantData.Count != 0)
                {
                    PrintLn("Unexpected constant data"); // reference types not supported
                    break;
                }
                entryIndex = Code.GetEntryIndex();
                <uint, uint> methodSizes = Code.GetMethodSizes();
                Parser.ProgressTick(".");
                
                patches[0x0000] = entryIndex; // Z80 reset entrypoint
                EmitByte(byte(0));
                EmitByte(byte(0));
                
                <byte> methodCode = Code.GetMethodCode(entryIndex);
                writeMethod(entryIndex, methodCode);
                Parser.ProgressTick(".");
                uint indexMax = 0;
                foreach (var sz in methodSizes)
                {
                    if (sz.key > indexMax)
                    {
                        indexMax = sz.key;
                    }
                }
                // if we emit the methods in increasing order of indices
                // then we can find them again in the binary (for debug info)
                for (uint index = 0; index <= indexMax; index++)
                {
                    if (index == entryIndex)          { continue; }
                    if (!methodSizes.Contains(index)) { continue; }   
                    methodCode = Code.GetMethodCode(index);
                    writeMethod(index, methodCode);   
                    Parser.ProgressTick(".");
                }
                doCallPatches();
                Parser.ProgressTick(".");
                
                writeIHex(ihexFile, 0x0000, output);
                File.Delete(codePath);
                if (!Code.ExportCode(codePath)) // after
                {
                    break;
                }
                codeSize = output.Count;
                if (!Parser.IsInteractive())
                {
                    PrintLn();
                    Print("Success, " + codeSize.ToString() + " bytes of code, ", Colour.ProgressText, Colour.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() +"s", Colour.ProgressHighlight, Colour.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                success = true;
                break;
            }
            break;
        }
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }
    }
}
