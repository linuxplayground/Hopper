program Z80Gen
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    
    //#define INLINE_STACK_OPERATIONS
    //#define INLINE_OTHER_INSTRUCTIONS
    
    #define CHECKED
//  #define PATCHCHECKED
    
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    
    uses "JSON/JSON"
    uses "JSON/Code"
    
    uses "CodeGen/Instructions"
    uses "Symbols"
    
    uses "/Source/Runtime/Platform/SysCalls"
    
    
    uses "CODEGEN/AsmZ80"
    uses "CODEGEN/Z80Library"
    uses "CODEGEN/Z80Peephole"
    
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/Parser"
    
    <string,variant> symbols;
    
    long codeSize = 0;
    <byte> output;
    <uint,uint> patches;         // <callLocation,methodIndex>
    <uint,uint> methods;         // <methodIndex,address>
    
    <string,bool> missingOpCodes;
    
    uint entryIndex;
    
    bool NoPackedInstructions { get { return false; } }
    
    uint CurrentAddress { get { return output.Count; } }
    
    reset()
    {
        // exited    = false; - TODO : uses 0xFFFF as invalid address?
        // interruptsEnabled = true; - TODO
        
        // DataMemoryReset(); - TODO
        // External.TimerInitialize(); - TODO
        //
        //      sp = 0;
        
        //      bp = 0;
        
               
        //      Error = 0;
        Emit(OpCode.XOR_A_A);
        EmitWord(OpCode.LD_inn_A, LastError);
        
        //      cnp = false;
        
    }
    
    /*
    patchRSTJump(uint rst, uint targetAddress)
    {
        uint offset = targetAddress - rst - 2;
        if (offset < 127)
        {
            output.SetItem(rst+0, byte(OpCode.J R_e));
            output.SetItem(rst+1, byte(offset));
        }
        else
        {
            output.SetItem(rst+1, byte(targetAddress & 0xFF));
            output.SetItem(rst+2, byte(targetAddress >> 8));
        }
    }
    */
    
    PatchByte(uint address, byte value)
    {
        patchByte(address, value);
    }
    bool firstBadPatch = true;
    bool firstPatchFailed = true;
    bool firstOpNotImplemented = true;
    patchByte(uint address, byte value)
    {
        if (address >= output.Count)
        {
            if (firstBadPatch)
            {
                PrintLn(" Bad patchByte: 0x" + address.ToHexString(4));
            }
            firstBadPatch = false;
        }
        else
        {
            output.SetItem(address, value);
        }
    }
    
    bool jumpPatch(uint methodIndex, uint patchLocation, uint targetAddress, uint methodAddress, uint methodLength)
    {
        bool success;
        loop
        {
#ifdef PATCHCHECKED            
            if ((patchLocation < methodAddress) || (patchLocation > methodAddress+methodLength-2))
            {
                PrintLn("0x" + methodIndex.ToHexString(4) + ": jumpPatch: patchLocation 0x" + patchLocation.ToHexString(4) + 
                        " outside method [0x"+methodAddress.ToHexString(4)+"-0x"+(methodAddress+methodLength-2).ToHexString(4) +"]");
                break;
            }
            if ((targetAddress < methodAddress) || (targetAddress > methodAddress+methodLength-2))
            {
                PrintLn("0x" + methodIndex.ToHexString(4) + ": jumpPatch: targetAddress 0x" + targetAddress.ToHexString(4) +
                        " outside method [0x"+methodAddress.ToHexString(4)+"-0x"+(methodAddress+methodLength-2).ToHexString(4) +"]");
                break;
            }
            OpCode jump = OpCode(output[patchLocation-1]);
            switch (jump)
            {
                case OpCode.JP_nn:
                case OpCode.JP_Z_nn:
                case OpCode.JP_NZ_nn:
                {
                }
                default:
                {
                    PrintLn("0x" + methodIndex.ToHexString(4) + ": jumpPatch: targetAddress-1 0x" + (targetAddress-1).ToHexString(4) + " is not a jump instruction (" + (output[patchLocation-1]).ToHexString(2) + ")");
                    break;
                }
            }
#endif
            // PATCH
            patchByte(patchLocation+0, byte(targetAddress & 0xFF));
            patchByte(patchLocation+1, byte(targetAddress >> 8));
            success = true;
            break;
        } // loop
        return success;
    }           
        
    doCallPatches(bool onlyEntry)
    {
        if (!onlyEntry)
        {
            // <uint,uint> patches; // <callLocation,methodIndex>
            // <uint,uint> methods; // <methodIndex,address>
            foreach (var kv in patches)
            {
                uint patchAddress  = kv.key;
                uint targetMethod  = kv.value;
                uint targetAddress = methods[targetMethod];
            
#ifdef PATCHCHECKED  
                bool patchOk = false;          
                OpCode instruction = GetOpCode(output, patchAddress-1);
                patchOk = (instruction == OpCode.CALL_nn);
                if (!patchOk)
                {
                    OpCode instruction1 = GetOpCode(output, patchAddress-3);
                    patchOk = (instruction == OpCode.LD_DE_nn) && (instruction1 == OpCode.DDDD); // PUSHD signature
                }
                if (!patchOk)
                {
                    PrintLn("doCallPatches: patchLocation-1 0x" + (patchAddress-1).ToHexString(4) + " is not a CALL instruction (" + (uint(instruction)).ToHexString(4) + ")");
                    continue;
                }
#endif
                // PATCH
                patchByte(patchAddress+0, byte(targetAddress & 0xFF));
                patchByte(patchAddress+1, byte(targetAddress >> 8));
            }
        }
        patchByte(4, byte(methods[entryIndex] & 0xFF));
        patchByte(5, byte(methods[entryIndex] >> 8));
    }
    
    emit(OpCode opCode)
    {
        Peephole.AddInstruction(output.Count);
        uint ui = uint(opCode);
        if ((ui & 0xFF00) != 0)
        {
            output.Append(byte(ui >> 8));
        }
        output.Append(byte(ui & 0xFF));
    }
    Emit(OpCode opCode)
    {
        emit(opCode);
        Peephole.Optimize(output);
        switch (opCode)
        {
            case OpCode.JP_HL:
            case OpCode.RET:
            case OpCode.HALT:
            {
                Peephole.Reset();
            }
        }
    }
    EmitByte(OpCode opCode, byte lsb)
    {
        emit(opCode);
        emitByte(lsb);
        Peephole.Optimize(output);
    }
    
    EmitOffset(OpCode opCode, int offset)
    {
        if (offset < 0)
        {
            offset += 256;
        }
        byte lsb = byte(offset);
        emit(opCode);
        emitByte(lsb);
        
        switch (opCode)
        {
            case OpCode.JR_NZ_e:
            case OpCode.JR_Z_e:
            case OpCode.JR_NC_e:
            case OpCode.JR_C_e:
            case OpCode.JR_e:
            {
                Peephole.Reset();
            }
        }
        Peephole.Optimize(output);
    }
    
    EmitOffsetByte(OpCode opCode, int offset, byte msb)
    {
        if (offset < 0)
        {
            offset += 256;
        }
        byte lsb = byte(offset);
        emit(opCode);
        emitByte(lsb);
        emitByte(msb);
        
        switch (opCode)
        {
            case OpCode.JR_NZ_e:
            case OpCode.JR_Z_e:
            case OpCode.JR_NC_e:
            case OpCode.JR_C_e:
            case OpCode.JR_e:
            {
                Die(0x0B); // Peephole.Reset();
            }
        }
        Peephole.Optimize(output);
    }

    EmitWord(OpCode opCode, uint operand)
    {
        emit(opCode);
        emitByte(byte(operand & 0xFF));
        emitByte(byte(operand >> 8));
        
        switch (opCode)
        {
            case OpCode.JP_nn:
            case OpCode.JP_Z_nn:
            case OpCode.JP_NZ_nn:
            {
                Peephole.Reset();
            }
        }
        
        Peephole.Optimize(output);
    }
    emitByte(byte lsb)
    {
        output.Append(lsb);
    }
    
    writeSystem()
    {
        while (output.Count < 256)
        {
            if (output.Count == 0x0040) // after the RSTx slots
            {
                Z80Library.Generate();
                break;
            }
            Emit(OpCode.NOP);
        }
    }  
    
    byte offsetOperandToByte(uint operand)
    {
        // calculate the 8-bit signed Hopper offset
        int ioffset = byte(operand & 0xFF);
        if (ioffset > 127)
        {
            ioffset = ioffset - 256;
        }
        
        // invert the sign since the Z80 stack grows downward
        ioffset = -ioffset;
        
        // double it to convert from stack slots to bytes
        ioffset *= 2;
        if (ioffset > 0)
        {
            ioffset += 2; // to skip BP
        }
        else
        {
            ioffset -= 2; // to skip BP
        }
        
        byte byteOffset = ioffset.GetByte(0);        
        return byteOffset;
    }   
        
    uint addressOperandToByte(uint operand)
    {
        // calculate the 8-bit signed Hopper address
        int iaddress = byte(operand & 0xFF);
        
        // invert the sign since the Z80 stack grows downward
        iaddress = -iaddress;
        
        // double it to convert from stack slots to bytes
        iaddress *= 2;
        
        iaddress -= 4; // skip:
                       // - the return address from startup
                       // - the first slot itself
        
        long address = long(StackAddress) + long(StackSize) + iaddress;
        //PrintLn(operand.ToString() + " " + iaddress.ToString() + " -> 0x" + address.ToHexString(4));
        return uint(address);
    }
    
    pushLocalB(uint operand)
    {
        byte offset = offsetOperandToByte(operand);
        EmitByte(OpCode.LD_E_iIY_d, offset);
        EmitByte(OpCode.LD_D_iIY_d, offset + 1);
        Emit(OpCode.PUSH_DE);
    }
    popLocalB(uint operand)
    {    
        byte offset = offsetOperandToByte(operand);
        Emit(OpCode.POP_DE);
        EmitByte(OpCode.LD_iIY_d_E, offset);
        EmitByte(OpCode.LD_iIY_d_D, offset + 1);
    }
    
    incLocalBB(uint operand0, uint operand1)
    {
        byte offset0 = offsetOperandToByte(operand0);
        byte offset1 = offsetOperandToByte(operand1);
        EmitByte(OpCode.LD_E_iIY_d, offset0);
        EmitByte(OpCode.LD_D_iIY_d, offset0 + 1);
        EmitByte(OpCode.LD_L_iIY_d, offset1);
        EmitByte(OpCode.LD_H_iIY_d, offset1 + 1);
        Emit(OpCode.ADD_HL_DE);
        EmitByte(OpCode.LD_iIY_d_H, offset0);
        EmitByte(OpCode.LD_iIY_d_L, offset0 + 1);
        
    }
    
    incLocalB(uint operand)
    {
        byte offset = offsetOperandToByte(operand);
        Peephole.Disabled = true;
        EmitByte  (OpCode.INC_iIY_d, offset);
        EmitOffset(OpCode.JR_NZ_e,    +3);    // did it overflow from 0xFF back around to 0x00?
        EmitByte  (OpCode.INC_iIY_d, offset+1);
        Peephole.Disabled = false;
        Peephole.Reset();
    }
    decLocalB(uint operand)
    {
        byte offset = offsetOperandToByte(operand);
        Peephole.Disabled = true;
        EmitByte  (OpCode.DEC_iIY_d,  offset);
        EmitByte  (OpCode.LD_A_n,       0xFF);
        EmitByte  (OpCode.CP_A_iIY_d, offset); // wrapped around from 0x00 to 0xFF?
        EmitOffset(OpCode.JR_NZ_e,        +3);
        EmitByte  (OpCode.DEC_iIY_d,  offset+1);
        Peephole.Disabled = false;
        Peephole.Reset();
    }
    pushStackAddrB(uint operand)
    {
        byte offset = offsetOperandToByte(operand);
        Emit(OpCode.PUSH_IY);
        Emit(OpCode.POP_IX);
        EmitByte(OpCode.LD_E_iIY_d, offset);
        EmitByte(OpCode.LD_D_iIY_d, offset + 1);
        Emit(OpCode.ADD_IX_DE);  // absolute address is now in IX
        Emit(OpCode.POP_IX);
    }
    pushRelB(uint operand)
    {
        byte offset = offsetOperandToByte(operand);
        Emit(OpCode.PUSH_IY);
        Emit(OpCode.POP_IX);
        EmitByte(OpCode.LD_E_iIY_d, offset);
        EmitByte(OpCode.LD_D_iIY_d, offset + 1);
        Emit(OpCode.ADD_IX_DE);  
        // reference address is now in IX   
        
        EmitByte(OpCode.LD_E_iIX_d, +0);
        EmitByte(OpCode.LD_D_iIX_d, +1);
        Emit(OpCode.PUSH_DE);
        Emit(OpCode.POP_IX);
        // actual address is now in IX
        
        EmitByte(OpCode.LD_E_iIY_d, offset);
        EmitByte(OpCode.LD_D_iIY_d, offset + 1);
        Emit(OpCode.PUSH_DE);    
    }
    popRelB(uint operand)
    {
        byte offset = offsetOperandToByte(operand);
        Emit(OpCode.PUSH_IY);
        Emit(OpCode.POP_IX);
        EmitByte(OpCode.LD_E_iIY_d, offset);
        EmitByte(OpCode.LD_D_iIY_d, offset + 1);
        Emit(OpCode.ADD_IX_DE);  
        // reference address is now in IX   
        
        EmitByte(OpCode.LD_E_iIX_d, +0);
        EmitByte(OpCode.LD_D_iIX_d, +1);
        Emit(OpCode.PUSH_DE);
        Emit(OpCode.POP_IX);
        // actual address is now in IX
        
        Emit(OpCode.POP_DE);    
        EmitByte(OpCode.LD_iIY_d_E, offset);
        EmitByte(OpCode.LD_iIY_d_D, offset + 1);
    }         
    
    
    incGlobalB(uint operand)
    {
        uint address = addressOperandToByte(operand);
        Peephole.Disabled = true;
        EmitWord  (OpCode.LD_IX_nn,   address);
        EmitByte  (OpCode.INC_iIX_d, +0);
        EmitOffset(OpCode.JR_NZ_e,   +3);    // did it overflow from 0xFF back around to 0x00?
        EmitByte  (OpCode.INC_iIX_d, +1);
        Peephole.Disabled = false;
        Peephole.Reset();
    }
    decGlobalB(uint operand)
    {
        uint address = addressOperandToByte(operand);
        Peephole.Disabled = true;
        EmitWord  (OpCode.LD_IX_nn,    address);
        EmitByte  (OpCode.DEC_iIX_d,  +0);
        EmitByte  (OpCode.LD_A_n,      0xFF);
        EmitByte  (OpCode.CP_A_iIX_d, +0); // wrapped around from 0x00 to 0xFF?
        EmitOffset(OpCode.JR_NZ_e,    +3);
        EmitByte  (OpCode.DEC_iIX_d,  +1);
        Peephole.Disabled = false;
        Peephole.Reset();
    }
    pushGlobalB(uint operand)
    {
        uint address = addressOperandToByte(operand);
        EmitWord(OpCode.LD_DE_inn, address);
        Emit    (OpCode.PUSH_DE);
    }
    popGlobalB(uint operand)
    {    
        uint address = addressOperandToByte(operand);
        Emit    (OpCode.POP_DE);
        EmitWord(OpCode.LD_inn_DE, address);
    }
        
    bool writeMethod(uint methodIndex, <byte> code)
    {
        bool success;
        if (entryIndex == methodIndex)
        {
            writeSystem();
        }        
        uint methodAddress   = output.Count;
        methods[methodIndex] = methodAddress;
        if (entryIndex == methodIndex)
        {
            reset();
        }
        
        <uint,uint> instructionAddresses; // <hopperAddress,z80Address>
        
        <uint,int>  jumpPatches;          // <hopperAddress,jumpOffset>
        <uint,uint> jumpPatchLocations;   // <hopperAddress,patchAddress>
        
        uint peepholeSinbin;
        uint index;
        loop
        {
            if (index == code.Count) { success = true; break; }
            
            if (peepholeSinbin > 0)
            {
                peepholeSinbin--;
                Peephole.Reset();
            }
            
            uint hopperAddress = index;
            instructionAddresses[hopperAddress] = output.Count;
            uint operand;
            Instruction instruction = Instructions.GetOperandAndNextAddress(code, ref index, ref operand);
            string instructionName = Instructions.ToString(instruction);
            
            
            bool isStackOffset;
            bool isAddressOffset;
            bool isRET;
            byte width = Instructions.GetKitchenSinkWidth(instruction, ref isStackOffset, ref isAddressOffset, ref isRET);
            
            // ### emit code here
            
            switch (instruction)
            {
                case Instruction.ENTER:
                {
                    Peephole.Reset();
                    // PUSH BP
                    Emit(OpCode.PUSH_IY); 
                    
                    // BP <- SP
                    EmitWord(OpCode.LD_inn_SP, SPBPSwapper);
                    EmitWord(OpCode.LD_IY_inn, SPBPSwapper);
                }
                case Instruction.ENTERB:
                {
                    Peephole.Reset();
                    // PUSH BP
                    Emit(OpCode.PUSH_IY); 
                    
                    // BP <- SP
                    EmitWord(OpCode.LD_inn_SP, SPBPSwapper);
                    EmitWord(OpCode.LD_IY_inn, SPBPSwapper);
                    
                    // Create some empty stack slots:
                    EmitWord(OpCode.LD_IX_nn, 0x0000);
                    
                    if (operand <= 5) // don't do this : makes an extra case for Z80Dasm and Z80Opt
                    {
                        loop
                        {
                            Emit(OpCode.PUSH_DE); // up to 5 pushes is the same length as the alternative below, but faster
                            operand--;
                            if (operand == 0) { break; }
                        }
                    }
                    else
                    {
                        EmitByte(OpCode.LD_B_n, byte(operand));
                        Peephole.Reset();
                        Emit(OpCode.PUSH_DE);
                        EmitOffset(OpCode.DJNZ_e, -3);
                    }
                }
                case Instruction.SWAP:
                {
                    Emit(OpCode.POP_DE);
                    Emit(OpCode.POP_BC);   
                    Emit(OpCode.PUSH_DE);
                    Emit(OpCode.PUSH_BC);
                }
                case Instruction.DUP:
                {
                    if (operand != 0) 
                    {
                        Die(0x0A);
                    }
                    Emit(OpCode.EX_iSP_HL);
                    Emit(OpCode.PUSH_HL);   
                }
                case Instruction.DUP0:
                {
                    Emit(OpCode.EX_iSP_HL);
                    Emit(OpCode.PUSH_HL);   
                }
                case Instruction.BOOLNOT:
                {
                    // assumes [top] is 0 or 1
                    Emit(OpCode.EX_iSP_HL);
                    Emit(OpCode.LD_A_L);   
                    Emit(OpCode.XOR_A_A);  
                    Emit(OpCode.LD_L_A);  
                    Emit(OpCode.EX_iSP_HL);
                }
                case Instruction.DECSP:
                {
                    if (operand <= 5)
                    {
                        loop
                        {
                            Emit(OpCode.POP_DE); // up to 5 pops is the same length as the alternative below, but faster
                            operand--;
                            if (operand == 0) { break; }
                        }
                    }
                    else
                    {
                        EmitByte(OpCode.LD_B_n, byte(operand));
                        Peephole.Reset();
                        Emit(OpCode.POP_DE);
                        EmitOffset(OpCode.DJNZ_e, -3);
                    }
                }
                case Instruction.PUSHD:
                {
                    Emit(OpCode.DDDD); // for patch signature used for validation and for the optimizer
                    EmitWord(OpCode.LD_DE_nn, operand);    
                    patches[output.Count-2] = operand; // patch it like a method
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.CALL:
                {
                    EmitWord(OpCode.CALL_nn, uint(operand));
                    patches[output.Count-2] = operand;
                }
                case Instruction.RETB:
                {
                    if (operand <= 5)
                    {
                        loop
                        {
                            Emit(OpCode.POP_DE); // up to 5 pops is the same length as the alternative below, but faster
                            operand--;
                            if (operand == 0) { break; }
                        }
                    }
                    else
                    {
                        EmitByte(OpCode.LD_B_n, byte(operand));
                        Peephole.Reset();
                        Emit(OpCode.POP_DE);
                        EmitOffset(OpCode.DJNZ_e, -3);
                    }
                    
                    // POP BP
                    Emit(OpCode.POP_IY); 
                    Emit(OpCode.RET);
                }
                case Instruction.RET0:
                {
                    // POP BP
                    Emit(OpCode.POP_IY); 
                    Emit(OpCode.RET);
                }
                case Instruction.RETFAST:
                {
                    Emit(OpCode.RET);
                }
                
                case Instruction.ADD:
                case Instruction.ADDI:
                {
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_HL);    
                    Emit(OpCode.ADD_HL_DE);
                    Emit(OpCode.PUSH_HL);  
                }
                case Instruction.SUB:
                case Instruction.SUBI:
                {
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_HL);    
                    Emit(OpCode.AND_A); // clear carry
                    Emit(OpCode.SBC_HL_DE);
                    Emit(OpCode.PUSH_HL);  
                }
                case Instruction.ADDB:
                {
                    EmitWord(OpCode.LD_DE_nn, operand);
                    Emit(OpCode.POP_HL);    
                    Emit(OpCode.ADD_HL_DE);
                    Emit(OpCode.PUSH_HL);
                }
                case Instruction.SUBB:
                {
                    EmitWord(OpCode.LD_DE_nn, operand);
                    Emit(OpCode.POP_HL);    
                    Emit(OpCode.AND_A); // clear carry
                    Emit(OpCode.SBC_HL_DE);
                    Emit(OpCode.PUSH_HL);
                }
                
                case Instruction.MUL:
                {
                    // top -> BC, next -> DE
                    // HL = next * top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_DE);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("MUL"));
                    Emit(OpCode.PUSH_HL);   
                }
                case Instruction.DIV:
                {
                    // top -> DE, next -> BC
                    // BC = next / top
                    // HL = next % top
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_BC);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("DIVMOD"));
                    Emit(OpCode.PUSH_BC);  
                }
                case Instruction.MOD:
                {
                    // top -> DE, next -> BC
                    // HL = next % top
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_BC);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("DIVMOD"));
                    Emit(OpCode.PUSH_HL);
                }
                case Instruction.MULI:
                {
                    // top -> BC, next -> DE
                    // HL = next * top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_DE);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("MULI"));
                    Emit(OpCode.PUSH_HL);  
                }
                case Instruction.DIVI:
                {
                    // top -> DE, next -> BC
                    // BC = next / top
                    // HL = next % top
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_BC);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("DIVI"));
                    Emit(OpCode.PUSH_BC);    
                }
                case Instruction.MODI:
                {
                    // top -> DE, next -> BC
                    // HL = next % top, always positive signed result
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_BC);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("MODI"));
                    Emit(OpCode.PUSH_HL);
                }
                
                case Instruction.BITSHL:
                {
                    // top -> BC, next -> HL
                    // HL = next  << top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITSHL"));
                    Emit(OpCode.PUSH_HL);   
                }
                case Instruction.BITSHR:
                {
                    // top -> BC, next -> HL
                    // HL = next  >> top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITSHR"));
                    Emit(OpCode.PUSH_HL);    
                }
                case Instruction.BOOLAND:
                case Instruction.BITAND:
                {
                    // top -> BC, next -> HL
                    // HL = next & top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITAND"));
                    Emit(OpCode.PUSH_HL);  
                }
                case Instruction.BOOLOR:
                case Instruction.BITOR:
                {
                    // top -> BC, next -> HL
                    // HL = next & top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITOR"));
                    Emit(OpCode.PUSH_HL);    
                }
                case Instruction.BITXOR:
                {
                    // top -> BC, next -> HL
                    // HL = next ^ top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITXOR"));
                    Emit(OpCode.PUSH_HL);    
                }
                case Instruction.BITNOT:
                {
                    // top = ~top
                    Emit(OpCode.POP_HL);
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITNOT"));
                    Emit(OpCode.PUSH_HL);    
                }
                
                case Instruction.BITSHL8:
                {
                    // top = top << 8
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.LD_H_L);                   
                    EmitByte(OpCode.LD_L_n, 0);   
                    Emit(OpCode.PUSH_HL);    
                }
                case Instruction.BITSHR8:
                {
                    // top = top >> 8
                    Emit(OpCode.EX_iSP_HL);
                    Emit(OpCode.LD_L_H);                   
                    EmitByte(OpCode.LD_H_n, 0);
                    Emit(OpCode.EX_iSP_HL);    
                }
                case Instruction.BITANDFF:
                {
                    // top = top & 0x00FF
                    Emit(OpCode.EX_iSP_HL);
                    EmitByte(OpCode.LD_H_n, 0);                   
                    Emit(OpCode.EX_iSP_HL);    
                }
                
                case Instruction.PUSHIBLE:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL <= BC ? 1 : 0 
                    EmitWord(OpCode.LD_BC_nn, operand & 0xFF);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LE"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.PUSHIBEQ:
                {
                    // next -> HL, top -> BC   
                    // EQ: DE = HL == BC ? 1 : 0 
                    EmitWord(OpCode.LD_BC_nn, operand & 0xFF);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("EQ"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.PUSHILT:
                {
                    // next -> HL, top -> BC
                    // LT: DE = HL < BC ? 1 : 0 
                    EmitWord(OpCode.LD_BC_nn, operand);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LT"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.PUSHILEI:
                {
                    // next -> HL, top -> BC
                    // LT: DE = HL < BC ? 1 : 0 
                    EmitWord(OpCode.LD_BC_nn, operand);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LEI"));
                    Emit(OpCode.PUSH_DE);
                }
                
                case Instruction.LE:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL <= BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LE"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.GE:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL >= BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GE"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.LT:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL < BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LT"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.GT:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL > BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GT"));
                    Emit(OpCode.PUSH_DE);
                }
                
                case Instruction.LTI:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL < BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LTI"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.LEI:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL <= BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LEI"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.GTI:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL > BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GTI"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.GEI:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL >= BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GEI"));
                    Emit(OpCode.PUSH_DE);
                }
                
                case Instruction.EQ:
                {
                    // next -> HL, top -> BC
                    // EQ: DE = HL == BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("EQ"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.NE:
                {
                    // next -> HL, top -> BC
                    // EQ: DE = HL != BC ? 1 : 0
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("NE"));
                    Emit(OpCode.PUSH_DE);
                }
                
                case Instruction.JZB:
                {
                    Emit(OpCode.XOR_A_A);
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.CP_A_L);
                    
                    EmitWord(OpCode.JP_Z_nn, uint(0));
                    int offset = byte(operand);
                    if (offset > 127)
                    {
                        offset -= 256;
                    }
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = offset;
                    if (offset > 0)
                    {
                        peepholeSinbin = uint(offset);
                    }
                }
                case Instruction.JNZB:
                {
                    Emit(OpCode.XOR_A_A);
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.CP_A_L);
                    
                    EmitWord(OpCode.JP_NZ_nn, uint(0));
                    int offset = byte(operand);
                    if (offset > 127)
                    {
                        offset -= 256;
                    }
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = offset;
                    if (offset > 0)
                    {
                        peepholeSinbin = uint(offset);
                    }
                }
                case Instruction.JB:
                {
                    EmitWord(OpCode.JP_nn, uint(0));
                    int offset = byte(operand);
                    if (offset > 127)
                    {
                        offset -= 256;
                    }
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = offset;
                    if (offset > 0)
                    {
                        peepholeSinbin = uint(offset);
                    }
                }
                
                case Instruction.JZ:
                {
                    Emit(OpCode.XOR_A_A);
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.CP_A_L);
                    
                    EmitWord(OpCode.JP_Z_nn, uint(0));
                    int ioffset = Int.FromBytes(byte(operand & 0xFF), byte(operand >> 8));
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = ioffset;
                    if (ioffset > 0)
                    {
                        peepholeSinbin = uint(ioffset);
                    }
                }
                case Instruction.JNZ:
                {
                    Emit(OpCode.XOR_A_A);
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.CP_A_L);
                    
                    EmitWord(OpCode.JP_NZ_nn, uint(0));
                    int ioffset = Int.FromBytes(byte(operand & 0xFF), byte(operand >> 8));
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = ioffset;
                    if (ioffset > 0)
                    {
                        peepholeSinbin = uint(ioffset);
                    }
                }
                
                case Instruction.J:
                {
                    EmitWord(OpCode.JP_nn, uint(0));
                    int ioffset = Int.FromBytes(byte(operand & 0xFF), byte(operand >> 8));                        
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = ioffset;
                    if (ioffset > 0)
                    {
                        peepholeSinbin = uint(ioffset);
                    }
                }
                                
                case Instruction.CAST:
                case Instruction.NOP:
                {
                    // NOP
                }
                
                case Instruction.PUSHR0:
                {
                    Emit(OpCode.PUSH_HL);
                }
                case Instruction.POPR0:
                {
                    Emit(OpCode.POP_HL);
                }
                case Instruction.PUSHIB:
                case Instruction.PUSHI:
                {
                    EmitWord(OpCode.LD_DE_nn, operand);    
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.PUSHI0:
                {
                    EmitWord(OpCode.LD_DE_nn, 0);    
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.PUSHI1:
                {
                    EmitWord(OpCode.LD_DE_nn, 1);    
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.PUSHIBB:
                {
                    EmitWord(OpCode.LD_DE_nn, operand & 0xFF);    
                    Emit(OpCode.PUSH_DE);
                    EmitWord(OpCode.LD_DE_nn, operand >> 8);    
                    Emit(OpCode.PUSH_DE);
                }
                
                
                case Instruction.PUSHSTACKADDRB:
                {
                    pushStackAddrB(operand);
                }
                case Instruction.PUSHRELB:
                {
                    pushRelB(operand);
                }
                case Instruction.POPRELB:
                {
                    popRelB(operand);
                }
                                
                case Instruction.PUSHLOCALB:
                {
                    pushLocalB(operand);
                }
                case Instruction.POPLOCALB:
                {
                    popLocalB(operand);
                }
                case Instruction.PUSHLOCALB00:
                {
                    pushLocalB(0);
                }
                case Instruction.PUSHLOCALB01:
                {
                    pushLocalB(1);
                }
                case Instruction.PUSHLOCALBB:
                {
                    pushLocalB(operand & 0xFF);
                    pushLocalB(operand >> 8);
                }
                case Instruction.POPLOCALB00:
                {
                    popLocalB(0);
                }
                case Instruction.POPLOCALB01:
                {
                    popLocalB(1);
                }
                case Instruction.INCLOCALBB:
                case Instruction.INCLOCALIBB:
                {
                    incLocalBB(operand & 0xFF, operand >> 8);
                }
                case Instruction.INCLOCALB:
                case Instruction.INCLOCALIB:
                {
                    incLocalB(operand);
                }
                case Instruction.DECLOCALB:
                case Instruction.DECLOCALIB:
                {
                    decLocalB(operand);
                }
                
                case Instruction.PUSHGLOBALB:
                {
                    pushGlobalB(operand);
                }
                case Instruction.PUSHGLOBALBB:
                {
                    pushGlobalB(operand & 0xFF);
                    pushGlobalB(operand >> 8);
                }
                case Instruction.POPGLOBALB:
                {
                    popGlobalB(operand);
                }
                case Instruction.INCGLOBALB:
                {
                    incGlobalB(operand);
                }
                case Instruction.DECGLOBALB:
                {
                    decGlobalB(operand);
                }
                
                case Instruction.SYSCALL0:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 0)) { break; }
                }
                case Instruction.SYSCALL00:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 0)) { break; }
                    if (!Z80Library.SysCall(byte(operand >> 8), 0)) { break; }
                }
                case Instruction.SYSCALL01:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 0)) { break; }
                    if (!Z80Library.SysCall(byte(operand >> 8), 1)) { break; }
                }
                case Instruction.SYSCALL10:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 1)) { break; }
                    if (!Z80Library.SysCall(byte(operand >> 8), 0)) { break; }
                }
                case Instruction.SYSCALL1:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 1)) { break; }
                }
                case Instruction.SYSCALLB0:
                {
                    EmitWord(OpCode.LD_DE_nn, operand & 0xFF);    
                    Emit(OpCode.PUSH_DE);
                    if (!Z80Library.SysCall(byte(operand >> 8), 0)) { break; }
                }
                
                default:
                {
                    if (firstOpNotImplemented)
                    {
                        PrintLn(Instructions.ToString(instruction) + " not implemented in 0x" + methodIndex.ToHexString(4));
                    }
                    firstOpNotImplemented = false;
                    Emit(OpCode.NOP);
                    break;
                }
            } // switch
        } // loop
        
        // <uint,uint> instructionAddresses; // <hopperAddress,z80Address>
        // <uint,int>  jumpPatches;          // <hopperAddress,jumpOffset>
        // <uint,uint> jumpPatchLocations    // <hopperAddress,patchAddress>
        //PrintLn(methodIndex.ToString() + ":");
        if (success)
        {
            foreach (var kv in jumpPatches)
            {
                uint hopperJumpLocation = kv.key;
                int  offset = kv.value;
                
                uint hopperJumpTarget = uint(int(hopperJumpLocation) + offset);
                if (!instructionAddresses.Contains(hopperJumpTarget))
                {
                    if (firstPatchFailed)
                    {
                        if (firstPatchFailed)
                        {
                            PrintLn("Patch failed: " + hopperJumpLocation.ToHexString(4) + " " + offset.ToString() + " " + hopperJumpTarget.ToHexString(4));
                        }
                        firstPatchFailed = false;
                    }
                }
                else
                {
                    uint targetAddress    = instructionAddresses[hopperJumpTarget];
                    uint patchLocation    = jumpPatchLocations[hopperJumpLocation];
                
                    // PATCH
                    uint methodLength = output.Count - methodAddress;
                    if (!jumpPatch(methodIndex, patchLocation, targetAddress, methodAddress, methodLength))
                    {
                        success = false;
                    }
                }
            }
        }
        bool modified;
        <string,string> debugInfo = Code.GetMethodDebugInfo(methodIndex);
        <string,string> z80DebugInfo;
        foreach (var kv in debugInfo)
        {
            string hopperAddress = kv.key;
            string lineNumber    = kv.value;
            uint hopperIndex;
            if (UInt.TryParse(hopperAddress, ref hopperIndex))
            {
                if (success || instructionAddresses.Contains(hopperIndex))
                {
                    uint z80Index = instructionAddresses[hopperIndex];
                    z80DebugInfo["0x" + z80Index.ToHexString(4)] = lineNumber;
                    modified = true;
                }
            }
        }
        // save the modified debugInfo
        if (modified)
        {        
            Code.SetMethodDebugInfo(methodIndex, z80DebugInfo);
        }
        return success;
    }
    
    
    badArguments()
    {
        PrintLn("Invalid arguments for Z80GEN:");
        PrintLn("  Z80GEN <code file>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
    }
    
    byte hexCheckSum(string values)
    {
        uint sum = 0;
        for (uint i = 0; i < values.Length / 2; i++)
        {
            string substr = values.Substring(i * 2, 2);
            uint b = 0;
            if (UInt.TryParse("0x" + substr, ref b))
            {
            }
            sum = sum + b;
        }
        sum = sum % 256;
        byte chk = byte(sum);
        chk = ~chk;
        chk++;
        return chk;
    }
    
    emitBuffer(file ihexFile, uint address, string buffer)
    {
        uint bytes = buffer.Length / 2;
        string ln = bytes.ToHexString(2) + address.ToHexString(4) + "00" + buffer;
        byte chk = hexCheckSum(ln);
        ihexFile.Append(":" + ln + chk.ToHexString(2) + char(0x0A));
    }
    
    writeIHex(file ihexFile, uint romAddress, <byte> output)
    {
        // https://en.wikipedia.org/wikie/Intel_HEX#Format
        
        uint byteCount = 0;
        uint index = 0;
        
        byte currentTick = 0;
        Parser.ProgressTick("x");
        
        string buffer;
        uint emitAddress = 0;
        loop
        {
            if (index == output.Count)
            {
                // done
                break;
            }
            byte cb = output[index]; index++;
            
            buffer = buffer + cb.ToHexString(2);
            if (buffer.Length == 32)
            {
                emitBuffer(ihexFile, emitAddress + romAddress, buffer);
                emitAddress = emitAddress + 16;
                buffer = "";
            }
            
            byteCount++;
            if (byteCount % 1024 == 0)
            {
                Parser.ProgressTick("x");
            }
        }
        if (buffer.Length != 0)
        {
            emitBuffer(ihexFile, emitAddress + romAddress, buffer);
            buffer = "";
        }
        
        ihexFile.Append(":00000001FF" + char(0x0A)); // eof
        ihexFile.Flush();
    }
    
    Hopper()
    {
        bool success = false;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length >= 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Count != 1)
            {
                badArguments();
                break;
            }
            string ext = ".code";
            string codePath = args[0];
            if (!File.Exists(ref codePath, ref ext, "/Debug/Obj/"))
            {
                badArguments();
            }
            
            long startTime = Millis;
            loop
            {
                string extension = Path.GetExtension(codePath);
                string ihexPath  = codePath.Replace(extension, ".hex");
                string symbolsPath = codePath.Replace(extension, ".sym");
                
                ihexPath = Path.GetFileName(ihexPath);
                ihexPath = Path.Combine("/Bin/", ihexPath);
                File.Delete(ihexPath);

                file ihexFile = File.Create(ihexPath);
                if (!ihexFile.IsValid())
                {
                    PrintLn("Failed to create '" + ihexPath + "'");
                    break;
                }
                
                Symbols.New();
                if (File.Exists(symbolsPath))
                {
                    if (Symbols.Import(symbolsPath, false))
                    {
                        CodeStream.InitializeSymbolShortcuts();
                    }
                }
                
                if (!ParseCode(codePath, true, true))
                {
                    break;
                }
                
                uint methodCount = Code.GetMethodCount();
                
                <byte> constantData = Code.GetConstantData();
                if (constantData.Count != 0)
                {
                    PrintLn("Unexpected constant data"); // reference types not supported
                    break;
                }
                entryIndex = Code.GetEntryIndex();
                <uint, uint> methodSizes = Code.GetMethodSizes();
                <uint,uint>  framelessMethodCandidates = Code.GetFramelessMethodCandidates();
                Parser.ProgressTick(".");
                
                // stack needs to exist before our first CALL
                // start pointing one byte beyond since it grows downward
                EmitWord(OpCode.LD_SP_nn, StackAddress + StackSize); 
                EmitWord(OpCode.CALL_nn, 0);
                Emit(OpCode.HALT);
                
                <byte> methodCode = Code.GetMethodCode(entryIndex);
                bool failed = !writeMethod(entryIndex, methodCode);
                Parser.ProgressTick(".");
                uint indexMax = 0;
                foreach (var sz in methodSizes)
                {
                    if (sz.key > indexMax)
                    {
                        indexMax = sz.key;
                    }
                }
                if (!failed)
                {
                    uint total = output.Count;
                    // if we emit the methods in increasing order of indices
                    // then we can find them again in the binary (for debug info)
                    uint count = 1;
                    for (uint index = 0; index <= indexMax; index++)
                    {
                        if (index == entryIndex)          { continue; }
                        if (!methodSizes.Contains(index)) { continue; }   
                        methodCode = Code.GetMethodCode(index);
                        uint startAddress = output.Count;
                        if (!writeMethod(index, methodCode))
                        {
                            failed = true;
                            break;
                        }
                        Parser.ProgressTick(".");
                        count++;
                        if (output.Count > 0xF000)
                        {
                            PrintLn();
                            PrintLn("0x"  + (output.Count).ToHexString(4) + " bytes Z80 assembly generated.", Colour.Red, Colour.Black);
                            PrintLn("Only on method " + count.ToString() + " of " + (methodSizes.Count).ToString() + ". Abandoning build.", Colour.Red, Colour.Black);
                            failed = true;
                            break;
                        }
                        uint length = output.Count - startAddress;
                        total += length;
                        if (false && (length > 500))
                        {
                            PrintLn();
                            Print("  0x" + index.ToHexString(4) + ": 0x" + startAddress.ToHexString(4) + " length: " + length.ToString() + " total: " + total.ToString() + " size: " + (methodCode.Count).ToString());
                        }
                    }
                }
                doCallPatches(failed);
                
                Parser.ProgressTick(".");
                writeIHex(ihexFile, 0x0000, output);
                string zcodePath = codePath.Replace(".code", ".zcode");
                File.Delete(zcodePath);
                if (!Code.ExportCode(zcodePath, false)) // after
                {
                    break;
                }
                if (failed)
                {
                    break;
                }
                codeSize = output.Count;
                if (!Parser.IsInteractive())
                {
                    PrintLn();
                    string laxReport = (LaxSavings == 0) ? "" : ", " + (LaxSavings).ToString() + " 'unsafe' Lax savings)";
                    Print("Success, " + codeSize.ToString() + " bytes of code (" +
                                        (StrictSavings).ToString() + " bytes of peephole savings" +
                                        laxReport +
                                        "), ", Colour.ProgressText, Colour.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() +"s", Colour.ProgressHighlight, Colour.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                success = true;
                break;
            }
            break;
        }
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }
    }
}
