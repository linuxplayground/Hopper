program Z80Gen
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    
    //#define INLINE_STACK_OPERATIONS
    //#define INLINE_OTHER_INSTRUCTIONS
    
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    
    uses "JSON/JSON"
    uses "JSON/Code"
    
    uses "CodeGen/Instructions"
    uses "Symbols"
    
    uses "/Source/Runtime/Platform/SysCalls"
    
    
    uses "CODEGEN/AsmZ80"
    uses "CODEGEN/Z80Library"
    uses "CODEGEN/Z80Peephole"
    
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/Parser"
    
    <string,variant> symbols;
    
    long codeSize = 0;
    <byte> output;
    <uint,uint> patches;         // <callLocation,methodIndex>
    <uint,uint> methods;         // <methodIndex,address>
    
    <string,bool> missingOpCodes;
    
    uint entryIndex;
    
    bool NoPackedInstructions { get { return false; } }
    
    uint CurrentAddress { get { return output.Count; } }
    
    reset()
    {
        // exited    = false; - TODO : uses 0xFFFF as invalid address?
        // interruptsEnabled = true; - TODO
        
        // DataMemoryReset(); - TODO
        // External.TimerInitialize(); - TODO
        //
        //      sp = 0;
        
        //      bp = 0;
        
               
        //      Error = 0;
        Emit(OpCode.XOR_A_A);
        EmitWord(OpCode.LD_inn_A, LastError);
        
        //      cnp = false;
        
    }
    
    
    patchRSTJump(uint rst, uint targetAddress)
    {
        uint offset = targetAddress - rst - 2;
        if (offset < 127)
        {
            output.SetItem(rst+0, byte(OpCode.JR_e));
            output.SetItem(rst+1, byte(offset));
        }
        else
        {
            output.SetItem(rst+1, byte(targetAddress & 0xFF));
            output.SetItem(rst+2, byte(targetAddress >> 8));
        }
    }
    
    PatchByte(uint address, byte value)
    {
        patchByte(address, value);
    }
    patchByte(uint address, byte value)
    {
        if ((address == 0x0010) || (address == 0x0011))
        {
            Die(0x0B);
        }
        output.SetItem(address, value);
    }
        
    doCallPatches()
    {
        // <uint,uint> patches; // <callLocation,methodIndex>
        // <uint,uint> methods; // <methodIndex,address>
        foreach (var kv in patches)
        {
            uint patchAddress  = kv.key;
            uint targetMethod  = kv.value;
            uint targetAddress = methods[targetMethod];
            // PATCH
            patchByte(patchAddress+0, byte(targetAddress & 0xFF));
            patchByte(patchAddress+1, byte(targetAddress >> 8));
        }
        patchByte(4, byte(methods[entryIndex] & 0xFF));
        patchByte(5, byte(methods[entryIndex] >> 8));
    }
    
    emit(OpCode opCode)
    {
        Peephole.AddInstruction(output.Count);
        uint ui = uint(opCode);
        if ((ui & 0xFF00) != 0)
        {
            output.Append(byte(ui >> 8));
        }
        output.Append(byte(ui & 0xFF));
    }
    Emit(OpCode opCode)
    {
        emit(opCode);
        Peephole.Optimize(output);
        switch (opCode)
        {
            case OpCode.JP_HL:
            case OpCode.RET:
            case OpCode.HALT:
            {
                Peephole.Reset();
            }
        }
    }
    EmitByte(OpCode opCode, byte lsb)
    {
        emit(opCode);
        emitByte(lsb);
        Peephole.Optimize(output);
    }
    EmitOffset(OpCode opCode, int offset)
    {
        if (offset < 0)
        {
            offset += 256;
        }
        byte lsb = byte(offset);
        emit(opCode);
        emitByte(lsb);
        
        switch (opCode)
        {
            case OpCode.JR_NZ_e:
            case OpCode.JR_Z_e:
            case OpCode.JR_NC_e:
            case OpCode.JR_C_e:
            case OpCode.JR_e:
            {
                Peephole.Reset();
            }
        }
        
        Peephole.Optimize(output);
    }
    EmitOffsetByte(OpCode opCode, int offset, byte msb)
    {
        if (offset < 0)
        {
            offset += 256;
        }
        byte lsb = byte(offset);
        emit(opCode);
        emitByte(lsb);
        emitByte(msb);
        
        switch (opCode)
        {
            case OpCode.JR_NZ_e:
            case OpCode.JR_Z_e:
            case OpCode.JR_NC_e:
            case OpCode.JR_C_e:
            case OpCode.JR_e:
            {
                Peephole.Reset();
            }
        }
        Peephole.Optimize(output);
    }
    EmitWord(OpCode opCode, uint operand)
    {
        emit(opCode);
        emitByte(byte(operand & 0xFF));
        emitByte(byte(operand >> 8));
        
        switch (opCode)
        {
            case OpCode.JP_nn:
            {
                Peephole.Reset();
            }
        }
        
        Peephole.Optimize(output);
    }
    emitByte(byte lsb)
    {
        output.Append(lsb);
    }
    
    writeSystem()
    {
        while (output.Count < 256)
        {
            if (output.Count == 0x0040) // after the RSTx slots
            {
                Z80Library.Generate();
                break;
            }
            Emit(OpCode.NOP);
        }
    }  
    
    byte offsetOperandToByte(uint operand)
    {
        // calculate the 8-bit signed Hopper offset
        int ioffset = byte(operand & 0xFF);
        if (ioffset > 127)
        {
            ioffset = ioffset - 256;
        }
        
        // invert the sign since the Z80 stack grows downward
        ioffset = -ioffset;
        
        // double it to convert from stack slots to bytes
        ioffset *= 2;
        if (ioffset > 0)
        {
            ioffset += 2; // to skip BP
        }
        else
        {
            ioffset -= 2; // to skip BP
        }
        
        byte byteOffset = ioffset.GetByte(0);        
        return byteOffset;
    }   
        
    uint addressOperandToByte(uint operand)
    {
        // calculate the 8-bit signed Hopper address
        int iaddress = byte(operand & 0xFF);
        
        // invert the sign since the Z80 stack grows downward
        iaddress = -iaddress;
        
        // double it to convert from stack slots to bytes
        iaddress *= 2;
        
        iaddress -= 4; // skip:
                       // - the return address from startup
                       // - the first slot itself
        
        long address = long(StackAddress) + long(StackSize) + iaddress;
        //PrintLn(operand.ToString() + " " + iaddress.ToString() + " -> 0x" + address.ToHexString(4));
        return uint(address);
    }
    
    incLocalB(uint operand)
    {
        byte offset = offsetOperandToByte(operand);
        Peephole.Disabled = true;
        EmitByte  (OpCode.INC_iIY_d, offset);
        EmitOffset(OpCode.JR_NZ_e,    +3);    // did it overflow from 0xFF back around to 0x00?
        EmitByte  (OpCode.INC_iIY_d, offset+1);
        Peephole.Disabled = false;
        Peephole.Reset();
    }
    decLocalB(uint operand)
    {
        byte offset = offsetOperandToByte(operand);
        Peephole.Disabled = true;
        EmitByte  (OpCode.DEC_iIY_d,  offset);
        EmitByte  (OpCode.LD_A_n,       0xFF);
        EmitByte  (OpCode.CP_A_iIY_d, offset); // wrapped around from 0x00 to 0xFF?
        EmitOffset(OpCode.JR_NZ_e,        +3);
        EmitByte  (OpCode.DEC_iIY_d,  offset+1);
        Peephole.Disabled = false;
        Peephole.Reset();
    }
    pushLocalB(uint operand)
    {
        byte offset = offsetOperandToByte(operand);
        EmitByte(OpCode.LD_E_iIY_d, offset);
        EmitByte(OpCode.LD_D_iIY_d, offset + 1);
        Emit(OpCode.PUSH_DE);
    }
    
    pushStackAddrB(uint operand)
    {
        byte offset = offsetOperandToByte(operand);
        Emit(OpCode.PUSH_IY);
        Emit(OpCode.POP_IX);
        EmitByte(OpCode.LD_E_iIY_d, offset);
        EmitByte(OpCode.LD_D_iIY_d, offset + 1);
        Emit(OpCode.ADD_IX_DE);  // absolute address is now in IX
        Emit(OpCode.POP_IX);
    }
    pushRelB(uint operand)
    {
        byte offset = offsetOperandToByte(operand);
        Emit(OpCode.PUSH_IY);
        Emit(OpCode.POP_IX);
        EmitByte(OpCode.LD_E_iIY_d, offset);
        EmitByte(OpCode.LD_D_iIY_d, offset + 1);
        Emit(OpCode.ADD_IX_DE);  
        // reference address is now in IX   
        
        EmitByte(OpCode.LD_E_iIX_d, +0);
        EmitByte(OpCode.LD_D_iIX_d, +1);
        Emit(OpCode.PUSH_DE);
        Emit(OpCode.POP_IX);
        // actual address is now in IX
        
        EmitByte(OpCode.LD_E_iIY_d, offset);
        EmitByte(OpCode.LD_D_iIY_d, offset + 1);
        Emit(OpCode.PUSH_DE);    
    }
    popRelB(uint operand)
    {
        byte offset = offsetOperandToByte(operand);
        Emit(OpCode.PUSH_IY);
        Emit(OpCode.POP_IX);
        EmitByte(OpCode.LD_E_iIY_d, offset);
        EmitByte(OpCode.LD_D_iIY_d, offset + 1);
        Emit(OpCode.ADD_IX_DE);  
        // reference address is now in IX   
        
        EmitByte(OpCode.LD_E_iIX_d, +0);
        EmitByte(OpCode.LD_D_iIX_d, +1);
        Emit(OpCode.PUSH_DE);
        Emit(OpCode.POP_IX);
        // actual address is now in IX
        
        Emit(OpCode.POP_DE);    
        EmitByte(OpCode.LD_iIY_d_E, offset);
        EmitByte(OpCode.LD_iIY_d_D, offset + 1);
    }         
    
    popLocalB(uint operand)
    {    
        byte offset = offsetOperandToByte(operand);
        Emit(OpCode.POP_DE);
        EmitByte(OpCode.LD_iIY_d_E, offset);
        EmitByte(OpCode.LD_iIY_d_D, offset + 1);
    }
    
    incGlobalB(uint operand)
    {
        uint address = addressOperandToByte(operand);
        Peephole.Disabled = true;
        EmitWord  (OpCode.LD_IX_nn,   address);
        EmitByte  (OpCode.INC_iIX_d, +0);
        EmitOffset(OpCode.JR_NZ_e,   +3);    // did it overflow from 0xFF back around to 0x00?
        EmitByte  (OpCode.INC_iIX_d, +1);
        Peephole.Disabled = false;
        Peephole.Reset();
    }
    decGlobalB(uint operand)
    {
        uint address = addressOperandToByte(operand);
        Peephole.Disabled = true;
        EmitWord  (OpCode.LD_IX_nn,    address);
        EmitByte  (OpCode.DEC_iIX_d,  +0);
        EmitByte  (OpCode.LD_A_n,      0xFF);
        EmitByte  (OpCode.CP_A_iIX_d, +0); // wrapped around from 0x00 to 0xFF?
        EmitOffset(OpCode.JR_NZ_e,    +3);
        EmitByte  (OpCode.DEC_iIX_d,  +1);
        Peephole.Disabled = false;
        Peephole.Reset();
    }
    pushGlobalB(uint operand)
    {
        uint address = addressOperandToByte(operand);
        EmitWord(OpCode.LD_IX_nn,    address);
        EmitByte(OpCode.LD_E_iIX_d, +0);
        EmitByte(OpCode.LD_D_iIX_d, +1);
        Emit    (OpCode.PUSH_DE);
    }
    popGlobalB(uint operand)
    {    
        uint address = addressOperandToByte(operand);
        EmitWord(OpCode.LD_IX_nn,    address);
        Emit    (OpCode.POP_DE);
        EmitByte(OpCode.LD_iIX_d_E, +0);
        EmitByte(OpCode.LD_iIX_d_D, +1);
    }
        
    writeMethod(uint methodIndex, <byte> code, bool frameless)
    {
        if (entryIndex == methodIndex)
        {
            writeSystem();
        }        
        uint methodAddress   = output.Count;
        methods[methodIndex] = methodAddress;
        if (entryIndex == methodIndex)
        {
            reset();
        }
        
        <uint,uint> instructionAddresses; // <hopperAddress,z80Address>
        
        <uint,int>  jumpPatches;          // <hopperAddress,jumpOffset>
        <uint,uint> jumpPatchLocations;   // <hopperAddress,patchAddress>
        
        if (frameless)
        {
            PrintLn();
            Print(methodIndex.ToString() + ": 0x" + (output.Count).ToHexString(4) + (frameless ? " Frameless! " : " "));
        }
        
        uint index = 0;
        uint currentDepth = 0;
        bool success;
        loop
        {
            if (index == code.Count) { success = true; break; }
            
            uint hopperAddress = index;
            instructionAddresses[hopperAddress] = output.Count;
            uint operand;
            Instruction instruction = Instructions.GetOperandAndNextAddress(code, ref index, ref operand);
            string instructionName = Instructions.ToString(instruction);
            
            
            bool isStackOffset;
            bool isAddressOffset;
            bool isRET;
            byte width = Instructions.GetKitchenSinkWidth(instruction, ref isStackOffset, ref isAddressOffset, ref isRET);
            
            // ### emit code here
            
            switch (instruction)
            {
                case Instruction.ENTER:
                {
                    Peephole.Reset();
                    if (!frameless)
                    {
                        // PUSH BP
                        Emit(OpCode.PUSH_IY); 
                        
                        // BP <- SP
                        EmitWord(OpCode.LD_inn_SP, SPBPSwapper);
                        EmitWord(OpCode.LD_IY_inn, SPBPSwapper);
                    }
                }
                case Instruction.ENTERB:
                {
                    Peephole.Reset();
                    if (!frameless)
                    {
                        // PUSH BP
                        Emit(OpCode.PUSH_IY); 
                        
                        // BP <- SP
                        EmitWord(OpCode.LD_inn_SP, SPBPSwapper);
                        EmitWord(OpCode.LD_IY_inn, SPBPSwapper);
                        
                        // Create some empty stack slots:
                        EmitWord(OpCode.LD_DE_nn, 0x0000);
                        
                        if (operand == 1) // don't do this : makes an extra case for Z80Dasm and Z80Opt
                        {
                            Emit(OpCode.PUSH_DE);
                        }
                        else
                        {
                            EmitByte(OpCode.LD_B_n, byte(operand));
                            Peephole.Reset();
                            Emit(OpCode.PUSH_DE);
                            EmitOffset(OpCode.DJNZ_e, -3);
                        }
                        currentDepth += operand;
                    }
                }
                case Instruction.SWAP:
                {
                    Emit(OpCode.POP_DE);
                    Emit(OpCode.POP_BC);   
                    Emit(OpCode.PUSH_DE);
                    Emit(OpCode.PUSH_BC);
                }
                case Instruction.DUP:
                {
                    if (operand != 0) 
                    {
                        Die(0x0A);
                    }
                    Emit(OpCode.EX_iSP_HL);
                    Emit(OpCode.PUSH_HL);   
                    currentDepth++;
                }
                case Instruction.DUP0:
                {
                    Emit(OpCode.EX_iSP_HL);
                    Emit(OpCode.PUSH_HL);   
                    currentDepth++;
                }
                case Instruction.BOOLNOT:
                {
                    // assumes [top] is 0 or 1
                    Emit(OpCode.EX_iSP_HL);
                    Emit(OpCode.LD_A_L);   
                    Emit(OpCode.XOR_A_A);  
                    Emit(OpCode.LD_L_A);  
                    Emit(OpCode.EX_iSP_HL);
                }
                case Instruction.DECSP:
                {
                    if (operand == 1)
                    {
                        Emit(OpCode.POP_DE);
                    }
                    else
                    {
                        EmitByte(OpCode.LD_B_n, byte(operand));
                        Peephole.Reset();
                        Emit(OpCode.POP_DE);
                        EmitOffset(OpCode.DJNZ_e, -3);
                    }
                    currentDepth -= operand;
                }
                case Instruction.CALL:
                {
                    EmitWord(OpCode.CALL_nn, uint(operand));
                    patches[output.Count-2] = operand;
                }
                case Instruction.RETB:
                {
                    if (!frameless)
                    {
                        if (operand == 1)
                        {
                            Emit(OpCode.POP_DE);
                        }
                        else
                        {
                            EmitByte(OpCode.LD_B_n, byte(operand));
                            Peephole.Reset();
                            Emit(OpCode.POP_DE);
                            EmitOffset(OpCode.DJNZ_e, -3);
                        }
                        
                        // POP BP
                        Emit(OpCode.POP_IY); 
                        currentDepth -= operand;
                    }
                    Emit(OpCode.RET);
                }
                case Instruction.RET0:
                {
                    if (!frameless)
                    {
                        // POP BP
                        Emit(OpCode.POP_IY); 
                    }
                    Emit(OpCode.RET);
                }
                case Instruction.RETFAST:
                {
                    Emit(OpCode.RET);
                }
                
                case Instruction.ADD:
                case Instruction.ADDI:
                {
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_HL);    
                    Emit(OpCode.ADC_HL_DE);
                    Emit(OpCode.PUSH_HL);  
                    
                    currentDepth -= 1;  
                }
                case Instruction.SUB:
                case Instruction.SUBI:
                {
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_HL);    
                    Emit(OpCode.AND_A); // clear carry
                    Emit(OpCode.SBC_HL_DE);
                    Emit(OpCode.PUSH_HL);  
                    
                    currentDepth -= 1;    
                }
                case Instruction.ADDB:
                {
                    EmitWord(OpCode.LD_DE_nn, operand);
                    Emit(OpCode.POP_HL);    
                    Emit(OpCode.ADC_HL_DE);
                    Emit(OpCode.PUSH_HL);
                }
                case Instruction.SUBB:
                {
                    EmitWord(OpCode.LD_DE_nn, operand);
                    Emit(OpCode.POP_HL);    
                    Emit(OpCode.AND_A); // clear carry
                    Emit(OpCode.SBC_HL_DE);
                    Emit(OpCode.PUSH_HL);
                }
                
                case Instruction.MUL:
                {
                    // top -> BC, next -> DE
                    // HL = next * top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_DE);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("MUL"));
                    Emit(OpCode.PUSH_HL);   
                    
                    currentDepth -= 1;     
                }
                case Instruction.DIV:
                {
                    // top -> DE, next -> BC
                    // BC = next / top
                    // HL = next % top
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_BC);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("DIVMOD"));
                    Emit(OpCode.PUSH_BC);  
                    
                    currentDepth -= 1;      
                }
                case Instruction.MOD:
                {
                    // top -> DE, next -> BC
                    // HL = next % top
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_BC);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("DIVMOD"));
                    Emit(OpCode.PUSH_HL);
                    
                    currentDepth -= 1;    
                }
                case Instruction.MULI:
                {
                    // top -> BC, next -> DE
                    // HL = next * top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_DE);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("MULI"));
                    Emit(OpCode.PUSH_HL);  
                    
                    currentDepth -= 1;      
                }
                case Instruction.DIVI:
                {
                    // top -> DE, next -> BC
                    // BC = next / top
                    // HL = next % top
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_BC);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("DIVI"));
                    Emit(OpCode.PUSH_BC);    
                }
                case Instruction.MODI:
                {
                    // top -> DE, next -> BC
                    // HL = next % top, always positive signed result
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_BC);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("MODI"));
                    Emit(OpCode.PUSH_HL);
                    
                    currentDepth -= 1;    
                }
                
                case Instruction.BITSHL:
                {
                    // top -> BC, next -> HL
                    // HL = next  << top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITSHL"));
                    Emit(OpCode.PUSH_HL);   
                    
                    currentDepth -= 1;     
                }
                case Instruction.BITSHR:
                {
                    // top -> BC, next -> HL
                    // HL = next  >> top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITSHR"));
                    Emit(OpCode.PUSH_HL);    
                    
                    currentDepth -= 1;    
                }
                case Instruction.BITAND:
                {
                    // top -> BC, next -> HL
                    // HL = next & top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITAND"));
                    Emit(OpCode.PUSH_HL);  
                    
                    currentDepth -= 1;      
                }
                case Instruction.BITOR:
                {
                    // top -> BC, next -> HL
                    // HL = next & top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITOR"));
                    Emit(OpCode.PUSH_HL);    
                }
                case Instruction.BITXOR:
                {
                    // top -> BC, next -> HL
                    // HL = next ^ top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITXOR"));
                    Emit(OpCode.PUSH_HL);    
                    
                    currentDepth -= 1;    
                }
                case Instruction.BITNOT:
                {
                    // top = ~top
                    Emit(OpCode.POP_HL);
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITNOT"));
                    Emit(OpCode.PUSH_HL);    
                }
                
                case Instruction.PUSHIBLE:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL <= BC ? 1 : 0 
                    EmitWord(OpCode.LD_BC_nn, operand & 0xFF);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LE"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.PUSHIBEQ:
                {
                    // next -> HL, top -> BC   
                    // EQ: DE = HL == BC ? 1 : 0 
                    EmitWord(OpCode.LD_BC_nn, operand & 0xFF);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("EQ"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.PUSHILT:
                {
                    // next -> HL, top -> BC
                    // LT: DE = HL < BC ? 1 : 0 
                    EmitWord(OpCode.LD_BC_nn, operand);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LT"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.PUSHILEI:
                {
                    // next -> HL, top -> BC
                    // LT: DE = HL < BC ? 1 : 0 
                    EmitWord(OpCode.LD_BC_nn, operand);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LEI"));
                    Emit(OpCode.PUSH_DE);
                }
                
                case Instruction.LE:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL <= BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LE"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentDepth -= 1;    
                }
                case Instruction.GE:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL >= BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GE"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentDepth -= 1;    
                }
                case Instruction.LT:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL < BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LT"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentDepth -= 1;    
                }
                case Instruction.GT:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL > BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GT"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentDepth -= 1;    
                }
                
                case Instruction.LTI:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL < BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LTI"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentDepth -= 1;    
                }
                case Instruction.LEI:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL <= BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LEI"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentDepth -= 1;    
                }
                case Instruction.GTI:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL > BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GTI"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentDepth -= 1;    
                }
                case Instruction.GEI:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL >= BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GEI"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentDepth -= 1;    
                }
                
                case Instruction.EQ:
                {
                    // next -> HL, top -> BC
                    // EQ: DE = HL == BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("EQ"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentDepth -= 1;    
                }
                case Instruction.NE:
                {
                    // next -> HL, top -> BC
                    // EQ: DE = HL != BC ? 1 : 0
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("NE"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentDepth -= 1;    
                }
                
                case Instruction.JZB:
                {
                    Emit(OpCode.XOR_A_A);
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.CP_A_L);
                    
                    EmitOffset(OpCode.JR_NZ_e, +3);
                    EmitWord(OpCode.JP_nn, uint(0));
                    int offset = byte(operand);
                    if (offset > 127)
                    {
                        offset -= 256;
                    }
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = offset;
                    
                    currentDepth -= 1;    
                }
                case Instruction.JNZB:
                {
                    Emit(OpCode.XOR_A_A);
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.CP_A_L);
                    
                    EmitOffset(OpCode.JR_Z_e, +3);
                    EmitWord(OpCode.JP_nn, uint(0));
                    int offset = byte(operand);
                    if (offset > 127)
                    {
                        offset -= 256;
                    }
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = offset;
                    
                    currentDepth -= 1;    
                }
                case Instruction.JB:
                {
                    EmitWord(OpCode.JP_nn, uint(0));
                    int offset = byte(operand);
                    if (offset > 127)
                    {
                        offset -= 256;
                    }
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = offset;
                }
                
                case Instruction.JZ:
                {
                    Emit(OpCode.XOR_A_A);
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.CP_A_L);
                    
                    EmitOffset(OpCode.JR_NZ_e, +3);
                    EmitWord(OpCode.JP_nn, uint(0));
                    long loffset = long(Int.FromBytes(byte(operand & 0xFF), byte(operand >> 8)));
                    if (loffset > 32767)
                    {
                        loffset = loffset +  0xFFFF;
                    }
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = int(loffset);
                    
                    currentDepth -= 1;    
                }
                case Instruction.JNZ:
                {
                    Emit(OpCode.XOR_A_A);
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.CP_A_L);
                    
                    EmitOffset(OpCode.JR_Z_e, +3);
                    EmitWord(OpCode.JP_nn, uint(0));
                    long loffset = long(Int.FromBytes(byte(operand & 0xFF), byte(operand >> 8)));
                    if (loffset > 32767)
                    {
                        loffset = loffset +  0xFFFF;
                    }                        
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = int(loffset);
                    
                    currentDepth -= 1;    
                }
                
                case Instruction.J:
                {
                    EmitWord(OpCode.JP_nn, uint(0));
                    long loffset = long(Int.FromBytes(byte(operand & 0xFF), byte(operand >> 8)));
                    if (loffset > 32767)
                    {
                        loffset = loffset +  0xFFFF;
                    }                        
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = int(loffset);
                }
                                
                case Instruction.CAST:
                case Instruction.NOP:
                {
                    // NOP
                }
                
                case Instruction.PUSHR0:
                {
                    Emit(OpCode.PUSH_HL);
                    
                    currentDepth += 1;    
                }
                case Instruction.POPR0:
                {
                    Emit(OpCode.POP_HL);
                    currentDepth -= 1;    
                }
                case Instruction.PUSHIB:
                case Instruction.PUSHI:
                {
                    EmitWord(OpCode.LD_DE_nn, operand);    
                    Emit(OpCode.PUSH_DE);
                    currentDepth += 1; 
                }
                case Instruction.PUSHI0:
                {
                    EmitWord(OpCode.LD_DE_nn, 0);    
                    Emit(OpCode.PUSH_DE);
                    currentDepth += 1; 
                }
                case Instruction.PUSHI1:
                {
                    EmitWord(OpCode.LD_DE_nn, 1);    
                    Emit(OpCode.PUSH_DE);
                    currentDepth += 1; 
                }
                case Instruction.PUSHIBB:
                {
                    EmitWord(OpCode.LD_DE_nn, operand & 0xFF);    
                    Emit(OpCode.PUSH_DE);
                    EmitWord(OpCode.LD_DE_nn, operand >> 8);    
                    Emit(OpCode.PUSH_DE);
                    currentDepth += 2; 
                }
                
                
                case Instruction.PUSHSTACKADDRB:
                {
                    pushStackAddrB(operand);
                    currentDepth += 1; 
                }
                case Instruction.PUSHRELB:
                {
                    pushRelB(operand);
                    currentDepth += 1; 
                }
                case Instruction.POPRELB:
                {
                    popRelB(operand);
                    currentDepth -= 1; 
                }
                                
                case Instruction.PUSHLOCALB:
                {
                    if (frameless && (operand == 0xFF))
                    {
                        PrintLn();
                        PrintLn("PUSHLOCALB 0xFF:" + currentDepth.ToString());
                    }
                    pushLocalB(operand);
                    currentDepth += 1; 
                }
                case Instruction.PUSHLOCALB00:
                {
                    pushLocalB(0);
                    currentDepth += 1; 
                }
                case Instruction.PUSHLOCALB01:
                {
                    pushLocalB(1);
                    currentDepth += 1; 
                }
                case Instruction.PUSHLOCALBB:
                {
                    pushLocalB(operand & 0xFF);
                    pushLocalB(operand >> 8);
                    currentDepth += 2; 
                }
                case Instruction.POPLOCALB:
                {
                    popLocalB(operand);
                    currentDepth -= 1; 
                }
                case Instruction.POPLOCALB00:
                {
                    popLocalB(0);
                    currentDepth -= 1; 
                }
                case Instruction.POPLOCALB01:
                {
                    popLocalB(1);
                    currentDepth -= 1; 
                }
                case Instruction.INCLOCALB:
                case Instruction.INCLOCALIB:
                {
                    incLocalB(operand);
                }
                case Instruction.DECLOCALB:
                {
                    decLocalB(operand);
                }
                
                case Instruction.PUSHGLOBALB:
                {
                    pushGlobalB(operand);
                    currentDepth += 1; 
                }
                case Instruction.PUSHGLOBALBB:
                {
                    pushGlobalB(operand & 0xFF);
                    pushGlobalB(operand >> 8);
                    currentDepth += 2; 
                }
                case Instruction.POPGLOBALB:
                {
                    popGlobalB(operand);
                    currentDepth += 1; 
                }
                case Instruction.INCGLOBALB:
                {
                    incGlobalB(operand);
                }
                case Instruction.DECGLOBALB:
                {
                    decGlobalB(operand);
                }
                
                
                
                case Instruction.SYSCALL0:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 0)) { break; }
                }
                case Instruction.SYSCALL00:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 0)) { break; }
                    if (!Z80Library.SysCall(byte(operand >> 8), 0)) { break; }
                }
                case Instruction.SYSCALL01:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 0)) { break; }
                    if (!Z80Library.SysCall(byte(operand >> 8), 1)) { break; }
                }
                case Instruction.SYSCALL10:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 1)) { break; }
                    if (!Z80Library.SysCall(byte(operand >> 8), 0)) { break; }
                }
                case Instruction.SYSCALL1:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 1)) { break; }
                }
                case Instruction.SYSCALLB0:
                {
                    EmitWord(OpCode.LD_DE_nn, operand & 0xFF);    
                    Emit(OpCode.PUSH_DE);
                    
                    if (!Z80Library.SysCall(byte(operand >> 8), 0)) { break; }
                }
                
                default:
                {
                    PrintLn(Instructions.ToString(instruction) + " not implemented in 0x" + methodIndex.ToHexString(4));
                    Emit(OpCode.NOP);
                    break;
                }
            }
        }
        
        // <uint,uint> instructionAddresses; // <hopperAddress,z80Address>
        // <uint,int>  jumpPatches;          // <hopperAddress,jumpOffset>
        // <uint,uint> jumpPatchLocations    // <hopperAddress,patchAddress>
        //PrintLn(methodIndex.ToString() + ":");
        foreach (var kv in jumpPatches)
        {
            uint hopperJumpLocation = kv.key;
            int  offset = kv.value;
            
            uint hopperJumpTarget = uint(int(hopperJumpLocation) + offset);
            if (!instructionAddresses.Contains(hopperJumpTarget))
            {
                PrintLn("Patch failed: " + hopperJumpLocation.ToHexString(4) + " " + offset.ToString() + " " + hopperJumpTarget.ToHexString(4));
            }
            else
            {
                uint targetAddress    = instructionAddresses[hopperJumpTarget];
                uint patchLocation    = jumpPatchLocations[hopperJumpLocation];
            
                // PATCH
                patchByte(patchLocation+0, byte(targetAddress & 0xFF));
                patchByte(patchLocation+1, byte(targetAddress >> 8));
                //PrintLn("  " +patchLocation.ToHexString(4) + " -> " + targetAddress.ToHexString(4));
            }
        }
        bool modified;
        <string,string> debugInfo = Code.GetMethodDebugInfo(methodIndex);
        <string,string> z80DebugInfo;
        foreach (var kv in debugInfo)
        {
            string hopperAddress = kv.key;
            string lineNumber    = kv.value;
            uint hopperIndex;
            if (UInt.TryParse(hopperAddress, ref hopperIndex))
            {
                if (success || instructionAddresses.Contains(hopperIndex))
                {
                    uint z80Index = instructionAddresses[hopperIndex];
                    z80DebugInfo["0x" + z80Index.ToHexString(4)] = lineNumber;
                    modified = true;
                }
            }
        }
        // save the modified debugInfo
        if (modified)
        {        
            Code.SetMethodDebugInfo(methodIndex, z80DebugInfo);
        }
    }
    
    
    badArguments()
    {
        PrintLn("Invalid arguments for Z80GEN:");
        PrintLn("  Z80GEN <code file>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
    }
    
    byte hexCheckSum(string values)
    {
        uint sum = 0;
        for (uint i = 0; i < values.Length / 2; i++)
        {
            string substr = values.Substring(i * 2, 2);
            uint b = 0;
            if (UInt.TryParse("0x" + substr, ref b))
            {
            }
            sum = sum + b;
        }
        sum = sum % 256;
        byte chk = byte(sum);
        chk = ~chk;
        chk++;
        return chk;
    }
    
    emitBuffer(file ihexFile, uint address, string buffer)
    {
        uint bytes = buffer.Length / 2;
        string ln = bytes.ToHexString(2) + address.ToHexString(4) + "00" + buffer;
        byte chk = hexCheckSum(ln);
        ihexFile.Append(":" + ln + chk.ToHexString(2) + char(0x0A));
    }
    
    writeIHex(file ihexFile, uint romAddress, <byte> output)
    {
        // https://en.wikipedia.org/wikie/Intel_HEX#Format
        
        uint byteCount = 0;
        uint index = 0;
        
        byte currentTick = 0;
        string progressTicks = "-\\|/-\\|/";
        
        string buffer;
        uint emitAddress = 0;
        loop
        {
            if (index == output.Count)
            {
                // done
                break;
            }
            byte cb = output[index]; index++;
            
            buffer = buffer + cb.ToHexString(2);
            if (buffer.Length == 32)
            {
                emitBuffer(ihexFile, emitAddress + romAddress, buffer);
                emitAddress = emitAddress + 16;
                buffer = "";
            }
            
            byteCount++;
            if (byteCount % 32 == 0)
            {
                Parser.ProgressTick("x");
            }
        }
        if (buffer.Length != 0)
        {
            emitBuffer(ihexFile, emitAddress + romAddress, buffer);
            buffer = "";
        }
        
        ihexFile.Append(":00000001FF" + char(0x0A)); // eof
        ihexFile.Flush();
    }
    
    Hopper()
    {
        bool success = false;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length >= 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Count != 1)
            {
                badArguments();
                break;
            }
            string ext = ".code";
            string codePath = args[0];
            if (!File.Exists(ref codePath, ref ext, "/Debug/Obj/"))
            {
                badArguments();
            }
            
            long startTime = Millis;
            loop
            {
                string extension = Path.GetExtension(codePath);
                string ihexPath  = codePath.Replace(extension, ".hex");
                string symbolsPath = codePath.Replace(extension, ".sym");
                
                ihexPath = Path.GetFileName(ihexPath);
                ihexPath = Path.Combine("/Bin/", ihexPath);
                File.Delete(ihexPath);

                file ihexFile = File.Create(ihexPath);
                if (!ihexFile.IsValid())
                {
                    PrintLn("Failed to create '" + ihexPath + "'");
                    break;
                }
                
                Symbols.New();
                if (File.Exists(symbolsPath))
                {
                    if (Symbols.Import(symbolsPath, false))
                    {
                        CodeStream.InitializeSymbolShortcuts();
                    }
                }
                
                if (!ParseCode(codePath, true, true))
                {
                    break;
                }
                
                uint methodCount = Code.GetMethodCount();
                
                <byte> constantData = Code.GetConstantData();
                if (constantData.Count != 0)
                {
                    PrintLn("Unexpected constant data"); // reference types not supported
                    break;
                }
                entryIndex = Code.GetEntryIndex();
                <uint, uint> methodSizes = Code.GetMethodSizes();
                <uint,bool>  framelessMethods = Code.GetFramelessMethods();
                Parser.ProgressTick(".");
                
                // stack needs to exist before our first CALL
                // start pointing one byte beyond since it grows downward
                EmitWord(OpCode.LD_SP_nn, StackAddress + StackSize); 
                EmitWord(OpCode.CALL_nn, 0);
                Emit(OpCode.HALT);
                
                <byte> methodCode = Code.GetMethodCode(entryIndex);
                writeMethod(entryIndex, methodCode, framelessMethods[entryIndex]);
                Parser.ProgressTick(".");
                uint indexMax = 0;
                foreach (var sz in methodSizes)
                {
                    if (sz.key > indexMax)
                    {
                        indexMax = sz.key;
                    }
                }
                // if we emit the methods in increasing order of indices
                // then we can find them again in the binary (for debug info)
                uint count = 1;
                bool failed = false;
                for (uint index = 0; index <= indexMax; index++)
                {
                    if (index == entryIndex)          { continue; }
                    if (!methodSizes.Contains(index)) { continue; }   
                    methodCode = Code.GetMethodCode(index);
                    writeMethod(index, methodCode, framelessMethods[index]);   
                    Parser.ProgressTick(".");
                    count++;
                    if (output.Count > 0xF000)
                    {
                        PrintLn();
                        PrintLn((output.Count).ToString() + " bytes Z80 assembly generated.", Colour.Red, Colour.Black);
                        PrintLn("Only on method " + count.ToString() + " of " + (methodSizes.Count).ToString() + ". Abandoning build.", Colour.Red, Colour.Black);
                        failed = true;
                        break;
                    }
                }
                if (!failed)
                {
                    doCallPatches();
                }
                Parser.ProgressTick(".");
                writeIHex(ihexFile, 0x0000, output);
                string zcodePath = codePath.Replace(".code", ".zcode");
                File.Delete(zcodePath);
                if (!Code.ExportCode(zcodePath)) // after
                {
                    break;
                }
                if (failed)
                {
                    break;
                }
                codeSize = output.Count;
                if (!Parser.IsInteractive())
                {
                    PrintLn();
                    Print("Success, " + codeSize.ToString() + " bytes of code, ", Colour.ProgressText, Colour.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() +"s", Colour.ProgressHighlight, Colour.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                success = true;
                break;
            }
            break;
        }
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }
    }
}
