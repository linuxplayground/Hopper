program Z80Opt
{
    //#define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    #define DIAGNOSTICS  
      
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    
    uses "JSON/JSON"
    uses "JSON/Code"
    
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/Parser"
    
    uses "CodeGen/AsmZ80"
    
    uses "CodeModel/Z80Code"
    uses "CodeModel/Z80Points"
    
    bool isExperimental;
    bool IsExperimental { get { return isExperimental; }}
    
    const uint progressSteps = 256;
    uint progressInstructions;
    ProgessNudge()
    {
        progressInstructions++;
        if ((progressInstructions % progressSteps) == 0)
        {
            Parser.ProgressTick("o"); // optimizer
        }
    }
    
    bool RemoveUnreachableMethods()
    {
        bool removed = false;
        // TODO
        return removed;
    }
    
    bool Optimize(uint pass, ref long codeBefore, ref long codeAfter)
    {
        bool anyModified = false;
        
        <uint> indices = Code.GetMethodIndices();
        
        <uint, bool> methodsWalked;
        <uint, bool> methodsCalled;
        foreach (var index in indices)
        {
            methodsCalled[index] = false;
            methodsWalked[index] = false;
        }
        
        <uint,string> methodNames = GetMethodNames(); // <index, name>
        
        uint methodIndex = 0;              // "main"
        methodsCalled[methodIndex] = true; // "main"
        loop
        {
            bool methodModified = false;
            //PrintLn("  Optimize: 0x" + methodIndex.ToHexString(4) + " " + methodNames[methodIndex] + " (" + pass.ToString() + ")");    
            
            // load codepoints
            methodsWalked[methodIndex] = true;
            uint size = CodePoints.Load(methodIndex, pass);
            if (pass == 0)
            {
                codeBefore += size;
            }
            
            CodePoints.MarkInstructions();
            
            if (CodePoints.OptimizeLDtoNOP())
            {
                methodModified = true;
            }
            if (CodePoints.OptimizeIncrement())
            {
                methodModified = true;
            }
            if (CodePoints.OptimizeAdd())
            {
                methodModified = true;
            }
            if (CodePoints.OptimizeAnd())
            {
                methodModified = true;
            }
            if (CodePoints.OptimizeReturn())
            {
                methodModified = true;
            }
            if (CodePoints.OptimizePopLocalPushLocal())
            {
                methodModified = true;
            }
            if (CodePoints.OptimizePushPop())
            {
                methodModified = true;
            }
            if (CodePoints.OptimizePushPopAdd())
            {
                methodModified = true;
            }            
            if (OptimizeShift8())
            {
                methodModified = true;
            }
            if (OptimizePushSandwichPop())
            {
                methodModified = true;
            } 
            if (OptimizeMoveXOR())
            {
                methodModified = true;
            }
            if (OptimizePushPopCompare())
            {
                methodModified = true;
            }
            if (OptimizeNOP8BitLoad())
            {
                methodModified = true;
            }
            if (Optimize8BitLoadLoad())
            {
                methodModified = true;
            }
            if (OptimizeIndirectLoadByte())
            {
                methodModified = true;
            }
            if (OptimizeWriteByte())
            {
                methodModified = true;
            }
            if (OptimizeTernary())
            {
                methodModified = true;
            }
            if (OptimizeTrivialPushPop())
            {
                methodModified = true;
            }
            if (OptimizeEQJ())
            {
                methodModified = true;
            }
            if (OptimizeOUT())
            {
                methodModified = true;
            }
            if (OptimizeWriteWord())
            {
                methodModified = true;
            }
            if (OptimizePOPDEx5())
            {
                methodModified = true;
            }
            if (OptimizeHLINC())
            {
                methodModified = true;
            }
            if (OptimizeDeclare())
            {
                methodModified = true;
            }
            
            // mark unreachable code
            if (CodePoints.OptimizeUnreachableToNOP())
            {
                methodModified = true;
            }
            // remove NOPs : should be last OptimizeXXX
            if (CodePoints.OptimizeRemoveNOPs())
            {
                methodModified = true;
            }
            
            CodePoints.CollectMethodCalls(methodsCalled);
            
            if (methodModified)
            {
                size = CodePoints.Save();
                codeAfter = codeAfter + size;
                anyModified = true;
            }
            else
            {
                codeAfter = codeAfter + size; // same as size before
            }
            ProgessNudge();
            
            
            bool walkNextMethod;
            foreach (var kv in methodsCalled)
            {
                bool isCalled = kv.value;
                if (isCalled)
                {
                    uint iMethod = kv.key;
                    if (!methodsWalked[iMethod])
                    {
                        // called but not yet walked
                        methodIndex = iMethod;
                        walkNextMethod = true;
                        break;
                    }
                }
            }
            if (!walkNextMethod) // no more to walk
            {
                break;
            }
            
        } // method loop
        
        if (RemoveUnreachableMethods())
        {
            anyModified = true;
        }
        if (CodePoints.InlineCandidatesExist)
        {
            indices = Code.GetMethodIndices(); // reload: some methods may be gone
            foreach (var methodIndex in indices)
            {
                uint size = CodePoints.Load(methodIndex, pass);
                <byte> rawCode = Code.GetMethodCode(methodIndex);
                if (InlineSmallMethods(rawCode))
                {
                    // update the method with the optimized code: no size change, pure replacement          
                    Code.SetMethodCode(methodIndex, rawCode);
                    anyModified = true;
                }
                ProgessNudge();
            }
        }
    
        return anyModified;    
    }
    
    BadArguments()
    {
        PrintLn("Invalid arguments for Z80Opt:");
        PrintLn("  Z80OPT <hex file>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
        PrintLn("    -x         : experimental");
    }
    
      
    Hopper()
    {
        bool success = false;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length >= 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-x":
                        {
                            isExperimental = true;
                        }
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Count != 1)
            {
                BadArguments();
                break;
            }
            
            string ext = ".hex";
            string codePath = args[0];
            if (!File.Exists(ref codePath, ref ext, "/Bin/"))
            {
                BadArguments();
            }
            
            long startTime = Millis;
            loop
            {
                
                
                string optPath = codePath;
                
                string extension = Path.GetExtension(codePath);
                string zcodePath  = codePath.Replace(extension, ".zcode");
                zcodePath = Path.GetFileName(zcodePath);
                zcodePath = Path.Combine("/Debug/Obj", zcodePath);
                
                if (File.Exists(zcodePath))
                {
                    if (!ParseCode(zcodePath, false, true))
                    {
                        break;
                    }
                }
                
                
                uint loadCode = Z80Code.Load(codePath);
                long codeBefore = Z80Code.GetPreAmbleSize();
                long codeAfter;
                
                uint pass = 0;
                loop
                {
                    if (!Optimize(pass, ref codeBefore, ref codeAfter))
                    {
                        break;
                    }
                    pass++;
                }
                if (codeBefore != loadCode) 
                { 
                    PrintLn("loadCode=" + loadCode.ToString() + ", codeBefore=" + codeBefore.ToString());
                    Die(0x0B); 
                }
                               
                Parser.ProgressTick(".");
                
                // save on success:
                if (!Z80Code.Save(codePath, ref codeAfter)) // testing round trip for now
                {
                    break;
                }
                if (!Z80Code.SaveSymbols(zcodePath))
                {
                    break;
                }
                
                success = true;
                if (!Parser.IsInteractive())
                {
                    long saved = codeBefore - codeAfter;
                    PrintLn();
                    Print("Success, " + codeBefore.ToString() + "->" + codeAfter.ToString() + " bytes of code (" + saved.ToString() + " bytes saved),", Colour.ProgressText, Colour.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() + "s", Colour.ProgressHighlight, Colour.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                
                break;
            }
            break;
        } // loop
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }   
    } // Hopper()
}
