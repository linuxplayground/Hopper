program Z80Opt
{
    //#define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    #define DIAGNOSTICS  
      
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    
    uses "JSON/JSON"
    uses "JSON/Code"
    
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/Parser"
    
    uses "CodeGen/AsmZ80"
    
    uses "CodeModel/Z80Code"
    uses "CodeModel/Z80Points"
    
    bool isExperimental;
    bool IsExperimental { get { return isExperimental; }}

    
    const uint progressSteps = 256;
    uint progressInstructions;
    ProgessNudge()
    {
        progressInstructions++;
        if ((progressInstructions % progressSteps) == 0)
        {
            Parser.ProgressTick(".");
        }
    }
    
    bool Optimize(uint pass, ref long codeBefore, ref long codeAfter)
    {
        //PrintLn("Optimize: " + pass.ToString());
        
        bool modified = false;
    
        return modified;    
    }
    
    BadArguments()
    {
        PrintLn("Invalid arguments for Z80Opt:");
        PrintLn("  Z80OPT <hex file>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
        PrintLn("    -x         : experimental");
    }
    
      
    Hopper()
    {
        bool success = false;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length >= 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-x":
                        {
                            isExperimental = true;
                        }
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Count != 1)
            {
                BadArguments();
                break;
            }
            
            string ext = ".hex";
            string codePath = args[0];
            if (!File.Exists(ref codePath, ref ext, "/Bin/"))
            {
                BadArguments();
            }
            
            long startTime = Millis;
            loop
            {
                long codeBefore;
                long codeAfter;
                string optPath = codePath;
                
                string extension = Path.GetExtension(codePath);
                string zcodePath  = codePath.Replace(extension, ".zcode");
                zcodePath = Path.GetFileName(zcodePath);
                zcodePath = Path.Combine("/Debug/Obj", zcodePath);
                
                if (File.Exists(zcodePath))
                {
                    PrintLn(zcodePath);
                    if (!ParseCode(zcodePath, false, true))
                    {
                        break;
                    }
                }
                PrintLn("Success");
                
                uint address = 0;
                
                codeBefore = Z80Code.Load(codePath);
                              
                uint pass = 0;
                loop
                {
                    if (!Optimize(pass, ref codeBefore, ref codeAfter))
                    {
                        break;
                    }
                    pass++;
                }
                               
                Parser.ProgressTick(".");
                
                // save on success:
                if (!Z80Code.Save(codePath, ref codeAfter)) // testing round trip for now
                {
                    break;
                }
                if (!Z80Code.SaveSymbols(zcodePath))
                {
                    break;
                }
                
                success = true;
                if (!Parser.IsInteractive())
                {
                    PrintLn();
                    Print("Success, " + codeBefore.ToString() + "->" + codeAfter.ToString() + " bytes of code,", Colour.ProgressText, Colour.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() + "s", Colour.ProgressHighlight, Colour.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                
                break;
            }
            break;
        } // loop
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }   
    } // Hopper()
}
