program Assemble
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    #define SHORT_CALLS  // use CALLB to save space
    #define ASSEMBLER
    
    
// ############## Hopper VM RAM map ##############
//
// 256-byte zero page               0x0000..0x00FF
// 256-byte 6502 stack              0x0100..0x01FF
// 256-byte keyboard buffer:        0x0200..0x02FF
// 256-byte serial buffer:          0x0300..0x03FF
//                    
// 256-byte callstack (128 slots):  0x0400..0x04FF
// 256-byte type stack (256 slots): 0x0500..0x05FF
// 512-byte value stack(256 slots): 0x0600..0x06FF or 0x07FF (8 or 16 bit stack pointer)
//
// Hopper programs are loaded at 0x0700 or 0x0800 depending on size of value stack
//    
    
    uses "/Source/System/System"
    uses "/Source/System/Diagnostics"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/Parser"
    
    uses "Symbols"
    uses "Types"
    uses "Constant"
    
    uses "Directives"
    
    uses "CodeGen/Block"
    uses "CodeGen/AsmStream"
    
    bool IsDebugger  { get { return false; } }
    bool NoPackedInstructions { get { return false; } }
    
    bool isExperimental;
    bool IsExperimental { get { return isExperimental; } }
    
    uint iCurrentOverload;
    uint iHopper;
    uint iNMI;
    uint iIRQ;
    
    badArguments()
    {
        PrintLn("Invalid arguments for ASSEMBLE:");
        PrintLn("  ASSEMBLE <object json>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
        PrintLn("    -a <arch>  : target CPU: M6502|W65C02|Z80");
        PrintLn("    -x         : use experimental features");
    }
    
    <byte> initializeGlobals()
    {
        <string,variant> top = Block.Top();
        < <string> > globals = top["globals"];
        
        
        // globals
        //   <string> gNames;
        //   <string,uint> gIndex;
        //   <uint, string> gTypes;
        // code location of initialization code:
        //   <uint, long> gStartPos;
        //   <uint, uint> gStartLine;
        //   <uint, string> gSourcePath;
        
        AsmStream.New();
        
        uint gCount = Symbols.GetGlobalCount();
        for (uint gIndex = 0; gIndex < gCount; gIndex++)
        {
            <string> global;                     
            string variableType = Symbols.GetGlobalType(gIndex);
            string identifier   = Symbols.GetGlobalName(gIndex);
            global.Append(variableType);
            global.Append(identifier);
            globals.Append(global);
            
        }
        top["globals"] = globals;
        Block.ReplaceTop(top);
        
        <byte> code = AsmStream.CurrentStream;
        return code;
        
    }
    
    bool assembleConstantExpression(ref uint immediateValue)
    {
        bool hasImmediate;
        string actualType;
        string value;
        loop
        {
            <string,string> currentToken = Parser.CurrentToken;
            HopperToken tokenType = Token.GetType(currentToken);
            if (tokenType == HopperToken.LParen)
            {
                Parser.Advance(); // (
                currentToken = Parser.CurrentToken;
                value = ParseConstantExpression("uint", ref actualType, true);
                if (Parser.HadError)
                {
                    break;
                }
                <string,string> previousToken = Parser.PreviousToken;
                if (previousToken["pos"] == currentToken["pos"])
                {
                    Parser.Error("simple (nn) considered dangerous, did you mean [..]?");
                }
                Parser.Consume(HopperToken.RParen);
            }
            else
            {
                value = ParseConstantExpression("uint", ref actualType, true);
                if (Parser.HadError)
                {
                    break;
                }
            }
            
            if ((actualType == "uint") || (actualType == "byte"))
            {
                hasImmediate = UInt.TryParse(value, ref immediateValue);
            }
            break;
        } // loop
        return hasImmediate;
    }
    
    bool assembleBlockScope()
    {
        bool success = false;
        loop
        {
            Block.PushBlock(false); // for block locals
            assembleBlock();
            Block.PopBlock();
            AsmStream.InsertDebugInfo(true);
            success = !Parser.HadError;
            break;
        }
        return success;
    }
    
    bool assembleSwitchStatement()
    {
        bool success = false;
        loop
        {
            uint opcodeJSR = GetJSRInstruction();
            uint opcodeJMP = GetJMPInstruction();
            bool tableCandidate;
            
            <byte,uint> jumpRecords; // <caseLabel,methodIndex>
            uint defaultIndex;
            
            <uint> caseLabels;
            <uint> jumpEnds;
            
            uint jumpToTable = AsmStream.NextAddress;
            uint fakeJump = jumpToTable + 3;
            AsmStream.AppendCode(byte(opcodeJMP));
            AsmStream.AppendCode(byte(fakeJump & 0xFF));
            AsmStream.AppendCode(byte(fakeJump >> 8));
            
            Parser.Advance(); // switch
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }
            
            <string,string> currentToken = Parser.CurrentToken;
            HopperToken tokenType = Token.GetType(currentToken);
            if (tokenType != HopperToken.Register)
            {
                Parser.Error("register expected");
                break;
            }  
            char registerName = (currentToken["lexeme"]).GetChar(0);
            Parser.Advance();
            
            tableCandidate = (registerName == 'X'); // JMP [nnnn,X]
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            
            Parser.Consume(HopperToken.LBrace);
            if (Parser.HadError)
            {
                break;
            }
            bool defaultSeen = false;
            loop
            {
                if (Parser.Check(HopperToken.RBrace))
                {
                    success = true;
                    Parser.Advance(); // }
                    break;
                }
                if (Parser.Check(HopperToken.EOF))
                {
                    Parser.ErrorAtCurrent("unexpected EOF in 'switch'");
                    break;
                }
                <byte> currentCaseLabels;
                bool   isDefault = false;
                
                if (!Parser.CheckKeyword("case"))
                {
                    if (Parser.CheckKeyword("default"))
                    {
                        isDefault = true;       
                        if (defaultSeen)
                        {
                            Parser.ErrorAtCurrent("'default' can only occur once");
                            break;    
                        }
                        defaultSeen = true;
                    }
                    else
                    {
                        Parser.ErrorAtCurrent("'case' expected");
                        break;
                    }
                }
                if (defaultSeen && !isDefault)
                {
                    Parser.ErrorAtCurrent("'default' must be last case");
                    break;    
                }      
                <uint> jumpNexts;
                <uint> jumpMatches;
                
                loop
                {
                    AsmStream.InsertDebugInfo(false);
                    
                    Parser.Advance(); // "case" or "default"
// next:         
                    if (!isDefault)
                    {   
                        string actualType;
                        string caseConstant = ParseConstantExpression("byte", ref actualType, true);
                        if (Parser.HadError)
                        {
                            break;
                        }
                        
                        uint cc;
                        if (UInt.TryParse(caseConstant, ref cc))
                        {
                            if (cc > 255)
                            {
                                IE();
                            }
                            AsmStream.AddInstructionCMP(registerName, byte(cc));
                        }
                        else
                        {
                            Parser.Error("unexpected 'case' constant '" + caseConstant + "'");   
                            break;             
                        }
                        if (caseLabels.Contains(cc))
                        {
                            Parser.Error("duplicate 'case' constant '" + caseConstant + "'");
                            break;
                        }
                        caseLabels.Append(cc);
                        currentCaseLabels.Append(byte(cc));
                    
                    } // !isDefault
                    
                    Parser.Consume(HopperToken.Colon);
                    if (Parser.HadError)
                    {
                        break;
                    }
                    
                    if (!isDefault)
                    {
                        // compare with case constant
                        AsmStream.AppendCode(GetBInstruction("Z"));
                        AsmStream.AppendCode(+3);
            
                        uint jumpNext = AsmStream.NextAddress;
                        jumpNexts.Append(jumpNext);
                        AsmStream.AddInstructionJ();
                        
                        if (Parser.CheckKeyword("case"))
                        {
                            uint jumpMatch = AsmStream.NextAddress;
                            AsmStream.AddInstructionJ();
                            jumpMatches.Append(jumpMatch);
                            
                            uint nextAddress = AsmStream.NextAddress;
                            AsmStream.PatchJump(jumpNexts[0], nextAddress);  
                            jumpNexts.Clear();
                            
                            continue; // multiple cases
                        }
                    }
                    break;
                } // loop: multiple "case"
                
                if (Parser.HadError)
                {
                    break;
                }
// match:       
                foreach (var jumpMatch in jumpMatches)
                {        
                    uint nextAddress = AsmStream.NextAddress;
                    AsmStream.PatchJump(jumpMatch, nextAddress);   
                }
                 
                uint beforeBlock = AsmStream.NextAddress;
                    
                Block.PushBlock(false); // not loop context
                assembleBlock();
                Block.PopBlock();
                
                uint afterBlock = AsmStream.NextAddress;
                uint blockSize  = afterBlock - beforeBlock;
                if (tableCandidate)
                {
                    if (blockSize != 3)
                    {
                        tableCandidate = false;
                    }
                    else
                    {
                        byte opCode  = AsmStream.GetCodeByte(afterBlock - blockSize);
                        uint methodIndex = AsmStream.GetCodeByte(afterBlock - blockSize+1) + (AsmStream.GetCodeByte(afterBlock - blockSize+2) << 8);
                        if (opCode == opcodeJSR)
                        {
                            if (isDefault)
                            {
                                defaultIndex = methodIndex;
                            }
                            else
                            {
                                foreach (var caseLabel in currentCaseLabels)
                                {
                                    jumpRecords[caseLabel] = methodIndex;
                                }
                            }
                        }
                        else
                        {
                            tableCandidate = false;
                        }
                    }
                }
                
                AsmStream.InsertDebugInfo(true); 
                
                uint jumpEnd = AsmStream.NextAddress;
                AsmStream.AddInstructionJ();
                jumpEnds.Append(jumpEnd);
// next:        
                // next case will be after the block if there was one
                foreach (var jumpNext in jumpNexts)
                {        
                    uint nextAddress = AsmStream.NextAddress;
                    AsmStream.PatchJump(jumpNext, nextAddress);   
                }
            } // loop
// end:         
            uint endAddress = AsmStream.NextAddress;
            foreach (var jumpEnd in jumpEnds)
            {
                uint ui = jumpEnd;
                AsmStream.PatchJump(ui, endAddress);
            }
            
            tableCandidate = tableCandidate && (defaultIndex != 0);
            tableCandidate = tableCandidate && (jumpRecords.Count > 8);
            if (tableCandidate)
            {
                tableCandidate = false;
                currentToken   = Parser.CurrentToken;
                tokenType      = Token.GetType(currentToken);
                if (tokenType == HopperToken.Keyword)
                {
                    tableCandidate = currentToken["lexeme"] == "return";
                }
                else if (tokenType == HopperToken.RBrace)
                {
                    tableCandidate = (Block.BlockDepth() == 2); // program | unit + current method
                }
            }
            if (tableCandidate)
            {   
                <uint> jumpList;
                uint i = 0;
                for (; i < 256; i++)
                {
                    if (!jumpRecords.Contains(byte(i)))
                    {
                        jumpList.Append(defaultIndex);
                    }
                    else
                    {
                        jumpList.Append(jumpRecords[i]);
                    }
                }
                
                uint tableAddress = AsmStream.NextAddress;
                AsmStream.PatchJump(jumpToTable, tableAddress);
                
                AsmStream.AddInstructionCMP('X', 0x80);
                AsmStream.AppendCode(GetBInstruction("NC"));
                AsmStream.AppendCode(+3);
                uint jumpSecond = AsmStream.NextAddress;
                AsmStream.AddInstructionJ();
            
                OpCodes.EmitInstruction("TXA");
                OpCodes.EmitInstruction("ASL");
                OpCodes.EmitInstruction("TAX");
                
                uint indexJump  = AsmStream.NextAddress;
                fakeJump = indexJump + 3;
                AsmStream.AppendCode(GetJMPIndexInstruction()); // JMP [nnnn,X]
                AsmStream.AppendCode(byte(fakeJump & 0xFF));
                AsmStream.AppendCode(byte(fakeJump >> 8));
                for (uint ii=0; ii < 0x80; ii++)
                {
                    uint methodIndex = jumpList[ii];
                    AsmStream.AppendCode(byte(methodIndex & 0xFF));
                    AsmStream.AppendCode(byte(methodIndex >> 8));
                }
                
                uint secondTableAddress = AsmStream.NextAddress;
                AsmStream.PatchJump(jumpSecond, secondTableAddress);
                OpCodes.EmitInstruction("TXA");
                OpCodes.EmitInstruction("SEC");
                OpCodes.EmitInstruction("SBC", 0x80);
                OpCodes.EmitInstruction("ASL");
                OpCodes.EmitInstruction("TAX");
                
                indexJump  = AsmStream.NextAddress;
                fakeJump = indexJump + 3;
                AsmStream.AppendCode(0x7C); // JMP [nnnn,X]
                AsmStream.AppendCode(byte(fakeJump & 0xFF));
                AsmStream.AppendCode(byte(fakeJump >> 8));
                for (uint ii=0x80; ii < 0x100; ii++)
                {
                    uint methodIndex = jumpList[ii];
                    AsmStream.AppendCode(byte(methodIndex & 0xFF));
                    AsmStream.AppendCode(byte(methodIndex >> 8));
                }
            }
            break;
            
        } // loop
        return success;
    }
    
    bool assembleIfStatement()
    {
        bool success = false;
        bool wasElse = false;
        <uint> jumpEnds;
        loop
        {
            AsmStream.InsertDebugInfo(false); // could be a 2nd 'else if'
            
            Parser.Advance(); // if
            
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }
            
            <string,string> currentToken = Parser.CurrentToken;
            string conditionString = currentToken["lexeme"];
            HopperToken tokenType = Token.GetType(currentToken);
            if (tokenType != HopperToken.Condition)
            {
                Parser.Error("condition expected");
                break;
            }  
            Parser.Advance();
            
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            
            AsmStream.AppendCode(GetBInstruction(conditionString));
            AsmStream.AppendCode(+3);
            
            // if false jump past
            uint jumpPast = AsmStream.NextAddress;
            AsmStream.AddInstructionJ();
                       
            Block.PushBlock(false); // not a loop context
            assembleBlock();
            Block.PopBlock();
            if (Parser.HadError)
            {
                break;
            }
            
            AsmStream.InsertDebugInfo(true);
            
            // jump end (past a potential "else" block)
            uint jumpEnd = AsmStream.NextAddress;
            jumpEnds.Append(jumpEnd);
            AsmStream.AddInstructionJ();
// past:    
            uint pastAddress = AsmStream.NextAddress;
            AsmStream.PatchJump(jumpPast, pastAddress);        
                        
            if (Parser.CheckKeyword("else"))
            {
                wasElse = true; // there was at least one else clause
                Advance(); // else
                if (Parser.CheckKeyword("if"))
                {
                    continue; // else if
                }   
                // final else block
                Block.PushBlock(false); // not a loop context
                assembleBlock();
                Block.PopBlock();
            }
// end:     
            if (wasElse)
            {       
                foreach (var jump in jumpEnds)
                {
                    AsmStream.PatchJump(jump, AsmStream.NextAddress);
                }
            }
            else
            {
                // simple if with no "else" clause/s
                uint jumpSize = 3; // this is always a 3 byte jump (for 6502, it could be BRA followed by NOP)
                AsmStream.PopTail(jumpSize);
                AsmStream.PatchJump(jumpPast, pastAddress-jumpSize);
                
            }
            success = true;                    
            break;
        }
        return success;
    }
    bool assembleLoop()
    {
        bool success = false;
        loop
        {
            Parser.Advance(); // loop

            Block.PushBlock(true); // loop context
            uint continueAddress = AsmStream.NextAddress;
            
            Block.PushBlock(false); // for block locals
            assembleBlock();
            Block.PopBlock();
            AsmStream.InsertDebugInfo(true);
            
            AsmStream.AddInstructionJ(continueAddress);
            
            uint breakAddress = AsmStream.NextAddress;
            Block.PopBlock(continueAddress, breakAddress);
            if (Parser.HadError)
            {
                break;
            }
            success = true;                    
            break;
        }
        return success;    
    }
    bool assembleReturn()
    {
        bool success = false;
        loop
        {
            Parser.Advance(); // return
            <string,variant> blockContext = Block.GetMethodBlock();
            if (blockContext.Count != 0)
            {
                if (blockContext.Contains("returntype"))
                {
                    Die(0x0B); // not supported yet
                }
            }
            
            // bytesToPop = locals + arguments
            uint bytesToPop = Block.GetLocalsToPop(true, iCurrentOverload == 0);
            AsmStream.AddInstructionRET(bytesToPop);
            success = true;
            break;
        }
        return success;        
    }
    bool assembleBreak()
    {
        bool success = true;
        
        Parser.Advance(); // break;
        
        // - pop all locals till inner loop
        uint bytesToPop = Block.GetBytesToPop(true, false);
        if (bytesToPop > 0)
        {
            Die(0x0B);            
        }
               
        // - jump to current inner loop 'exit'
        uint breakJump = AsmStream.NextAddress;
        AsmStream.AddInstructionJ();
        if (!Block.AddBreakPatch(breakJump))
        {
            Parser.ErrorAtCurrent("'break' must be inside loop block");
            success = false;
        }
        
        return success;
    }
    bool assembleContinue()
    {
        bool success = true;
        
        Parser.Advance(); // continue;
        
        // - pop all locals till inner loop
        uint bytesToPop = Block.GetBytesToPop(true, true);
        if (bytesToPop > 0)
        {
            Die(0x0B);
        }
        // - jump to current inner loop 'next'
        uint continueJump = AsmStream.NextAddress;
        AsmStream.AddInstructionJ();
        if (!Block.AddContinuePatch(continueJump))
        {
            Parser.ErrorAtCurrent("'continue' must be inside loop block");
            success = false;
        }
        
        return success;
    }
    
    bool assembleMethodCall(string methodName)
    {
        bool success = false;
        loop
        {
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            string returnType;
            < <string > > arguments;
            if (!methodName.Contains('.'))
            {
                methodName = Types.QualifyMethodName(methodName);
            }
            uint iOverload = Types.FindVisibleOverload(methodName, arguments, ref returnType);
            if (Parser.HadError)
            {
                break;
            }
            
            Symbols.OverloadToCompile(iOverload); // CompileMethodCall(methodName): Setters, function calls, actual method calls
            Symbols.AddFunctionCall(iOverload);   // CompileMethodCall(methodName)
            
            AsmStream.AddInstructionCALL(iOverload);
            success = true;
            break;
        } // loop
        return success;
    }
    bool assembleInstructionZ80()
    {
        // Z80 instruction forms
        //
        // instr
        // instr R
        // instr RR
        // instr R, nn
        // instr R, nnnn
        // instr R, R
        // instr RR, RR
        // instr [RR]
        // instr R, [RR]
        // instr [RR], R
        // instr [nnnn], R
        // instr dd
        // instr C, dd
        // instr C
        // instr C, nnnn
        // instr nnnn
        
        Die(0x0A);
        return false;
    }
    bool assembleInstruction6502()
    {
        // Z80 instruction forms
        //
        // Implied:
        //     RTS
        // Accumulator:
        //     INC A
        // Immediate:
        //     LDA #nn
        // Absolute:
        //     LDA nnnn
        // X-Indexed Absolute:
        //     LDA nnnn,X
        // Y-Indexed Absolute:
        //     LDA nnnn,Y
        // Absolute Indirect:
        //     JMP [nnnn]
        // Absolute X-Indexed Indirect:
        //     JMP [nnnn,X]
        // Zero Page:
        //     LDA nn   (same as LDA 00nn)
        // X-Indexed Zero Page:
        //     LDA nn,X (same as LDA 00nn, X) 
        // Y-Indexed Zero Page:
        //     LDX nn,Y (same as LDA 00nn, Y) 
        // Zero Page Indirect:
        //     LDA [nn]
        // X-Indexed Zero Page Indirect:
        //     LDA [nn,X]
        // Zero Page Indirect Y-Indexed:
        //     LDA [nn],Y
        // Relative:
        //     BEQ dd
        
        bool success = false;
        loop
        {
            <string,string> currentToken = Parser.CurrentToken;
            HopperToken tokenType;
            string instructionName = currentToken["lexeme"];
            Parser.Advance();
            
            currentToken = Parser.CurrentToken;
            tokenType = Token.GetType(currentToken);
            
            AddressingModes addressingModes = OpCodes.GetAddressingModes(instructionName);
            
            if (addressingModes == AddressingModes.Implied)
            {
                OpCodes.EmitInstruction(instructionName);
                success = true;
                break;
            }
            if (addressingModes == AddressingModes.Relative)
            {
                int offset;
                // -128 .. 127
                bool negative;
                if (tokenType == HopperToken.Subtract)
                {
                    Parser.Advance(); // '-' 
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                    negative = true; 
                }
                else if (tokenType == HopperToken.Add)
                {
                    Parser.Advance(); // '+'    
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                }
                if ((tokenType == HopperToken.Integer) && Int.TryParse(currentToken["lexeme"], ref offset))
                {
                    Parser.Advance(); // <offset>
                    OpCodes.EmitInstruction(instructionName, negative ? -offset : offset);
                    success = true;
                    break;
                }
                else
                {
                    Parser.ErrorAtCurrent("integer offset (-128..127) expected");
                }
                break;
            }
            if ((addressingModes & AddressingModes.Accumulator) == AddressingModes.Accumulator)
            {
                if ((tokenType == HopperToken.Register) && (currentToken["lexeme"] == "A"))
                {
                    Parser.Advance(); // 'A'
                    OpCodes.EmitInstruction(instructionName);
                    success = true;
                    break;
                }
            }
            bool expectImmediate;
            if ((addressingModes & AddressingModes.Immediate) == AddressingModes.Immediate)
            {
                if (tokenType == HopperToken.Hash)
                {
                    Parser.Advance(); // '#'
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                    expectImmediate = true;
                }
                if ((tokenType == HopperToken.Identifier) || (tokenType == HopperToken.DottedIdentifier))
                {
                    if ((currentToken["lexeme"]).StartsWith('#'))
                    {
                        expectImmediate = true;
                    }
                }
            }
            bool expectIndirect;
            if ((addressingModes & (AddressingModes.AbsoluteIndirect
                                   |AddressingModes.AbsoluteIndirectX
                                   |AddressingModes.ZeroPageIndirect
                                   |AddressingModes.XIndexedZeroPage
                                   |AddressingModes.YIndexedZeroPage)) != AddressingModes.None)
            {
                if (tokenType == HopperToken.LBracket)
                {
                    Parser.Advance(); // '['
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                    expectIndirect = true;
                }
            }
                        
            bool hasImmediate;
            uint immediateValue;
            
            switch (tokenType)
            {
                case HopperToken.Char:
                case HopperToken.Integer:
                case HopperToken.Identifier:
                case HopperToken.DottedIdentifier:
                case HopperToken.LParen:
                {
                    hasImmediate = assembleConstantExpression(ref immediateValue);
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                }
            }
            
            if (expectImmediate)
            {
                if (!hasImmediate || (immediateValue > 255))
                {
                    Parser.Error("immediate byte value expected");
                }
                else
                {
                    OpCodes.EmitInstruction(instructionName, byte(immediateValue));
                    success = true;
                }
                break;
            }
            if (!hasImmediate)
            {
                // Second swing at Accumulator, where we just assume 'A'
                //   There are only 6 instructions that have Accumulator addressing mode and all their
                //   alternate addressing modes would have had an immediate operand next so ...
                if ((addressingModes & AddressingModes.Accumulator) == AddressingModes.Accumulator)
                {
                    OpCodes.EmitInstruction(instructionName);
                    success = true;
                    break;
                }
                Parser.Error("immediate operand expected");
                break;
            }
            
            if ((addressingModes & (AddressingModes.ZeroPageRelative)) == AddressingModes.ZeroPageRelative)
            {
                if (tokenType != HopperToken.Comma)
                {
                    Parser.Error("',' expected");
                    break;
                }
                if (immediateValue > 255)
                {
                    Parser.Error("byte zero page address");
                    break;
                }
                Parser.Advance();
                
                currentToken = Parser.CurrentToken;
                tokenType = Token.GetType(currentToken);
                
                int offset;
                // -128 .. 127
                bool negative;
                if (tokenType == HopperToken.Subtract)
                {
                    Parser.Advance(); // '-' 
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                    negative = true; 
                }
                else if (tokenType == HopperToken.Add)
                {
                    Parser.Advance(); // '+'    
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                }
                if ((tokenType == HopperToken.Integer) && Int.TryParse(currentToken["lexeme"], ref offset))
                {
                    Parser.Advance(); // <offset>
                    
                    // ZeroPageRelative=0x8000,          // nn,dd
                    OpCodes.EmitInstructionZeroPageRelative(instructionName, byte(immediateValue), negative ? -offset : offset);
                    
                    success = true;
                    break;
                }
                else
                {
                    Parser.ErrorAtCurrent("integer offset (-128..127) expected");
                    break;
                }
           }
            
            char registerName;
            bool rparenConsumed;
            if ((addressingModes & (AddressingModes.AbsoluteIndirectX
                                   |AddressingModes.XIndexedZeroPage
                                   |AddressingModes.YIndexedZeroPage
                                   |AddressingModes.ZeroPageX
                                   |AddressingModes.ZeroPageY
                                   |AddressingModes.AbsoluteX
                                   |AddressingModes.AbsoluteY
                                   |AddressingModes.ZeroPageRelative
                                   )) != AddressingModes.None)
            {
                if (tokenType == HopperToken.RBracket)
                {
                    if ((addressingModes & (AddressingModes.YIndexedZeroPage)) == AddressingModes.YIndexedZeroPage)
                    {
                        Parser.Advance(); // ')'
                        currentToken = Parser.CurrentToken;
                        tokenType = Token.GetType(currentToken);
                        rparenConsumed = true;
                    }
                }
                if (tokenType == HopperToken.Comma)
                {
                    Parser.Advance(); // ','
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                    if ((tokenType != HopperToken.Register) || ((currentToken["lexeme"] != "X") && (currentToken["lexeme"] != "Y")))
                    {
                        Parser.ErrorAtCurrent("index register expected");
                        break;
                    }
                    string registerString = currentToken["lexeme"];
                    registerName = registerString[0];
                    Parser.Advance(); // X|Y
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                }
            }
                       
            if (immediateValue <= 255)
            {
                byte operand = byte(immediateValue);
                if (expectIndirect)
                {
                    switch (registerName)
                    {
                        case 'X':
                        {
                            if ((addressingModes & (AddressingModes.XIndexedZeroPage)) != AddressingModes.XIndexedZeroPage)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // XIndexedZeroPage=0x1000,  // [nn,X]
                            OpCodes.EmitInstructionZeroPage(instructionName, byte(immediateValue), AddressingModes.XIndexedZeroPage);
                        }
                        case 'Y':
                        {
                            if ((addressingModes & (AddressingModes.YIndexedZeroPage)) != AddressingModes.YIndexedZeroPage)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // YIndexedZeroPage=0x2000,  // [nn], Y
                            OpCodes.EmitInstructionZeroPage(instructionName, byte(immediateValue), AddressingModes.YIndexedZeroPage);
                        }
                        default:
                        {
                            if ((addressingModes & (AddressingModes.ZeroPageIndirect)) != AddressingModes.ZeroPageIndirect)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // ZeroPageIndirect=0x0800,  // [nn]
                            OpCodes.EmitInstructionZeroPage(instructionName, byte(immediateValue), AddressingModes.ZeroPageIndirect);
                        }
                    }
                }
                else
                {
                    switch (registerName)
                    {
                        case 'X':
                        {
                            if ((addressingModes & (AddressingModes.ZeroPageX)) != AddressingModes.ZeroPageX)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // ZeroPageX=0x0200,         // nn,X
                            OpCodes.EmitInstructionZeroPage(instructionName, byte(immediateValue), AddressingModes.ZeroPageX);
                        }
                        case 'Y':
                        {
                            if ((addressingModes & (AddressingModes.ZeroPageY)) != AddressingModes.ZeroPageY)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // ZeroPageY=0x0400,         // nn,Y
                            OpCodes.EmitInstructionZeroPage(instructionName, byte(immediateValue), AddressingModes.ZeroPageY);
                        }
                        default:
                        {
                            if ((addressingModes & (AddressingModes.ZeroPage)) != AddressingModes.ZeroPage)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // ZeroPage=0x0100,          // nn
                            OpCodes.EmitInstructionZeroPage(instructionName, byte(immediateValue), AddressingModes.ZeroPage);
                        }
                    }
                }
            }
            else // > 255
            {
                uint operand = immediateValue;
                if (expectIndirect)
                {
                    if (registerName == 'X')
                    {
                        if ((addressingModes & (AddressingModes.AbsoluteIndirectX)) != AddressingModes.AbsoluteIndirectX)
                        {
                            Parser.Error("internal error"); Die(0x0B);
                        }
                        // AbsoluteIndirectX=0x0080, // [nnnn,X]
                        OpCodes.EmitInstructionAbsolute(instructionName, immediateValue, AddressingModes.AbsoluteIndirectX);
                    }
                    else
                    {
                        if ((addressingModes & (AddressingModes.AbsoluteIndirect)) != AddressingModes.AbsoluteIndirect)
                        {
                            Parser.Error("internal error"); Die(0x0B);
                        }
                        // AbsoluteIndirect=0x0040,  // [nnnn]
                        OpCodes.EmitInstructionAbsolute(instructionName, immediateValue, AddressingModes.AbsoluteIndirect);
                    }
                }
                else
                {
                    switch (registerName)
                    {
                        case 'X':
                        {
                            if ((addressingModes & (AddressingModes.AbsoluteX)) != AddressingModes.AbsoluteX)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // AbsoluteX=0x0020,         // nnnn,X
                            OpCodes.EmitInstructionAbsolute(instructionName, immediateValue, AddressingModes.AbsoluteX);
                        }
                        case 'Y':
                        {
                            if ((addressingModes & (AddressingModes.AbsoluteY)) != AddressingModes.AbsoluteY)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // AbsoluteY=0x0010,         // nnnn,Y
                            OpCodes.EmitInstructionAbsolute(instructionName, immediateValue, AddressingModes.AbsoluteY);
                        }
                        default:
                        {
                            if ((addressingModes & (AddressingModes.Absolute)) != AddressingModes.Absolute)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // Absolute=0x0008,          // nnnn
                            OpCodes.EmitInstructionAbsolute(instructionName, immediateValue, AddressingModes.Absolute);
                        }
                    }
                }
            }
            
            success = true;
            if (expectIndirect && !rparenConsumed)
            {
                Parser.Consume(HopperToken.SemiColon);
                if (Parser.HadError)
                {
                    success = false;
                }
            }
            break;
        }
        return success;
    }
    
    bool assembleStatement(bool noSemiColon, bool debugInfoInsert)
    {
        bool success = false;
        <string,string> currentToken = Parser.CurrentToken;
        string tokenString = currentToken["lexeme"];
        HopperToken tokenType = Token.GetType(currentToken);
        if (debugInfoInsert)
        {
            AsmStream.InsertDebugInfo(false);
        }
        
        switch (tokenType)
        {
            case HopperToken.Keyword:
            {
                if (tokenString == "if")
                {
                    success = assembleIfStatement();
                    noSemiColon = true;
                }
                else if (tokenString == "switch")
                {
                    success = assembleSwitchStatement();
                    noSemiColon = true;
                }
                else if (tokenString == "return")
                {
                    success = assembleReturn();
                }
                else if (tokenString == "break")
                {
                    success = assembleBreak();
                }
                else if (tokenString == "continue")
                {
                    success = assembleContinue();
                }
                else if (tokenString == "loop")
                {
                    success = assembleLoop();
                    noSemiColon = true;
                }
                else
                {
                    // simple type
                    Parser.ErrorAtCurrent("no local declarations in assembly");
                }
            }
            case HopperToken.Instruction:
            {
                if (Architecture == CPUArchitecture.Z80A)
                {
                    success = assembleInstructionZ80();
                }
                else
                {    
                    success = assembleInstruction6502();
                }
                noSemiColon = true;
            }
            default:
            {
                if (   (tokenType == HopperToken.Identifier) 
                    || (tokenType == HopperToken.DottedIdentifier)
                    || (tokenType == HopperToken.Discarder)
                   )
                {
                    bool isDotted    = (tokenType == HopperToken.DottedIdentifier);
                    HopperToken nextTokenType = Parser.PeekTokenType();
                    if (Types.IsEnum(tokenString) || Types.IsFlags(tokenString))
                    {
                        Parser.ErrorAtCurrent("no local declarations in assembly");
                    }
                    else if (nextTokenType == HopperToken.Identifier)
                    {
                        Parser.ErrorAtCurrent("no local declarations in assembly");
                    }
                    else
                    {
                        Advance();
                        <string,string> idToken   = Parser.PreviousToken;
                        tokenString = idToken["lexeme"];
                        tokenType = Token.GetType(Parser.CurrentToken);
                        if (tokenType == HopperToken.LParen)
                        {
                            // method call
                            success = assembleMethodCall(tokenString);
                        }
                        else
                        {
                            if (!Parser.HadError)
                            {
                                Parser.ErrorAtCurrent("'(' expected");
                            }
                        }
                    }
                }
                else
                {
                    // failed
                }
            }
        } // switch (tokenType)
        if (success && !noSemiColon)
        {
            Parser.Consume(HopperToken.SemiColon);
            if (Parser.HadError)
            {
                success = false;
            }
        }
        return success;
    }
    
    assembleBlock()
    {
        loop
        {
            if (!Parser.Check(HopperToken.LBrace))
            {
                Parser.ErrorAtCurrent('{');
                break;
            }
            
            Parser.Advance(); // {
            loop
            {
                // next statement ..
                if (Parser.HadError)
                {
                    break;
                }
                if (Parser.Check(HopperToken.Directive))
                {
                    // preprocessor directives (#ifdef, #ifndef, #else, #endif")
                    Directives.Directive();
                }
                else
                {
                    // not directive
                    bool allDefined = Directives.IsAllDefined();
                    if (!allDefined)
                    {
                        loop
                        {
                            if (Parser.Check(HopperToken.Directive))
                            {
                                break;
                            }
                            if (Parser.Check(HopperToken.EOF))
                            {
                                break;
                            }
                            Parser.Advance(); // gobble gobble
                        }
                    }
                    else if (Parser.Check(HopperToken.RBrace))
                    {
                        Advance(); // }
                        break; // end of method
                    }
                    else
                    {      
                        <string,string> currentToken = Parser.CurrentToken;
                        HopperToken tokenType = Token.GetType(currentToken);
                        if (   (tokenType == HopperToken.Keyword)           // simple type, "if", "while", ...
                            || (tokenType == HopperToken.Identifier)        // assignment, procedure call
                            || (tokenType == HopperToken.Discarder)         // assignment   
                            || (tokenType == HopperToken.DottedIdentifier) 
                            || (tokenType == HopperToken.Instruction)
                            )
                        {
                            if (!assembleStatement(false, true))
                            {
                                if (!Parser.HadError)
                                {
                                    Parser.ErrorAtCurrent("bad statement?");
                                }
                                break;
                            }
                        }
                        else if (tokenType == HopperToken.LBrace)
                        {
                            AsmStream.InsertDebugInfo(false);
                            if (!assembleBlockScope())
                            {
                                if (!Parser.HadError)
                                {
                                    Parser.ErrorAtCurrent("bad 'block' statement?");
                                }
                                break;
                            }
                        }
                        else
                        {
                            DumpPrevious();
                            DumpCurrent();
                            Parser.ErrorAt(currentToken, "keyword or identifier expected");
                            break;
                        }
                    }
                }   
            } // loop
            break;
        } // loop
    }
    
    
    bool assemble()
    {
        <byte> globalCode = initializeGlobals();
        
        
        
        
        bool success = false;
        bool isMain = true;
        uint iMain = iCurrentOverload;
        loop
        {
            if (HadError)
            {
                break;
            }
            
            // compile fIndex
            <string, string> startToken = Symbols.GetOverloadStart(iCurrentOverload);
            Scanner.Reset(startToken);
            Parser.Reset();
            Directives.New();
            AsmStream.New();
            
            if (globalCode.Count != 0)
            {
                AsmStream.AppendCode(globalCode);
                globalCode.Clear();
            }
            
            Types.SetCurrentMethod(iCurrentOverload);
                                                                                                                                                                    
            Parser.Advance(); // load first token
            
            <string,string> braceToken = Parser.CurrentToken; // for CodeGen location
            
            if (isMain)
            {
                AsmStream.AddInstructionRESET();
            }
            AsmStream.AddInstructionENTER();
            if (!isMain) // already pushed with globals
            {
                Block.PushBlock(false); // new block context
            }
            
            <string,variant> blockContext = Block.Top();
            < < string > > arguments = Symbols.GetOverloadArguments(iCurrentOverload);
            if (arguments.Count != 0)
            {
                Die(0x0B); // no return types in Assembly : preprocess should catch this
            }
            blockContext["arguments"] = arguments;
            blockContext["iOverload"] = iCurrentOverload.ToString();
            string returnType = Symbols.GetOverloadReturnType(iCurrentOverload);
            if (returnType != "void")
            {                    
                Die(0x0B); // no return types in Assembly : preprocess should catch this
            }
            Block.ReplaceTop(blockContext);
                     
            assembleBlock();
            
            if (Parser.HadError)
            {
                break;
            }
            Parser.ProgressTick(".");
            
            // check that #ifdef nesting is zero
            if (Directives.IsStillOpen)
            {
                Parser.ErrorAtCurrent("'#endif' expected before end of method");
                break;
            }
            
            <string,string> previousToken = Parser.PreviousToken;
            HopperToken tokenType = Token.GetType(previousToken);
            if (tokenType != HopperToken.RBrace)
            {
                DumpCurrent();
                DumpPrevious();
                Parser.Error("'}' expected in assemble()!!");
                Die(0x0B);
            }
            
            AsmStream.InsertDebugInfo(true);
            
            uint bytesToPop = Block.GetLocalsToPop(true, isMain);
            AsmStream.AddInstructionRET(bytesToPop);
            
            if (!isMain)
            {
                Block.PopBlock();
            }
            else
            {
                Block.Export(0);
                
                // pop "main" locals and arguments but keep globals
                <string,variant> mainContext = Block.Top();
                < <string> > empty;
                mainContext["locals"] = empty;
                mainContext["arguments"] = empty;
                Block.ReplaceTop(mainContext);
            }
            
            <byte> asmStream = AsmStream.CurrentStream;
            <string,string> debugInfo = AsmStream.DebugInfo;
            Symbols.SetCodeStream(iCurrentOverload, asmStream, debugInfo);
            AsmStream.ClearDebugInfo();
            
            Symbols.OverloadWasCompiled(iCurrentOverload);         
            if (!Symbols.OverloadNextToCompile(ref iCurrentOverload))
            {
                success = true; // all done
                break;
            }
            isMain = false;
            
        } // loop 
        iCurrentOverload = iMain;
        Types.SetCurrentMethod(iCurrentOverload);
        return success;               
    }
    
    Hopper()
    {
        bool success = false;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            bool checkedBuild = true;
            bool touchesTree = false;
          
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length == 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        case "-a":
                        {
                            iArg++;
                            switch (rawArgs[iArg])
                            {
                                case "M6502":  { Architecture = CPUArchitecture.M6502;  }
                                case "W65C02": { Architecture = CPUArchitecture.W65C02; }
                                case "Z80A":   { Architecture = CPUArchitecture.Z80A;   }
                            } 
                        }
                        case "-x":
                        {
                            isExperimental = true;   
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if ((args.Count != 1) || (Architecture == CPUArchitecture.None))
            {
                badArguments();
                break;
            }
            
            string jsonPath = args[0];
            string ext = ".json";
            if (!File.Exists(ref jsonPath, ref ext, "/Debug/Obj/"))
            {
                badArguments();
            }
            
            long startTime = Millis;
            loop
            {
                Symbols.New();
                if (!Symbols.Import(jsonPath))
                {
                    break;
                }
                isExperimental       = isExperimental || Symbols.DefineExists("EXPERIMENTAL");
                
                uint mIndex;
                if (!Symbols.GetFunctionIndex("Hopper", ref mIndex))
                {
                    Parser.Error("where is 'Hopper()'?");
                    break;
                }
                <uint> mOverloads = Symbols.GetFunctionOverloads(mIndex);
                if (mOverloads.Count != 1)
                {
                    Parser.Error("'Hopper()' has overloads?");
                    break;
                }
                
                Scanner.New();
                Token.InitializeAssembler(Architecture);
                
                iHopper = mOverloads[0];
                Symbols.AddFunctionCall(iHopper); // yup, main is called at least once
                
                if ((Architecture & CPUArchitecture.M6502) == CPUArchitecture.M6502)
                {
                    uint iIndex;
                    uint nIndex;
                    if (!Symbols.GetFunctionIndex("IRQ", ref iIndex))
                    {
                        Parser.Error("6502 should have an 'IRQ()' method for the isr vector destination");
                        break;
                    }
                    if (!Symbols.GetFunctionIndex("NMI", ref nIndex))
                    {
                        Parser.Error("6502 should have an 'NMI()' method for the nmi vector destination");
                        break;
                    }
                    mOverloads = Symbols.GetFunctionOverloads(iIndex);
                    if (mOverloads.Count != 1)
                    {
                        Parser.Error("'IRQ' has overloads?");
                        break;
                    }
                    iIRQ = mOverloads[0];
                    Symbols.OverloadToCompile(iIRQ);
                    Symbols.AddFunctionCall(iIRQ);
                    mOverloads = Symbols.GetFunctionOverloads(nIndex);
                    if (mOverloads.Count != 1)
                    {
                        Parser.Error("'NMI' has overloads?");
                        break;
                    }
                    iNMI = mOverloads[0];
                    Symbols.OverloadToCompile(iNMI);
                    Symbols.AddFunctionCall(iNMI);
                }

                // start with iHopper
                iCurrentOverload = iHopper;
                Block.PushBlock(false); // new block context
                if (!assemble()) 
                {
                    break;
                }
                Block.PopBlock();
                
                string extension = Path.GetExtension(jsonPath);
                string codePath = jsonPath.Replace(extension, ".code");
                if (!Symbols.ExportCode(codePath))
                {
                    break;
                }
                
                if (!IsInteractive())
                {
                    PrintLn();
                    Print("Success.", Colour.ProgressText, Colour.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() + "s", Colour.ProgressHighlight, Colour.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                success = true;
                break;
            } // main loop
            break;
        } // argument loop
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }
    }
}
