program Optimize
{
    #define JSONEXPRESS // .code and .json are generated by us so assume .json files have no errors
    
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    
    uses "/Source/Compiler/JSON/JSON"
    uses "/Source/Compiler/JSON/Code"
    
    uses "/Source/Compiler/Tokens/Token"
    uses "/Source/Compiler/Tokens/Scanner"
    uses "/Source/Compiler/Tokens/Parser"
    
    uses "/Source/Compiler/CodeGen/Instructions"
    
    <string,variant> symbols;
    
    const uint progressSteps = 2048;
    
    bool target6502;
    bool Target6502 
    { 
        get { return target6502; }
    }
    
    CheckTarget()
    {
        foreach (var kv in symbols)
        {
            switch (kv.key)
            {
                case "symbols":
                {
                    // preprocessor symbols
                    <string,string> pdValues = kv.value;
                    if (pdValues.Contains("H6502"))
                    {
                        target6502 = true;
                    }
                    break;
                }
            }
        } // kv
    }
    
    AdjustDebugIndices(ref <uint,string> indexDebugInfo, uint iMargin, int delta, bool foldENTER, uint iEnter)
    {
        // iMargin is the index currently being removed
        // delta is probably always -1
        if (delta >= 0)
        {
            Die(0x0B);
        }
        <uint,string> oldDebugInfo = indexDebugInfo;
        indexDebugInfo.Clear();
        uint iLow = 10000;
        foreach (var kv in oldDebugInfo)
        {
            uint iIndex = kv.key;
            string ln   = kv.value;
            if (iIndex < iLow)
            {
                iLow = iIndex;
            }
            if (iIndex > iMargin)
            {
                iIndex = uint(int(iIndex) + delta);
            }
            indexDebugInfo[iIndex] = ln;
        }
        if (foldENTER)
        {
            indexDebugInfo[iEnter] = oldDebugInfo[iLow];
        }
    }
    AdjustJumps(ref < <uint> > instructions, uint iMargin, int delta)
    {
        uint iIndex = 0;
        uint instructionsLength = instructions.Length;
        loop
        {
            if (iIndex == instructionsLength)
            {
                break;
            }
            <uint> instructionList = instructions[iIndex];
            Instruction opCode = Instruction(instructionList[0]);
            if (Instructions.OperandIsAddressOffset(opCode))
            {
                uint iTarget = instructionList[2];
                if (iTarget > iMargin)
                {
                    iTarget = uint(int(iTarget) + delta);
                }
                instructionList.SetItem(2, iTarget);
                instructions.SetItem(iIndex, instructionList);
            }
            iIndex++;
        }
    }
    RemoveInstruction(ref < <uint> > instructions, ref <uint,string> indexDebugInfo, uint iIndex)
    {
        RemoveInstruction(ref instructions, ref indexDebugInfo, iIndex, false, 0);
    }
    RemoveInstruction(ref < <uint> > instructions, ref <uint,string> indexDebugInfo, uint iIndex, bool foldENTER, uint iEnter)
    {
        instructions.Remove(iIndex);
        // all instructions that jump to an index > iIndex
        // need to have their target reduced by 1
        AdjustJumps(ref instructions, iIndex, -1);
        
        // all debugInfo with an index > iIndex
        // needs to be reduced by 1
        AdjustDebugIndices(ref indexDebugInfo, iIndex, -1, foldENTER, iEnter);
    }
    
    
    uint GetInstructionAddress(uint seekIndex, ref < <uint> > instructions)
    {
        uint address = 0;
        uint index = 0;
        loop
        {
            if (index == seekIndex)
            {
                break;
            }
            <uint> instruction = instructions[index];
            Instruction opCode = Instruction(byte(instruction[0]));
            byte operands = Instructions.OperandWidth(opCode);
            address = address + operands + 1;
            index++;
        }
        return address;
    }
    uint GetInstructionIndex(uint seekAddress, ref < <uint> > instructions)
    {
        uint address = 0;
        uint index = 0;
        loop
        {
            if (address == seekAddress)
            {
                break;
            }
            <uint> instruction = instructions[index];
            Instruction opCode = Instruction(byte(instruction[0]));
            byte operands = Instructions.OperandWidth(opCode);
            address = address + operands + 1;
            index++;
        }
        return index;
    }
    
    
    
    
    Instruction FlipConditionalJumpCondition(Instruction opCode)
    {
        switch (opCode)
        {
            case Instruction.JZW:
            {
                opCode = Instruction.JNZW;
            }
            case Instruction.JNZW:
            {
                opCode = Instruction.JZW;
            }
            case Instruction.JZB:
            {
                opCode = Instruction.JNZB;
            }
            case Instruction.JNZB:
            {
                opCode = Instruction.JZB;
            }
            default:
            {
                Die(0x0B); // expected a conditional jump
            }
        }
        return opCode;
    }
    bool IsJumpInstruction(Instruction opCode)
    {
        return ((opCode == Instruction.JW) || (opCode == Instruction.JZW) || (opCode == Instruction.JNZW) ||
                (opCode == Instruction.JB) || (opCode == Instruction.JZB) || (opCode == Instruction.JNZB));
    }
    bool IsJumpWInstruction(Instruction opCode)
    {
        return ((opCode == Instruction.JW) || (opCode == Instruction.JZW) || (opCode == Instruction.JNZW));
    }
    bool IsJumpBInstruction(Instruction opCode)
    {
        return ((opCode == Instruction.JB) || (opCode == Instruction.JZB) || (opCode == Instruction.JNZB));
    }
    bool IsConditionalJumpInstruction(Instruction opCode)
    {
        return ((opCode == Instruction.JZW) || (opCode == Instruction.JNZW) ||
                (opCode == Instruction.JZB) || (opCode == Instruction.JNZB));
    }       
    bool IsUnconditionalJumpInstruction(Instruction opCode)
    {
        return (opCode == Instruction.JB) || (opCode == Instruction.JW);
    }
    bool IsMethodExitInstruction(Instruction opCode)
    {
        return (opCode == Instruction.RETB) || (opCode == Instruction.RET0)    || (opCode == Instruction.RETRETB) ||
               (opCode == Instruction.RETW) || (opCode == Instruction.RETRETW) || (opCode == Instruction.DIE);
    }
    bool IsPUSHInstruction(Instruction opCode)
    {
        return (opCode == Instruction.PUSHIB)       || (opCode == Instruction.PUSHI0)       || (opCode == Instruction.PUSHI1) || 
               (opCode == Instruction.PUSHIW)       || (opCode == Instruction.PUSHIM1)      ||
               (opCode == Instruction.PUSHLOCALB)   || (opCode == Instruction.PUSHGLOBALB)  || (opCode == Instruction.PUSHRELB) ||
               (opCode == Instruction.PUSHLOCALW)   || (opCode == Instruction.PUSHGLOBALW)  || (opCode == Instruction.PUSHRELW) ||
               (opCode == Instruction.PUSHLOCALB00) || (opCode == Instruction.PUSHLOCALB02);
    }
    bool IsPOPInstruction(Instruction opCode)
    {
        return (opCode == Instruction.POPLOCALB)   || (opCode == Instruction.POPGLOBALB) || (opCode == Instruction.POPRELB) ||
               (opCode == Instruction.POPLOCALW)   || (opCode == Instruction.POPGLOBALW) || (opCode == Instruction.POPRELW) ||
               (opCode == Instruction.POPLOCALB00) || (opCode == Instruction.POPLOCALB02);
    }
    Instruction SwitchToCOPYPOP(Instruction opCode)
    {
        switch (opCode)
        {
            case Instruction.POPLOCALB:
            {
                opCode = Instruction.POPCOPYLOCALB;
            }
            case Instruction.POPLOCALB00:
            {
                opCode = Instruction.POPCOPYLOCALB00;
            }
            case Instruction.POPLOCALB02:
            {
                opCode = Instruction.POPCOPYLOCALB02;
            }
            case Instruction.POPLOCALW:
            {
                opCode = Instruction.POPCOPYLOCALW;
            }
            case Instruction.POPGLOBALB:
            {
                opCode = Instruction.POPCOPYGLOBALB;
            }
            case Instruction.POPGLOBALW:
            {
                opCode = Instruction.POPCOPYGLOBALW;
            }
            case Instruction.POPRELB:
            {
                opCode = Instruction.POPCOPYRELB;
            }
            case Instruction.POPRELW:
            {
                opCode = Instruction.POPCOPYRELW;
            }
        }
        return opCode;
    }
    
    bool OptimizeJumpW(ref < <uint> > instructions, ref uint progressInstructions)
    {
        uint iIndex = 0;
        uint instructionsLength = instructions.Length;
        bool modified = false;
        loop
        {
            if (iIndex == instructionsLength)
            {
                break;
            }
            <uint> instructionList = instructions[iIndex];
            Instruction opCode = Instruction(instructionList[0]);
            if (IsJumpWInstruction(opCode))
            {
                uint operand = instructionList[1];
                
                long offset = operand;
                if (offset > 32767)
                {
                    offset = offset - 65536; // 0x10000 -> -1
                }
                if ((offset >= -128) && (offset <= 127))
                {
                    switch (opCode)
                    {
                        case Instruction.JW:
                        {
                            instructionList.SetItem(0, uint (Instruction.JB));
                        }
                        case Instruction.JZW:
                        {
                            instructionList.SetItem(0, uint (Instruction.JZB));
                        }
                        case Instruction.JNZW:
                        {
                            instructionList.SetItem(0, uint (Instruction.JNZB));
                        }
                    }
                    instructions.SetItem(iIndex, instructionList);
                    modified = true;
                }
            }
            iIndex++;
            progressInstructions++;
            if ((progressInstructions % progressSteps) == 0)
            {
                Parser.ProgressTick(".");
            }
        }
        return modified;
    }
    bool OptimizeRemoveNOP(ref < <uint> > instructions, ref <uint,string> indexDebugInfo, ref uint progressInstructions)
    {
        uint iIndex = 0;
        bool modified = false;
        loop
        {
            if (iIndex >= instructions.Length)
            {
                break;
            }
            <uint> instructionList = instructions[iIndex];
            Instruction opCode = Instruction(instructionList[0]);
            bool removeSingleNOP = false;
            if (opCode == Instruction.NOP)
            {
                removeSingleNOP = true;
            }
            else if ((opCode == Instruction.JB) || (opCode == Instruction.JW))
            {
                uint iJumpTarget = instructionList[2];
                if (iJumpTarget == iIndex + 1)
                {
                    removeSingleNOP = true;
                }
            }
            if (removeSingleNOP)
            {
                RemoveInstruction(ref instructions, ref indexDebugInfo, iIndex);
                modified = true;
            }
            iIndex++;
            progressInstructions++;
            if ((progressInstructions % progressSteps) == 0)
            {
                Parser.ProgressTick(".");
            }
        }
        return modified;
    }
    WalkCode(ref < <uint> > instructions, ref <bool> instructionsReached, uint iIndex)
    {
        uint length = instructions.Length;
        loop
        {
            if (iIndex > length)
            {
                break;
            }
            if (instructionsReached[iIndex])
            {
                break;
            }
            instructionsReached.SetItem(iIndex, true);
            <uint> instructionList = instructions[iIndex];
            Instruction opCode = Instruction(instructionList[0]);
            if (IsConditionalJumpInstruction(opCode))
            {
                // conditional branch: explore both paths
                uint iJumpTarget = instructionList[2];
                WalkCode(ref instructions, ref instructionsReached, iJumpTarget);
                // fall through and continue on the non-branch path ..
            }
            else if ((opCode == Instruction.JW) || (opCode == Instruction.JB))
            {
                // unconditional branch: continue on the branch path only
                iIndex = instructionList[2];
                continue;
            }
            else if (IsMethodExitInstruction(opCode))
            {
                break; // end of this path
            }
            iIndex++;
        }
    }
    bool OptimizeRemoveDeadCode(ref < <uint> >  instructions, ref <uint,string> indexDebugInfo, ref uint progressInstructions)
    {
        bool modified = false;
        
        <bool> instructionsReached;
        uint length = instructions.Length;
        for (uint i=0; i < length; i++)
        {
            instructionsReached.Append(false);
        }
        WalkCode(ref instructions, ref instructionsReached, 0);
        
        uint iIndex = 0;
        loop
        {
            if (iIndex >= instructions.Length)
            {
                break;
            }
            if (!instructionsReached[iIndex])
            {
                RemoveInstruction(ref instructions, ref indexDebugInfo, iIndex);
                instructionsReached.Remove(iIndex);
                modified = true;
            }
            iIndex++;
        }
        return modified;
    }
    
    bool OptimizeCOPYPOP(ref < <uint> > instructions, ref <uint,string> indexDebugInfo, ref uint progressInstructions)
    {
        bool modified = false;   
        uint iIndex = 1; // start at 2nd instruction
        bool first = true;
        loop
        {
            if (iIndex >= instructions.Length)
            {
                break;
            }
            <uint> instructionList = instructions[iIndex-1];
            Instruction opCode = Instruction(instructionList[0]);
            
            if (opCode == Instruction.COPYNEXTPOP)
            {
                <uint> instructionListNext = instructions[iIndex];
                Instruction opCodeNext = Instruction(instructionListNext[0]);
                if (IsPOPInstruction(opCodeNext))
                {
                    opCodeNext = SwitchToCOPYPOP(opCodeNext);
                    uint popOperandWidth = OperandWidth(opCodeNext);
                    <uint> newInstructionList;
                    newInstructionList.Append(byte(opCodeNext));
                    if (popOperandWidth != 0)
                    {
                        newInstructionList.Append(instructionListNext[1]); // operand
                    }
                    instructions.SetItem(iIndex - 1, newInstructionList);
                    
                    RemoveInstruction(ref instructions, ref indexDebugInfo, iIndex);
                    modified = true;
                }
            }
            iIndex++;
        }
        progressInstructions++;
        if ((progressInstructions % progressSteps) == 0)
        {
            Parser.ProgressTick(".");
        }
        return modified;
    }
    bool OptimizeENTERPUSHI0(ref < <uint> > instructions, ref <uint,string> indexDebugInfo, ref uint progressInstructions)
    {
        bool modified = false;   
        uint iIndex = 1; // start at 2nd instruction
        bool first = true;
        loop
        {
            if (iIndex >= instructions.Length)
            {
                break;
            }
            <uint> instructionList = instructions[iIndex-1];
            Instruction opCode = Instruction(instructionList[0]);
            
            if ((opCode == Instruction.ENTER) || ((opCode == Instruction.ENTERB) && (instructionList[1] < 255)))
            {
                <uint> instructionListNext = instructions[iIndex];
                Instruction opCodeNext = Instruction(instructionListNext[0]);
                if (opCodeNext == Instruction.PUSHI0)
                {
                    bool reachable = false;
                    for (uint rIndex = 0; rIndex < instructions.Length; rIndex++)
                    {
                        if ((rIndex == iIndex) || (rIndex == iIndex-1))
                        {
                            // self
                        }
                        else
                        {
                            <uint> instructionListReach = instructions[rIndex];
                            Instruction opCodeReach = Instruction(instructionListReach[0]);
                            if (IsJumpInstruction(opCodeReach))
                            {
                               uint iJumpTarget = instructionListReach[2];
                               if (iJumpTarget == iIndex)
                               {
                                   reachable = true;
                                   break;
                               }
                           }
                        }
                    } // foreach
                    if (!reachable)
                    {
                        if (opCode == Instruction.ENTERB)
                        {
                            instructionList.SetItem(1, instructionList[1] + 1);
                        }
                        else
                        {
                            instructionList.SetItem(0, uint(Instruction.ENTERB));
                            instructionList.Append(1);
                        }
                        instructions.SetItem(iIndex-1, instructionList);
                        RemoveInstruction(ref instructions, ref indexDebugInfo, iIndex, true, iIndex-1);
                        modified = true;
                    }
                }
            }
            iIndex++;
        }
        progressInstructions++;
        if ((progressInstructions % progressSteps) == 0)
        {
            Parser.ProgressTick(".");
        }
        return modified;
    }
    bool OptimizeNOTJump(ref < <uint> > instructions, ref <uint,string> indexDebugInfo, ref uint progressInstructions)
    {
        bool modified = false;   
        uint iIndex = 1; // start at 2nd instruction
        bool first = true;
        loop
        {
            if (iIndex >= instructions.Length)
            {
                break;
            }
            <uint> instructionList = instructions[iIndex-1];
            Instruction opCode = Instruction(instructionList[0]);
            
            if (opCode == Instruction.BOOLNOT)
            {
                <uint> instructionListNext = instructions[iIndex];
                Instruction opCodeNext = Instruction(instructionListNext[0]);
                if (IsConditionalJumpInstruction(opCodeNext))
                {
                    bool reachable = false;
                    for (uint rIndex = 0; rIndex < instructions.Length; rIndex++)
                    {
                        if ((rIndex == iIndex) || (rIndex == iIndex-1))
                        {
                            // self
                        }
                        else
                        {
                            <uint> instructionListReach = instructions[rIndex];
                            Instruction opCodeReach = Instruction(instructionListReach[0]);
                            if (IsJumpInstruction(opCodeReach))
                            {
                               uint iJumpTarget = instructionListReach[2];
                               if (iJumpTarget == iIndex)
                               {
                                   reachable = true;
                                   break;
                               }
                           }
                        }
                    } // foreach
                    if (!reachable)
                    {
                        opCodeNext = FlipConditionalJumpCondition(opCodeNext);
                        
                        <uint> newInstructionList;
                        newInstructionList.Append(byte(opCodeNext));
                        newInstructionList.Append(instructionListNext[1]); // needs operand, value not important
                        newInstructionList.Append(instructionListNext[2]);
                        instructions.SetItem(iIndex - 1, newInstructionList);
                        
                        RemoveInstruction(ref instructions, ref indexDebugInfo, iIndex);
                        modified = true;
                    }
                }
            }
            iIndex++;
        }
        progressInstructions++;
        if ((progressInstructions % progressSteps) == 0)
        {
            Parser.ProgressTick(".");
        }
        return modified;
    }
    
    bool OptimizeZEROEQJump(ref < <uint> > instructions, ref <uint,string> indexDebugInfo, ref uint progressInstructions)
    {
        bool modified = false;   
        uint iIndex = 2; // start at 3nd instruction
        bool first = true;
        loop
        {
            if (iIndex >= instructions.Length)
            {
                break;
            }
            <uint> instructionList0 = instructions[iIndex-2];
            Instruction opCode0 = Instruction(instructionList0[0]);
            
            if (opCode0 == Instruction.PUSHI0)
            {
                <uint> instructionList1 = instructions[iIndex-1];
                Instruction opCode1 = Instruction(instructionList1[0]);
                <uint> instructionList2 = instructions[iIndex];
                Instruction opCode2 = Instruction(instructionList2[0]);
                if (((opCode1 == Instruction.EQ) || (opCode1 == Instruction.NE)) && IsConditionalJumpInstruction(opCode2))
                {
                    bool reachable = false;
                    for (uint rIndex = 0; rIndex < instructions.Length; rIndex++)
                    {
                        if ((rIndex == iIndex) || (rIndex == iIndex-1) || (rIndex == iIndex-2))
                        {
                            // self
                        }
                        else
                        {
                            <uint> instructionListReach = instructions[rIndex];
                            Instruction opCodeReach = Instruction(instructionListReach[0]);
                            if (IsJumpInstruction(opCodeReach))
                            {
                               uint iJumpTarget = instructionListReach[2];
                               if ((iJumpTarget == iIndex) || (iJumpTarget == iIndex-1))
                               {
                                   reachable = true;
                                   break;
                               }
                           }
                        }
                    } // foreach
                    if (!reachable)
                    {
                        if (opCode1 == Instruction.EQ)
                        {   
                            opCode2 = FlipConditionalJumpCondition(opCode2);
                        }
                        
                        <uint> newInstructionList;
                        newInstructionList.Append(byte(opCode2));
                        newInstructionList.Append(instructionList2[1]); // needs operand, value not important
                        newInstructionList.Append(instructionList2[2]);
                        instructions.SetItem(iIndex - 2, newInstructionList);
                        
                        RemoveInstruction(ref instructions, ref indexDebugInfo, iIndex);
                        RemoveInstruction(ref instructions, ref indexDebugInfo, iIndex-1);

                        modified = true;
                        
                    }
                }
            }
            iIndex++;
        }
        progressInstructions++;
        if ((progressInstructions % progressSteps) == 0)
        {
            Parser.ProgressTick(".");
        }
        return modified;
    }
    
    bool OptimizePUSHPUSHSWAP(ref < <uint> > instructions, ref <uint,string> indexDebugInfo, ref uint progressInstructions)
    {
        bool modified = false;   
        uint iIndex = 2; // start at 3nd instruction
        bool first = true;
        loop
        {
            if (iIndex >= instructions.Length)
            {
                break;
            }
            <uint> instructionList0 = instructions[iIndex-2];
            <uint> instructionList1 = instructions[iIndex-1];
            <uint> instructionList2 = instructions[iIndex];
            Instruction opCode0 = Instruction(instructionList0[0]);
            Instruction opCode1 = Instruction(instructionList1[0]);
            Instruction opCode2 = Instruction(instructionList2[0]);
            bool pushPushSwap = (IsPUSHInstruction(opCode0) && IsPUSHInstruction(opCode1) && (opCode2 == Instruction.SWAP));
            bool push0EQJ     = ((opCode0 == Instruction.PUSHI0) && (opCode1 == Instruction.EQ) && IsConditionalJumpInstruction(opCode2));
            if (pushPushSwap || push0EQJ)
            {
                bool reachable = false;
                for (uint rIndex = 0; rIndex < instructions.Length; rIndex++)
                {
                    if ((rIndex == iIndex) || (rIndex == iIndex-1))
                    {
                        // self
                    }
                    else
                    {
                        <uint> instructionListReach = instructions[rIndex];
                        Instruction opCodeReach = Instruction(instructionListReach[0]);
                        if (IsJumpInstruction(opCodeReach))
                        {
                            uint iJumpTarget = instructionListReach[2];
                            if ((iJumpTarget == iIndex) || (iIndex == iIndex-1))
                            {
                                reachable = true;
                                break;
                            }
                        }
                    }
                } // foreach
                if (!reachable)
                {
                    if (pushPushSwap)
                    {
                        instructions.SetItem(iIndex-2, instructionList1);
                        instructions.SetItem(iIndex-1, instructionList0);
                        
                        RemoveInstruction(ref instructions, ref indexDebugInfo, iIndex);
                        modified = true;
                    }
                    if (false && push0EQJ) // TODO
                    {
                        opCode2 =  FlipConditionalJumpCondition(opCode2);
                        instructionList2.SetItem(0, opCode2);
                        instructions.SetItem(iIndex-2, instructionList2);
                        RemoveInstruction(ref instructions, ref indexDebugInfo, iIndex);
                        RemoveInstruction(ref instructions, ref indexDebugInfo, iIndex-1);
                        modified = true;
                    }
                }
            }
            iIndex++;
        }
        progressInstructions++;
        if ((progressInstructions % progressSteps) == 0)
        {
            Parser.ProgressTick(".");
        }
        return modified;
    }
    
    bool OptimizeJumpFollowedByJump(ref < <uint> > instructions, ref <uint,string> indexDebugInfo, ref uint progressInstructions)
    {
        bool modified = false;   
        uint iIndex = 1; // start at 2nd instruction
        bool first = true;
        loop
        {
            if (iIndex >= instructions.Length)
            {
                break;
            }
            <uint> instructionList = instructions[iIndex-1];
            Instruction opCode = Instruction(instructionList[0]);
            if (IsConditionalJumpInstruction(opCode))
            {
                uint iConditionalJumpTarget = instructionList[2];
                <uint> instructionListNext = instructions[iIndex];
                Instruction opCodeNext = Instruction(instructionListNext[0]);
                if ((iConditionalJumpTarget == iIndex+1) && ((opCodeNext == Instruction.JB) || (opCodeNext == Instruction.JW)))
                {
                    bool reachable = false;
                    for (uint rIndex = 0; rIndex < instructions.Length; rIndex++)
                    {
                        if ((rIndex == iIndex) || (rIndex == iIndex-1))
                        {
                            // self
                        }
                        else
                        {
                            <uint> instructionListReach = instructions[rIndex];
                            Instruction opCodeReach = Instruction(instructionListReach[0]);
                            if (IsJumpInstruction(opCodeReach))
                            {
                                uint iJumpTarget = instructionListReach[2];
                                if ((iJumpTarget == iIndex) || (iIndex == iIndex-1))
                                {
                                    reachable = true;
                                    break;
                                }
                            }
                        }
                    } // foreach
                    if (!reachable)
                    {
                        // check range for iIndex-1 if JNZB or JZB (change to JZW or JNZW?)
                        uint iJumpTarget = instructionListNext[2];
                        uint fromAddress = GetInstructionAddress(iIndex-1, ref instructions);
                        uint toAddress   = GetInstructionAddress(iJumpTarget, ref instructions);
                        int offset = int(toAddress) - int(fromAddress);
                        if ((opCode == Instruction.JZB) || (opCode == Instruction.JNZB))
                        {
                            if ((offset < -128) || (offset > 127))
                            {
                                if (opCode == Instruction.JZB)
                                {
                                    opCode = Instruction.JZW;
                                }
                                else if (opCode == Instruction.JNZB)
                                {
                                    opCode = Instruction.JNZW;
                                }
                            }
                        }
                        opCode = FlipConditionalJumpCondition(opCode);
                        
                        instructionListNext.SetItem(0, byte(opCode));
                        instructionListNext.SetItem(2, iJumpTarget);
                        instructions.SetItem(iIndex-1, instructionListNext);
                    
                        RemoveInstruction(ref instructions, ref indexDebugInfo, iIndex);
                        modified = true;
                    }
                }
            }
            iIndex++;
        }
        progressInstructions++;
        if ((progressInstructions % progressSteps) == 0)
        {
            Parser.ProgressTick(".");
        }
        return modified;
    }
    
    bool OptimizeJumpToJump(ref < <uint> > instructions, ref <uint,string> indexDebugInfo, ref uint progressInstructions)
    {
        bool modified = false;
        uint iIndex = 0;
        bool first = true;
        loop
        {
            if (iIndex >= instructions.Length)
            {
                break;
            }
            <uint> instructionList = instructions[iIndex];
            Instruction opCode = Instruction(instructionList[0]);
            bool removeSingleNOP = false;
            if (IsJumpInstruction(opCode))
            {
                uint iJumpTarget = instructionList[2];
                <uint> targetInstructionList = instructions[iJumpTarget];
                Instruction targetOpCode = Instruction(targetInstructionList[0]);
                
                if (IsUnconditionalJumpInstruction(targetOpCode))
                {
                    // set target to jump past the unconditional jump target
                    uint iTargetJumpTarget = targetInstructionList[2];
                    uint fromAddress = GetInstructionAddress(iIndex, ref instructions);
                    uint toAddress   = GetInstructionAddress(iTargetJumpTarget, ref instructions);
                    int offset = int(toAddress) - int(fromAddress);
                    if (IsJumpBInstruction(opCode))
                    {
                        if ((offset >= -128) && (offset < 127))
                        {
                            // safe B cases
                            instructionList.SetItem(2, iTargetJumpTarget);
                            instructions.SetItem(iIndex, instructionList);
                            modified = true;
                        }
                        else
                        {
                            // inserting code is harder than it may first appear (knock-on effects ..)
                        }
                    }
                    else
                    {
                        // W cases
                        instructionList.SetItem(2, iTargetJumpTarget);
                        instructions.SetItem(iIndex, instructionList);
                        modified = true;
                    }
                }
                else if (IsUnconditionalJumpInstruction(opCode) && IsMethodExitInstruction(targetOpCode))
                {
                    // JB or JW -> RETx  becomes RETx
                    uint jumpOperandWidth   = OperandWidth(opCode);
                    uint targetOperandWidth = OperandWidth(targetOpCode);
                    if (targetOperandWidth <= jumpOperandWidth) // inserting code is harder than it may first appear (knock-on effects ..)
                    {
                        // OperandWidth = 0:
                        //     Instruction.RET0
                        // OperandWidth = 1:
                        //     Instruction.DIE
                        //     Instruction.RETB
                        //     Instruction.RETRETB
                        // OperandWidth = 2
                        //     Instruction.RETW
                        //     Instruction.RETRETW
                        <uint> exitInstructionList;
                        exitInstructionList.Append(targetInstructionList[0]);
                        if (targetOpCode != Instruction.RET0)
                        {
                            exitInstructionList.Append(targetInstructionList[1]);
                        }
                        instructions.SetItem(iIndex, exitInstructionList);
                        modified = true;
                    }
                }
            }
            iIndex++;
            progressInstructions++;
            if ((progressInstructions % progressSteps) == 0)
            {
                Parser.ProgressTick(".");
            }
        } // loop
        return modified;
    }
    
    Optimize(ref uint codeBefore, ref uint codeAfter)
    {
        <uint> indices = Code.GetMethodIndices();
        
        
        uint progressInstructions;
        foreach (var methodIndex in indices)
        {
            //if (methodIndex != 0x0020)
            //if (methodIndex != 0x0087)
            //if (methodIndex != 0x0001)
            //{
            //    continue;
            //}
            //string name = Code.GetMethodName(methodIndex);
            

            // convert from '<byte> code' to '< <uint > > instructions'
            <byte> code = Code.GetMethodCode(methodIndex);
            < <uint> > instructions;
            uint codeLength = code.Length;
            codeBefore = codeBefore + codeLength;
            byte operandWidth;
            uint i = 0;
            loop
            {
                Instruction opCode = Instruction(code[i]);
                operandWidth = Instructions.OperandWidth(opCode);
                
                <uint> instructionList;
                instructionList.Append(code[i]);
                
                i++;
                if (operandWidth == 1)
                {
                    instructionList.Append(code[i]);
                    i++;
                }
                if (operandWidth == 2)
                {
                    uint lsb = code[i];
                    i++;
                    uint msb = code[i];
                    i++;
                    uint operand = lsb + (msb << 8);
                    instructionList.Append(operand);
                }
                instructions.Append(instructionList);
                if (i == codeLength)
                {
                    break;
                }
                progressInstructions++;
                if ((progressInstructions % progressSteps) == 0)
                {
                    Parser.ProgressTick(".");
                }
            } // loop
            
            uint instructionsLength = instructions.Length;
            
            // set the jumps to point to instruction indexes (rather than addresses)
            uint iIndex = 0;
            loop
            {
                if (iIndex == instructionsLength)
                {
                    break;
                }
                <uint> instructionList = instructions[iIndex];
                Instruction opCode = Instruction(instructionList[0]);
                byte operandWidth = Instructions.OperandWidth(opCode);
                long offset;
                uint address = GetInstructionAddress(iIndex, ref instructions);
                long jumpTarget;
                if (Instructions.OperandIsAddressOffset(opCode))
                {
                    if (operandWidth == 1)
                    {
                        offset = instructionList[1];
                        if (offset > 127)
                        {
                            offset = offset - 256; // 255 -> -1
                        }
                        jumpTarget = long(address) + offset;
                    }
                    else
                    {
                        // operandWidth == 2
                        uint operand = instructionList[1];
                        offset = operand;
                        if (offset > 32767)
                        {
                            offset = offset - 65536; // 0x10000 -> -1
                        }
                        jumpTarget = long(address) + offset;
                    }
                }
                if (jumpTarget != 0)
                {
                    uint jumpIndex = GetInstructionIndex(jumpTarget, ref instructions);
                    instructionList.Append(jumpIndex);
                    instructions.SetItem(iIndex, instructionList);
                }
                
                iIndex++;
                progressInstructions++;
                if ((progressInstructions % progressSteps) == 0)
                {
                    Parser.ProgressTick(".");
                }
            } // loop iIndex
            
            // convert the debugInfo from instruction addresses to instruction indices
            <string,string> debugInfo = GetMethodDebugInfo(methodIndex);
            <uint,string> indexDebugInfo;
            foreach (var kv in debugInfo)
            {
                string saddress = kv.key;
                uint address;
                if (UInt.TryParse(saddress, ref address))
                {
                }
                uint index = GetInstructionIndex(address, ref instructions);
                indexDebugInfo[index] = kv.value;
            }
            loop
            {
                bool modified;
                
                // if the operand would fit in a byte, switch to the W to the B variant
                modified = OptimizeJumpW(ref instructions, ref progressInstructions);
                
                // not just NOP, also JMP -> JMP + 1, can cause more short JumpToJump's to work
                modified = modified || OptimizeRemoveNOP(ref instructions, ref indexDebugInfo, ref progressInstructions);
                
                // COPYNEXTPOP POPX -> POPCOPYX
                modified = modified || OptimizeCOPYPOP(ref instructions, ref indexDebugInfo, ref progressInstructions);  
                
                // ENTER|ENTERN PUSHI0 -> ENTERN <n>
                modified = modified || OptimizeENTERPUSHI0(ref instructions, ref indexDebugInfo, ref progressInstructions);  
                
                // NOT JZ -> JNZ and NOT JNZ -> JZ
                modified = modified || OptimizeNOTJump(ref instructions, ref indexDebugInfo, ref progressInstructions);
                
                // PUSHI0 EQ JNZ -> JZ  and  PUSHI0 EQ JZ -> JNZ
                modified = modified || OptimizeZEROEQJump(ref instructions, ref indexDebugInfo, ref progressInstructions);
                
                // PUSHxxx PUSHyyy SWAP -> PUSHyyy PUSHxxx
                modified = modified || OptimizePUSHPUSHSWAP(ref instructions, ref indexDebugInfo, ref progressInstructions);
                
                // remove jumps to unconditional jumps, can cause more dead code to appear
                modified = modified || OptimizeJumpToJump(ref instructions, ref indexDebugInfo, ref progressInstructions);
                
                // walk/mark and sweep for dead code removal, can cause more short JumpToJump's to work
                modified = modified || OptimizeRemoveDeadCode(ref instructions, ref indexDebugInfo, ref progressInstructions);
                
                modified = modified ||  OptimizeJumpFollowedByJump(ref instructions, ref indexDebugInfo, ref progressInstructions);
                if (!modified)
                {
                    break; // no more changes
                }
            }
            
            // convert from '< <uint > > instructions' back to '<byte> code'
            code.Clear();
            instructionsLength = instructions.Length;
            iIndex = 0;
            loop
            {
                if (iIndex == instructionsLength)
                {
                    break;
                }
                uint currentAddress = code.Length;
                < uint > instructionList = instructions[iIndex];
                Instruction opCode = Instruction(instructionList[0]);
                byte operandWidth = Instructions.OperandWidth(opCode);
                code.Append(instructionList[0]);
                if (operandWidth > 0)
                {
                    uint operand = instructionList[1];
                    if (Instructions.OperandIsAddressOffset(opCode))
                    {
                        // use the index to calculate the new offset
                        uint iIndex = instructionList[2];
                        long jumpAddress    = GetInstructionAddress(iIndex, ref instructions);
                        //PrintLn("0x" + jumpAddress.ToHexString(4) + " 0x" + currentAddress.ToHexString(4));
                        long offset = jumpAddress - currentAddress;
                        if (offset < 0)
                        {
                            if (operandWidth == 1)
                            {
                                if ((offset < -128) || (offset > 127))
                                {
                                    PrintLn("Bad Jump:  " + offset.ToString());
                                }
                                offset = offset + 256;
                            }
                            else
                            {
                                offset = offset + 65536;
                            }
                        }
                        operand = uint(offset);
                    }
                    byte lsb = byte(operand & 0xFF);
                    code.Append(lsb);
                    if (operandWidth > 1)
                    {
                        byte msb = byte(operand >> 8);
                        code.Append(msb);
                    }
                }
                iIndex++;
                progressInstructions++;
                if ((progressInstructions % progressSteps) == 0)
                {
                    Parser.ProgressTick(".");
                }
            } // loop // convert from '< <uint > > instructions' back to '<byte> code'
            
            // convert the indexDebugInfo back from instruction indices to instruction addresses
            debugInfo.Clear();
            foreach (var kv in indexDebugInfo)
            {
                uint iIndex = kv.key;
                uint address = GetInstructionAddress(iIndex, ref instructions);
                debugInfo[address.ToString()] = kv.value;
            }

            // update the method with the optimized code            
            Code.SetMethodCode(methodIndex, code);
            Code.SetMethodDebugInfo(methodIndex, debugInfo);
            
            codeAfter = codeAfter + code.Length;
            
        } // foreach methodIndex
    }
    
    BadArguments()
    {
        PrintLn("Invalid arguments for Optimize:");
        PrintLn("  OPTIMIZE <code file>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
    }
    
    {
        uint codeBefore; 
        uint codeAfter;
        loop
        {
            bool doIHex = false;
            <string> rawArgs = System.Arguments;
            <string> args;
            for (uint iArg = 0; iArg < rawArgs.Length; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length >= 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Length != 1)
            {
                BadArguments();
                break;
            }
            string codePath = args[0];
            
            string ext = ".code";
            string codePath = args[0];
            if (!File.Exists(ref codePath, ref ext, "/Debug/Obj/"))
            {
                BadArguments();
            }
            
            long startTime = Millis;
            loop
            {
                string extension = Path.GetExtension(codePath);
                if (!Code.ParseCode(codePath, true, true, false))
                {
                    break;
                }
                string symbolsPath = codePath.Replace(extension, ".json");
                if (File.Exists(symbolsPath))
                {
                    if (JSON.Read(symbolsPath, ref symbols))
                    {
                        CheckTarget();
                    }
                }
                
                Optimize(ref codeBefore, ref codeAfter);
                
                // after
                File.Delete(codePath);
                if (!Code.ExportCode(codePath, false)) // after
                {
                    break;
                }
                
                if (!Parser.IsInteractive())
                {
                    PrintLn();
                    Print("Success, " + codeBefore.ToString() + "->" + codeAfter.ToString() + " code bytes.", Color.ProgressText, Color.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() + "s", Color.ProgressHighlight, Color.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                
                // compare before and after
#ifdef UNUSED                
                file cFile = File.Open(codePath);
                file oFile = File.Open(optPath);
                long pos = 0;
                loop
                {
                    if (!cFile.IsValid())
                    {
                        if (oFile.IsValid())
                        {
                            PrintLn(".opt file has more content!");
                        }
                        break;
                    }
                    if (!oFile.IsValid())
                    {
                        PrintLn(".opt file has less content!");
                    }
                    byte c = cFile.Read();
                    byte o = oFile.Read();
                    if (c != o)
                    {
                        PrintLn("First difference at position " + pos.ToString());
                        PrintLn("  c=0x" + c.ToHexString(2));
                        PrintLn("  o=0x" + o.ToHexString(2));
                        break;
                    }
                    pos++;
                }
#endif
                break;
            }
            break;
        } // loop
    } // main
}
