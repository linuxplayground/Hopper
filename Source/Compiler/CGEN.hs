program CODEGEN
{

#define JSONEXPRESS // .code and .json are generated by us so assume .json files have no errors
#define INLINED
    
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    
    uses "/Source/Compiler/JSON/JSON"
    uses "/Source/Compiler/JSON/Code"
    
    uses "/Source/Compiler/CodeGen/Instructions"
    
    uses "/Source/Compiler/Tokens/Token"
    uses "/Source/Compiler/Tokens/Scanner"
    uses "/Source/Compiler/Tokens/Parser"
    uses "/Source/Compiler/Tokens/SysCalls"
    uses "/Source/Compiler/Types"
    
    string pathLoaded;
    <string> sourceLines;
    string GetSourceLine(string path, string lnum)
    {
        if (pathLoaded != path)
        {
            file sourceFile = File.Open(path);
            if (sourceFile.IsValid())
            {
                sourceLines.Clear();
                pathLoaded = path;
                loop
                {
                    string ln = sourceFile.ReadLine();
                    if (ln.Length == 0)
                    {
                        if (!sourceFile.IsValid())
                        {
                            break;
                        }
                    }
                    sourceLines.Append(ln);
                }
            }
        }
        string sourceLine;
        uint iline;
        if (UInt.TryParse(lnum, ref iline))
        {
            if (iline > 0)
            {
                iline--;
            }
            if (sourceLines.Length > iline)
            {
                sourceLine = sourceLines[iline];
            }
        }
        return sourceLine;
    }
    
    BadArguments()
    {
        PrintLn("Invalid arguments for CGEN:");
        PrintLn("  CGEN <code file>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
    }
    {
        bool success = false;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            for (uint iArg = 0; iArg < rawArgs.Length; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length >= 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Length != 1)
            {
                BadArguments();
                break;
            }
            string ext = ".code";
            string codePath = args[0];
            if (!File.Exists(ref codePath, ref ext, "/Debug/Obj/"))
            {
                BadArguments();
            }
            
            long startTime = Millis;
            loop
            {
                string extension = Path.GetExtension(codePath);
                string cPath  = codePath.Replace(extension, ".cpp");
                
                cPath = Path.GetFileName(cPath);
                cPath = Path.Combine("/Bin/", cPath);
                File.Delete(cPath);

                file cFile = File.Create(cPath);
                if (!cFile.IsValid())
                {
                    PrintLn("Failed to create '" + cPath + "'");
                    break;
                }
                
                if (!ParseCode(codePath, true, true))
                {
                    break;
                }
                SysCalls.New();
                string eol = "" + char(0x0A);

                cFile.Append("#include " + '"' + "Platform.h" + '"' + eol);
                cFile.Append("#include " + '"' + "Machine.h" + '"' + eol);
                cFile.Append(eol);
                
                // constant data for string literals (always empty?)
                <byte> constantData = Code.GetConstantData();
                cFile.Append("const Byte constantData[] = {" + eol);
                uint count = 0;
                foreach (var b in constantData)
                {
                    count++;
                    cFile.Append("0x" + b.ToHexString(2) + ", ");
                    if (count % 32 == 0)
                    {
                        cFile.Append(eol);
                    }
                }
                if (constantData.Length == 0)
                {
                    cFile.Append("0x00 ");
                }
                cFile.Append("    };" + eol);
                cFile.Append(eol);
                
                Parser.ProgressTick(".");
                
                // forward declarations for methods and functions
                <uint, string> resolvedMethodNames;
                <uint, string> externalMethods;
                <uint, uint> methodSizes = Code.GetMethodSizes();
                foreach (var kv in methodSizes)
                {  
                    uint methodIndex = kv.key;
                    string name = Code.GetMethodName(methodIndex).Replace('.', '_');
                    
                    string nameUnique = name;
                    if (!name.Contains("_New"))
                    {
                        nameUnique = nameUnique + "_0x" + methodIndex.ToHexString(4);
                    }
                    resolvedMethodNames[methodIndex] = nameUnique;
                    if (name.StartsWith("External_"))
                    {
                        externalMethods[methodIndex] = name;
                        continue;
                    }
                    switch (name)
                    {
                        case "IO_Read":
                        case "IO_IsBreak":
                        {
                            //externalMethods[methodIndex] = name;
                            //continue;
                        }
                    }
                    cFile.Append("void " + nameUnique + "();" + eol);
                }
                
                uint entryIndex = Code.GetEntryIndex();
                string mainName = Code.GetMethodName(entryIndex).Replace('.', '_');
                cFile.Append(eol);
                cFile.Append("void HopperEntryPoint()" + eol);
                cFile.Append("{" + eol);
                cFile.Append("    PushBP(); // place holder push for final return"+ eol);
                cFile.Append("    " + mainName + "_0x" + entryIndex.ToHexString(4)  + "();"+ eol);
                cFile.Append("}" + eol);
                
                foreach (var kv in methodSizes)
                {  
                    uint methodIndex = kv.key;
                    string name = Code.GetMethodName(methodIndex).Replace('.', '_');
                    
                    if (externalMethods.Contains(methodIndex))
                    {
                        continue;
                    }
                    
                    cFile.Append(eol);
                    
                    string nameUnique = name;
                    if (!name.Contains("_New"))
                    {
                        nameUnique = nameUnique + "_0x" + methodIndex.ToHexString(4);
                    }
                    
                    cFile.Append("void " + nameUnique  + "()" + eol);
                    cFile.Append("{" + eol);
                    
                    <uint> jumpTargets;
                    <uint> jixLabels;
                    
                    <byte> methodCode = Code.GetMethodCode(methodIndex);
                    uint codeLength = methodCode.Length;
                    uint pc = 0;
                    
                    // find all jump targets
                    bool needNext;
                    bool needTop;
                    bool needNexti;
                    bool needTopi;
                    bool neetHType;
                    loop
                    {
                        if (pc == codeLength)
                        {
                            break;
                        }
                        uint operand;
                        uint nextPC = pc;
                        
                        Instruction opCode = GetOperandAndNextAddress(methodCode, ref nextPC, ref operand);
                        string dasm = Instructions.Disassemble(methodCode, ref pc, 0, ref jumpTargets, ref jixLabels, true);
                        
                        switch (opCode)
                        {
                            case Instruction.EQ:
                            case Instruction.NE:
                            case Instruction.LT:
                            case Instruction.LE:
                            case Instruction.GT:
                            case Instruction.GE:
                            case Instruction.ADD:
                            case Instruction.SUB:
                            case Instruction.MUL:
                            case Instruction.DIV:
                            case Instruction.MOD:
                            case Instruction.BOOLAND:
                            case Instruction.BOOLOR:
                            case Instruction.BITAND:
                            case Instruction.BITOR:
                            case Instruction.BITXOR:
                            case Instruction.BITSHL:
                            case Instruction.BITSHR:
                            case Instruction.PUSHIWLE:
                            case Instruction.PUSHIWLT:
                            {
                                needTop  = true;
                                needNext = true;
                            }
                            
                            case Instruction.BOOLNOT:
                            case Instruction.BITNOT:
                            {
                                needTop  = true;
                            }
                            
                            case Instruction.ADDI:
                            case Instruction.SUBI:
                            case Instruction.MULI:
                            case Instruction.DIVI:
                            case Instruction.MODI:
                            case Instruction.LTI:
                            case Instruction.LEI:
                            case Instruction.GTI:
                            case Instruction.GEI:
                            case Instruction.PUSHIWLEI:
                            {
                                needTopi  = true;
                                needNexti = true;
                            }
                            case Instruction.PUSHLOCALB:
                            case Instruction.PUSHLOCALB00:
                            case Instruction.PUSHLOCALB02:
                            case Instruction.PUSHLOCALBB:
                            case Instruction.POPLOCALB:
                            case Instruction.POPLOCALB00:
                            case Instruction.POPLOCALB02:
                            case Instruction.PUSHGLOBALB:
                            case Instruction.PUSHGLOBALBB:
                            case Instruction.POPGLOBALB:
                            case Instruction.RETRETB:
                            case Instruction.DUP:
                            case Instruction.PUSHRELB:
                            case Instruction.POPRELB:
                            case Instruction.INCLOCALB:
                            case Instruction.INCGLOBALB:
                            {
                                neetHType = true;
                            }
                        }
                        
                        pc = nextPC;
                    } // first pass
//#ifndef INLINED
                    if (needTop)
                    {
                        cFile.Append("    UInt top   = 0;" + eol);
                    }
                    if (needNext)
                    {
                        cFile.Append("    UInt next  = 0;" + eol);
                    }
                    if (needTopi)
                    {
                        cFile.Append("    Int topi   = 0;" + eol);
                    }
                    if (needNexti)
                    {
                        cFile.Append("    Int nexti  = 0;" + eol);
                    }
//#endif                    
                    if (neetHType)
                    {
                        cFile.Append("    Type htype = Type::tNone;" + eol);
                    }
                    if (needTop || needNext || needTopi || needNexti || neetHType)
                    {
                        cFile.Append(eol);
                    }

                    string srcPath;
                    string srcName;
                    <string,string> debugInfo;
                    <string,variant> methodSymbols = Code.GetMethodSymbols(methodIndex);
                    if (methodSymbols.Count > 0)
                    {
                        srcPath = methodSymbols["source"];
                        srcName = Path.GetFileName(srcPath);
                        debugInfo = methodSymbols["debug"];
                    }
                    
                    // second pass
                    string labelName = Code.GetMethodName(methodIndex).Replace('.', '_');
                    labelName = labelName[0].ToLower() + labelName.Substring(1);
                    pc = 0;
                    loop
                    {
                        if (pc == codeLength)
                        {
                            break;
                        }
                        string pcStr = pc.ToString();
                        if (debugInfo.Contains(pcStr))
                        {
                            string dln = debugInfo[pcStr];
                            cFile.Append("" + char(0x0A)); 
                            string sourceLine = GetSourceLine(srcPath, dln);
                            if (sourceLine.Length > 0)
                            {
                                string commentStart;
                                commentStart = "    //";
                                sourceLine = commentStart + " " + sourceLine.Trim();
                                if (sourceLine.Length < 70)
                                {
                                    sourceLine = sourceLine.Pad(' ', 80);
                                    sourceLine = sourceLine + srcName + ":" + dln;
                                }
                                cFile.Append(sourceLine + char(0x0A));  
                            }
                            else
                            {
                                cFile.Append("    // " + srcName + ":" + dln + char(0x0A));  
                            }
                            cFile.Append("    // " + char(0x0A));  
                        }
                        
                        uint operand;
                        uint nextPC = pc;
                        string content;
                        if (jumpTargets.Contains(pc) || (jixLabels.Contains(pc) && (pc != 0)))
                        {
                            content = labelName + "_0x" + pc.ToHexString(4) + ":";
                            cFile.Append(content + eol);        
                        }
                        
                        content = "";
                        string extraContent;
                        Instruction opCode = GetOperandAndNextAddress(methodCode, ref nextPC, ref operand);
                        <uint> currentTargets;
                        <uint> currentJixLabels;
                        string dasm = Instructions.Disassemble(methodCode, ref pc, 0, ref currentTargets, ref currentJixLabels, true);
                        
                        switch(opCode)
                        {
                            case Instruction.NOP:
                            {
                                content = "    ;";
                            }
                            
                            case Instruction.JW:
                            case Instruction.JB:
                            {
                                content = "    goto " + labelName + "_0x" + currentTargets[0].ToHexString(4) + ";";
                            }
                            case Instruction.JZW:
                            case Instruction.JZB:
                            {
#ifdef UNUSED
                                content = "    sp--; if (valuestack[sp] == 0) { goto " + labelName + "_0x" + currentTargets[0].ToHexString(4) + "; }";
#else
                                content = "    if (PopStack() == 0) { goto " + labelName + "_0x" + currentTargets[0].ToHexString(4) + "; }";
#endif
                            }
                            case Instruction.JNZW:
                            case Instruction.JNZB:
                            {
#ifdef UNUSED
                                content = "    sp--; if (valuestack[sp]) { goto " + labelName + "_0x" + currentTargets[0].ToHexString(4) + "; }";
#else
                                content = "    if (PopStack() != 0) { goto " + labelName + "_0x" + currentTargets[0].ToHexString(4) + "; }";
#endif                                
                            }
                            
                            case Instruction.JIXB:
                            case Instruction.JIXW:
                            {
#ifdef UNUSED
                                content      =                "    sp--; switch(valuestack[sp])";
#else
                                content      =                "    switch(PopStack())";
#endif
                                extraContent = "";
                                extraContent = extraContent + "    {" + eol;
                                
                                uint switchCase = (operand & 0xFF);
                                foreach (var label in currentJixLabels)
                                {
                                    if (label != 0)
                                    {
                                        extraContent = extraContent + "        case 0x" + switchCase.ToHexString(2) 
                                                                    + ": { goto " + labelName + "_0x" + label.ToHexString(4) + "; }" + eol;
                                    }
                                    switchCase++;
                                }
                                
                                
                                extraContent = extraContent + "    }" + eol;
                            }
                            
                            
                            case Instruction.CALLW:
                            case Instruction.CALLB:
                            {
                                if (externalMethods.Contains(operand))
                                {
                                    content = "    " + externalMethods[operand] + "();";
                                }
                                else
                                {
                                    content = "    " + resolvedMethodNames[operand] + "();";
                                }
                            }
                            case Instruction.SYSCALL0:
                            {
#ifdef INLINED
                                switch (operand)
                                {
                                    case 0xA9: // Memory.ReadByte
                                    {
                                        content = "    valuestack[sp-1] = memoryBlock[valuestack[sp-1]]; typestack [sp-1] = Type::tByte;";
                                    }
                                    case 0xAA: // Memory.WriteByte
                                    {
                                        content = "    sp--; sp--; memoryBlock[valuestack[sp]] = (Byte)valuestack[sp+1];";
                                    }
                                    
                                    //case 0xC6: // Time.Delay
                                    //{
                                    //    content = "    sp--; delay(valuestack[sp]);";
                                    //}
                                    case 0xD7: // Memory.ReadWord
                                    {
                                        content = "    valuestack[sp-1] = (memoryBlock[valuestack[sp-1]] + (memoryBlock[valuestack[sp-1]+1] << 8)); typestack [sp-1] = Type::tUInt;";
                                    }
                                    case 0xD8: // Memory.WriteWord
                                    {
                                        content = "    sp--; sp--; memoryBlock[valuestack[sp]] = (Byte)(valuestack[sp+1] & 0xFF); memoryBlock[valuestack[sp]+1] = (Byte)(valuestack[sp+1] >> 8);";
                                    }
                                    
                                    case 0x37:  // UInt.ToInt
                                    {
                                        content = "    typestack [sp-1] = Type::tInt;";
                                    }
                                    default:
                                    {
                                        string syscallName = SysCalls.GetSysCallName(byte(operand));
                                        syscallName = syscallName.Replace('.', '_');
                                        content = "    " + syscallName + "(0);";
                                    }
                                }
#else                               
                                switch (operand)
                                {
                                    case 0x37:  // UInt.ToInt
                                    {
                                        content = "    External_UIntToInt();";
                                    }
                                    default:
                                    { 
                                        string syscallName = SysCalls.GetSysCallName(byte(operand));
                                        syscallName = syscallName.Replace('.', '_');
                                        content = "    " + syscallName + "(0);";
                                    }
                                }
#endif
                            }
                            case Instruction.SYSCALL1:
                            {
                                string syscallName = SysCalls.GetSysCallName(byte(operand));
                                syscallName = syscallName.Replace('.', '_');
                                content = "    " + syscallName + "(1);";
                            }
                            case Instruction.SYSCALL:
                            {
                                string syscallName = SysCalls.GetSysCallName(byte(operand));
                                syscallName = syscallName.Replace('.', '_');
                                content = "    " + syscallName + "(PopStack());";
                            }
                            case Instruction.ENTER:
                            {
#ifdef UNUSED
                                content = "    callstack[csp] = bp;bp = sp;csp++;";
#else                                
                                content = "    PushBP();";
#endif
                            }
                            case Instruction.RET0:
                            {
#ifdef UNUSED
                                content = "    csp--; bp = callstack[csp];";
#else                                
                                content = "    PopBP();";
#endif
                                extraContent = extraContent + "    return;" + eol;
                            }
                            case Instruction.RETFAST:
                            {
                                content = "    return;";
                            }
                            case Instruction.RETB:
                            {
                                operand = operand / 2;
#ifdef UNUSED
                                content = "    sp = sp -" + operand.ToString() + "; csp--; bp = callstack[csp];";
                                extraContent = extraContent + "    return;" + eol;
#else                                
                                content = "    DecSP(" + operand.ToString() + "); PopBP();";
                                extraContent = extraContent + "    return;" + eol;
#endif
                            }
                            case Instruction.RETRETB:
                            {
                                operand = operand / 2;
#ifdef INLINED // +ve                         
                                if (operand == 1)
                                {  
                                    content =      "    sp--; valuestack[sp-1] = valuestack[sp]; typestack[sp-1] = typestack[sp];";
                                }
                                else
                                {
                                    content =                     "    {   sp--; UInt rv = valuestack[sp]; htype = typestack[sp];";
                                    extraContent =                "        sp = sp - " + operand.ToString() + ";" + eol;
                                    extraContent = extraContent + "        valuestack[sp] = rv; typestack[sp] = htype; sp++;" + eol;
                                    extraContent = extraContent + "    }" + eol;
                                }
                                
                                extraContent = extraContent + "    csp--; bp = callstack[csp];" + eol;
                                extraContent = extraContent + "    return;" + eol;
#else
                                content = "    { UInt rv = PopStack(&htype); DecSP(" + operand.ToString() + "); PushStack(rv, htype); }";
                                extraContent = extraContent + "    PopBP();" + eol;
                                extraContent = extraContent + "    return;" + eol;
#endif
                            }
                            case Instruction.DECSP:
                            {
                                operand = operand / 2;
                                content = "    DecSP(" + operand.ToString() + ");";
                            }
                            case Instruction.DUP:
                            {
                                operand = operand / 2;
                                if (operand == 0)
                                {
                                    // DUP 0 means DUP [top]
                                    content = "    PushStack(GetStack(sp-1, &htype), htype);";
                                }
                                else
                                {  
                                    // DUP 1 means DUP [next], etc.
                                    operand++;
                                    content = "    PushStack(GetStack(sp-" + operand.ToString() + ", &htype), htype);";
                                }
                            }
                            case Instruction.CAST:
                            {
#ifdef UNUSED
                                content = "    typestack[sp-1] = (Type)(0x"+ operand.ToHexString(2) +");";
#else                                
                                content = "    PutStackType(sp-1, (Type)(0x"+ operand.ToHexString(2) +"));";
#endif
                            }
                            
                            
                            case Instruction.ENTERB:
                            {
#ifdef UNUSED
                                content = "    callstack[csp] = bp;bp = sp;csp++;";
#else                                
                                content = "    PushBP();";
#endif
                                while (operand != 0)
                                {
#ifdef UNUSED
                                    extraContent = extraContent + "    typestack[sp] = Type::tByte; valuestack[sp] = 0; sp++;";
#else
                                    extraContent = extraContent + "    PushStack(0, Type::tByte);" + eol;
#endif
                                    operand--;
                                }
                            }
                            case Instruction.PUSHI0:
                            {
#ifdef UNUSED
                                content = "    typestack[sp] = Type::tByte; valuestack[sp] = 0; sp++;";
#else         
                                content = "    PushStack(0, Type::tByte);";
#endif                                                       
                            }
                            case Instruction.PUSHI1:
                            {
#ifdef UNUSED
                                content = "    typestack[sp] = Type::tByte; valuestack[sp] = 1; sp++;";
#else         
                                content = "    PushStack(1, Type::tByte);";
#endif                                                       
                            }
                            case Instruction.PUSHIM1:
                            {
                                content = "    PushStack(0xFFFF, Type::tInt);";
                            }
                            case Instruction.PUSHDB:
                            case Instruction.PUSHIB:
                            {
#ifdef UNUSED
                                content = "    typestack[sp] = Type::tByte; valuestack[sp] = 0x" + operand.ToHexString(2) + "; sp++;";
#else         
                                content = "    PushStack(0x" + operand.ToHexString(2) + ", Type::tByte);";
#endif 
                            }
                            case Instruction.PUSHDW:
                            case Instruction.PUSHIW:
                            {
#ifdef UNUSED
                                content = "    typestack[sp] = Type::tUInt; valuestack[sp] = 0x" + operand.ToHexString(4) + "; sp++;";
#else         
                                content = "    PushStack(0x" + operand.ToHexString(4) + ", Type::tUInt);";
#endif 
                            }
                            case Instruction.PUSHGLOBALBB:
                            {
                                byte lsb = byte(operand & 0xFF);
                                byte msb = byte(operand >> 8);
                                
                                lsb = lsb / 2;
                                msb = msb / 2;
#ifdef UNUSED
                                content      = "    typestack [sp] = typestack [" + lsb.ToString() + "];"; 
                                extraContent = "    valuestack[sp] = valuestack[" + lsb.ToString() + "]; sp++;" + eol; 
                                extraContent = extraContent + "    typestack [sp] = typestack [" + msb.ToString() + "];"; 
                                extraContent = extraContent + "    valuestack[sp] = valuestack[" + msb.ToString() + "]; sp++;" + eol; 
#else
                                content     = "    PushStack(GetStack(" + lsb.ToString() + ", &htype), htype);"; 
                                extraContent = "    PushStack(GetStack(" + msb.ToString() + ", &htype), htype);" + eol; 
#endif
                            }
                            
                            case Instruction.PUSHGLOBALB:
                            {
                                operand = operand / 2;
#ifdef UNUSED
                                content      = "    typestack [sp] = typestack [" + operand.ToString() + "];"; 
                                extraContent = "    valuestack[sp] = valuestack[" + operand.ToString() + "]; sp++;" + eol; 
#else
                                content = "    PushStack(GetStack(" + operand.ToString() + ", &htype), htype);"; 
#endif
                            }
                            
                            case Instruction.PUSHRELB:
                            {
                                int ioperand = int(operand);
                                string sign = "+";
                                if (ioperand > 127)
                                {
                                    ioperand = ioperand - 256;
                                    sign = "";
                                }
                                ioperand = ioperand / 2;
                                content = "    PushStack(GetStack(GetStack(bp" + sign + ioperand.ToString() + "), &htype), htype);";
                            }
                            case Instruction.POPRELB:
                            {
                                int ioperand = int(operand);
                                string sign = "+";
                                if (ioperand > 127)
                                {
                                    ioperand = ioperand - 256;
                                    sign = "";
                                }
                                ioperand = ioperand / 2;
                                content = "    PutStack(GetStack(bp" + sign + ioperand.ToString() + "), PopStack(&htype), htype);";
                            }
                            
                            
                            case Instruction.PUSHSTACKADDRB:
                            {
                                int ioperand = int(operand);
                                string sign = "+";
                                if (ioperand > 127)
                                {
                                    ioperand = ioperand - 256;
                                    sign = "";
                                }
                                ioperand = ioperand / 2;
                                content = "    PushStack(bp" + sign + ioperand.ToString() + ", Type::tReference);";
                            }
                            case Instruction.PUSHLOCALBB:
                            {
                                byte lsb = byte(operand & 0xFF);
                                byte msb = byte(operand >> 8);
                                
                                int ioperand = int(lsb);
                                string sign = "+";
                                if (ioperand > 127)
                                {
                                    ioperand = ioperand - 256;
                                    sign = "";
                                }
                                ioperand = ioperand / 2;
                                content      = "    PushStack(GetStack(bp" + sign + ioperand.ToString() + ", &htype), htype);";
                                
                                int ioperand = int(msb);
                                string sign = "+";
                                if (ioperand > 127)
                                {
                                    ioperand = ioperand - 256;
                                    sign = "";
                                }
                                ioperand = ioperand / 2;
                                extraContent = "    PushStack(GetStack(bp" + sign + ioperand.ToString() + ", &htype), htype);" + eol;
                                
                            }
                            
                            case Instruction.INCLOCALB:
                            {
                                int ioperand = int(operand);
                                string sign = "+";
                                if (ioperand > 127)
                                {
                                    ioperand = ioperand - 256;
                                    sign = "";
                                }
                                ioperand = ioperand / 2;
#ifdef UNUSED
                                content      = "    htype = typestack [bp" + sign + ioperand.ToString() + "]; typestack [bp" + sign + ioperand.ToString() + "] = (htype == Type::tByte) ? Type::tUInt : htype;";
                                extraContent = "    valuestack[bp" + sign + ioperand.ToString() + "]++;" + eol;
#else
                                content      = "    htype = GetStackType(bp" + sign + ioperand.ToString() + ");";
                                extraContent = "    PutStack(bp" + sign + ioperand.ToString() + 
                                                            ", GetStack(bp" + sign + ioperand.ToString() + 
                                                             ")+1, (htype == Type::tByte) ? Type::tUInt : htype);" + eol;
#endif
                            }
                            case Instruction.DECLOCALB:
                            {
                                int ioperand = int(operand);
                                string sign = "+";
                                if (ioperand > 127)
                                {
                                    ioperand = ioperand - 256;
                                    sign = "";
                                }
                                ioperand = ioperand / 2;
#ifdef UNUSED
                                content = "    valuestack[bp" + sign + ioperand.ToString() + "]--;";
#else                                
                                content = "    PutStack(bp" + sign + ioperand.ToString() + ", GetStack(bp" + sign + ioperand.ToString() + ")-1);";
#endif
                            }
                            case Instruction.INCLOCALBB:
                            {
                                byte lsb = byte(operand & 0xFF);
                                byte msb = byte(operand >> 8);
                                
                                int ioperand0 = int(lsb);
                                string sign0 = "+";
                                if (ioperand0 > 127)
                                {
                                    ioperand0 = ioperand0 - 256;
                                    sign0 = "";
                                }
                                ioperand0 = ioperand0 / 2;
                                
                                int ioperand1 = int(msb);
                                string sign1 = "+";
                                if (ioperand1 > 127)
                                {
                                    ioperand1 = ioperand1 - 256;
                                    sign1 = "";
                                }
                                ioperand1 = ioperand1 / 2;
                                
                                content     = "    PutStack(bp" + sign0 + ioperand0.ToString() + 
                                                           ", GetStack(bp" + sign0 + ioperand0.ToString() + 
                                                          ") + GetStack(bp" + sign1 + ioperand1.ToString() + "));"; 
                            }
                            
                            case Instruction.PUSHLOCALB:
                            case Instruction.PUSHLOCALB00:
                            case Instruction.PUSHLOCALB02:
                            {
                                switch (opCode)
                                {
                                    case Instruction.PUSHLOCALB00: { operand = 0; }
                                    case Instruction.PUSHLOCALB02: { operand = 2; }
                                }
                                int ioperand = int(operand);
                                string sign = "+";
                                if (ioperand > 127)
                                {
                                    ioperand = ioperand - 256;
                                    sign = "";
                                }
                                ioperand = ioperand / 2;
                                string index = sign + ioperand.ToString();
                                if (ioperand == 0)
                                {
                                    index = "";
                                }
#ifdef UNUSED
                                content      = "    typestack [sp] = typestack [bp" + index + "];";
                                extraContent = "    valuestack[sp] = valuestack[bp" + index + "]; sp++;" + eol;
#else                                
                                content = "    PushStack(GetStack(bp " + index + ", &htype), htype);";
#endif
                            }
                            case Instruction.POPGLOBALB:
                            {
                                operand = operand / 2;
#ifdef UNUSED
                                content      = "    sp--; typestack [" + operand.ToString() + "] = typestack [sp];";
                                extraContent = "          valuestack[" + operand.ToString() + "] = valuestack[sp];" + eol;
#else
                                content = "    PutStack(" + operand.ToString() + ", PopStack(&htype), htype);";
#endif
                            }
                            case Instruction.INCGLOBALB:
                            {
                                operand = operand / 2;
#ifdef UNUSED
                                content      = "    htype = typestack [" + operand.ToString() + "]; typestack [" + operand.ToString() + "] = (htype == Type::tByte) ? Type::tUInt : htype;";
                                extraContent = "    valuestack[" + operand.ToString() + "]++;" + eol;
#else
                                content      = "    htype = GetStackType(" + operand.ToString() + ");";
                                extraContent = "    PutStack(" + operand.ToString() + 
                                                            ", GetStack(" + operand.ToString() + 
                                                             ")+1, (htype == Type::tByte) ? Type::tUInt : htype);" + eol;
#endif
                            }
                            case Instruction.DECGLOBALB:
                            {
                                operand = operand / 2;
#ifdef UNUSED
                                content = "    valuestack[" + operand.ToString() + "]--;";
#else
                                content = "    PutStack(" + operand.ToString() + 
                                                            ", GetStack(" + operand.ToString() + 
                                                             ")-1, GetStackType(" + operand.ToString() + "));" + eol;
#endif
                            }
                            case Instruction.POPLOCALB:
                            case Instruction.POPLOCALB00:
                            case Instruction.POPLOCALB02:
                            {
                                switch (opCode)
                                {
                                    case Instruction.POPLOCALB00: { operand = 0; }
                                    case Instruction.POPLOCALB02: { operand = 2; }
                                }
                                int ioperand = int(operand);
                                string sign = "+";
                                if (ioperand > 127)
                                {
                                    ioperand = ioperand - 256;
                                    string sign = "";
                                }
                                ioperand = ioperand / 2;
                                string index = sign + ioperand.ToString();
                                if (ioperand == 0)
                                {
                                    index = "";
                                }
#ifdef UNUSED
                                content      = "    sp--; valuestack[bp " + index + "] = valuestack[sp];";
                                extraContent = "    typestack[bp" + index + "] = typestack[sp];" + eol;
#else
                                content      = "    PutStack(bp" + index + ", PopStack(&htype), htype);";
#endif
                            }
                            
                            case Instruction.EQ:
                            case Instruction.NE:
                            case Instruction.LT:
                            case Instruction.LE:
                            case Instruction.GT:
                            case Instruction.GE:
                            case Instruction.PUSHIWLE:
                            case Instruction.PUSHIWLT:
                            {
                                string condition;
                                switch (opCode)
                                {
                                    case Instruction.EQ: { condition = "=="; }
                                    case Instruction.NE: { condition = "!="; }
                                    case Instruction.PUSHIWLT:
                                    case Instruction.LT: { condition = "<"; }
                                    case Instruction.GT: { condition = ">"; }
                                    case Instruction.GE: { condition = ">="; }
                                    case Instruction.PUSHIWLE:
                                    case Instruction.LE: { condition = "<="; }
                                    
                                }
                                if ((opCode == Instruction.PUSHIWLE) || (opCode == Instruction.PUSHIWLT))
                                {
#ifdef INLINED // +ve
                                    content      = "    typestack [sp-1] = Type::tBool;";
                                    extraContent = "    valuestack[sp-1] = (valuestack[sp-1] " + condition + " " + operand.ToString() + ");" + eol;
#else
                                    content      = "    top = " + operand.ToString() + "; next = PopStack();";
                                    extraContent = "    PushStack((next " + condition + " top), Type::tBool);" + eol;
#endif
                                }
                                else
                                {
#ifdef INLINED // +ve
                                    content      = "    sp--; typestack [sp-1] = Type::tBool;";
                                    extraContent = "    valuestack[sp-1] = (valuestack[sp-1] " + condition + " valuestack[sp]);" + eol;
#else                                
                                    content      = "    top = PopStack(); next = PopStack();";
                                    extraContent = "    PushStack((next " + condition + " top), Type::tBool);" + eol;
#endif                                    
                                }
                                
                            }
                            
                            case Instruction.LTI:
                            case Instruction.LEI:
                            case Instruction.PUSHIWLEI:
                            case Instruction.GTI:
                            case Instruction.GEI:
                            {
                                string condition;
                                switch (opCode)
                                {
                                    case Instruction.LTI: { condition = "<"; }
                                    case Instruction.GTI: { condition = ">"; }
                                    case Instruction.GEI: { condition = ">="; }
                                    case Instruction.PUSHIWLEI:
                                    case Instruction.LEI: { condition = "<="; }
                                }
                                if (opCode == Instruction.PUSHIWLEI)
                                {
                                    int ioperand = Types.UIntToInt(operand);
                                    content      = "    topi = " + ioperand.ToString() + "; nexti = PopStackI();";
                                    extraContent = "    PushStack((nexti " + condition + " topi), Type::tBool);" + eol;
                                }
                                else
                                {
#ifdef INLINED // +ve
                                    content      = "    sp--; typestack [sp-1] = Type::tBool;";
                                    extraContent = "    valuestack[sp-1] = (Int(valuestack[sp-1]) " + condition + " Int(valuestack[sp]));" + eol;
#else                                                                    
                                    content      = "    topi = PopStackI(); nexti = PopStackI();";
                                    extraContent = "    PushStack((nexti " + condition + " topi), Type::tBool);" + eol;
#endif
                                }
                                
                            }
                            
                            case Instruction.ADD:
                            {
#ifdef INLINED // +ve
                                content      = "    sp--; typestack[sp-1] = Type::tUInt;";
                                extraContent = "    valuestack[sp-1] += valuestack[sp];" + eol;
#else                                
                                content      = "    top = PopStack(); next = PopStack();";
                                extraContent = "    PushStack(next + top, Type::tUInt);" + eol;
#endif
                            }
                            case Instruction.BOOLNOT:
                            {
                                content      = "    top = PopStack();";
                                extraContent = "    PushStack((top == 0) ? 1 : 0, Type::tBool);" + eol;                          
                            }
                            case Instruction.BITNOT:
                            {
                                content      = "    top = PopStack();";
                                extraContent = "    PushStack(~top, Type::tUInt);" + eol;                          
                            }
                            case Instruction.SUB:
                            case Instruction.MUL:
                            case Instruction.DIV:
                            case Instruction.MOD:
                            case Instruction.BITAND:
                            case Instruction.BITOR:
                            case Instruction.BITXOR:
                            case Instruction.BITSHL:
                            case Instruction.BITSHR:
                            {
                                string operation;
                                switch (opCode)
                                {
                                    case Instruction.SUB:     { operation = "-"; }
                                    case Instruction.MUL:     { operation = "*"; }
                                    case Instruction.DIV:     { operation = "/"; } // TODO : / 0 check
                                    case Instruction.MOD:     { operation = "%"; } // TODO : / 0 check
                                    case Instruction.BITAND:  { operation = "&"; }
                                    case Instruction.BITOR:   { operation = "|"; }
                                    case Instruction.BITXOR:  { operation = "^"; }
                                    case Instruction.BITSHL:  { operation = "<<"; }
                                    case Instruction.BITSHR:  { operation = ">>"; }
                                }
#ifdef INLINED
                                content      = "    sp--; typestack[sp-1] = Type::tUInt;";
                                extraContent = "    valuestack[sp-1] = (valuestack[sp-1] " + operation + " valuestack[sp]);" + eol;
#else                                
                                content      = "    top = PopStack(); next = PopStack();";
                                extraContent = "    PushStack(next " + operation + " top, Type::tUInt);" + eol;
#endif
                            }
                            case Instruction.BOOLAND:
                            case Instruction.BOOLOR:
                            {
                                string operation;
                                switch (opCode)
                                {
                                    case Instruction.BOOLAND: { operation = "&&"; }
                                    case Instruction.BOOLOR:  { operation = "||"; }
                                }
#ifdef UNUSED
                                content      = "    sp--; typestack[sp-1] = Type::tBool;";
                                extraContent = "    valuestack[sp-1] = ((valuestack[sp-1]!=0) " + operation + " (valuestack[sp]!=0));" + eol;
#else
                                content      = "    top = PopStack(); next = PopStack();";
                                extraContent = "    PushStack((Bool)(next " + operation + " top), Type::tBool);" + eol;
#endif
                            }
                            
                            case Instruction.ADDI:
                            case Instruction.SUBI:
                            case Instruction.MULI:
                            case Instruction.DIVI:
                            case Instruction.MODI:
                            {
                                string operation;
                                switch (opCode)
                                {
                                    case Instruction.ADDI: { operation = "+"; }
                                    case Instruction.SUBI: { operation = "-"; }
                                    case Instruction.MULI: { operation = "*"; }
                                    case Instruction.DIVI: { operation = "/"; } // TODO : / 0 check
                                    case Instruction.MODI: { operation = "%"; } // TODO : / 0 check
                                }
#ifdef INLINED // +ve
                                content      = "    sp--; typestack[sp-1] = Type::tInt;";
                                extraContent = "    valuestack[sp-1] = UInt(Int(valuestack[sp-1]) " + operation + " Int(valuestack[sp]));" + eol;
#else                                
                                content      = "    topi = PopStackI(); nexti = PopStackI();";
                                extraContent = "    PushStackI(nexti " + operation + " topi);" + eol;
#endif
                            }
                            default:
                            {
                                content      = "    PushStack(0x0A, Type::tByte); Diagnostics_SetError(0); // not implemented";
                                PrintLn();
                                PrintLn("opCode=" + Instructions.ToString(opCode) + " not implemented yet?", MatrixRed, Black);
                                Die(0x0A); // opCode probably not implemented
                            }
                        }
                        cFile.Append("    // " + dasm + eol);  
                        cFile.Append(content + eol);  
                        if (extraContent.Length > 0)
                        {
                            cFile.Append(extraContent);  
                        }      
                        //cFile.Append(eol);
                        pc = nextPC;
                    } // second pass
                    
                    cFile.Append("}" + eol);
                    Parser.ProgressTick(".");        
                }
                                
                cFile.Flush();
                
                if (!Parser.IsInteractive())
                {
                    long codeSize = File.GetSize(cPath);
                    PrintLn();
                    Print("Success, " + codeSize.ToString() + " bytes, ", Color.ProgressText, Color.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() +"s", Color.ProgressHighlight, Color.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                success = true;
                break;
            }
            break;
        }
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }

    }
}
