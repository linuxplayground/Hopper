program E6502
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    
    //#define PROFILING
        
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    
    uses "/Source/Compiler/JSON/JSON"
    uses "/Source/Compiler/JSON/Code"
    
    uses "/Source/Editor/Highlighter"
    
    uses "/Source/Compiler/CODEGEN/Asm6502"
    
    uses "Chips/6502"
    uses "Chips/ACIA"
    
    uses "6502/Shared"
    
    bool showStringVariables;
    uint orgROM;
    uint[16] breakpoints;
    
    <uint,uint> methodSizes;     // <index, length>
    <uint,uint> methodAddresses; // <address,index>
    
    <uint,long> addressHits;
    
    DumpProfile()
    {
        file profileData = File.Create("/Temp/Profile.csv");
        foreach (var kv in addressHits)
        {
            uint address = kv.key;
            long hits    = kv.value;
            profileData.Append("0x" + address.ToHexString(4) + "," + hits.ToString() + Char.EOL);
        }
        profileData.Flush();
    }
    
    bool BreakCheck()
    {
        if (Keyboard.IsAvailable)
        {
            Key key = Keyboard.ReadKey();
            if (key == Key.ControlC)
            {
                PrintLn("<ctrl><C>");
                return true;
            }
        }
        return false;
    }
    Run()
    {
        // run ignoring breakpoints
        loop
        {
            if (BreakCheck()) { break; }
            uint pc = W65C02.PC;
            if (pc == InvalidAddress) { break; }
            StepInto();
        }
    }
    Debug()
    {
        // run until breakpoint
        bool first = true;
        loop
        {
            if (BreakCheck()) { break; }
            uint pc = W65C02.PC;
            if (pc == InvalidAddress) { break; }
            if (!first && IsBreakPoint(pc))
            {
                ClearIfZeroBreakPoint(pc);
                break;
            }
            StepInto();
            first = false;
        }
    }
    StepOver()
    {
        uint pc = W65C02.PC;
        if (pc == InvalidAddress) { return; }
        OpCode instruction = OpCode(W65C02.GetMemory(pc));
        if (instruction == Asm6502.GetJSRInstruction())
        {
            uint length = Asm6502.GetInstructionLength(instruction);
            SetBreakPoint(0, pc+length);
            Debug();
        }
        else
        {
            StepInto();
        }
    }
    StepInto()
    {
        if (ACIA.ServiceSerial())
        {
            W65C02.RaiseIRQ();
        }
#ifdef PROFILING        
        uint pc = W65C02.PC;
        if (!addressHits.Contains(pc))
        {
            addressHits[pc] = 0;
        }
        addressHits[pc] = addressHits[pc] + 1;
#endif
        W65C02.Execute();
    }
    ClearIfZeroBreakPoint(uint address)
    {
        if (breakpoints[0] == address)
        {
            breakpoints[0] = InvalidAddress;
        }
    }
    ClearBreakPoints()
    {
        for (uint i = 0; i < breakpoints.Count; i++)
        {
            breakpoints[i] = InvalidAddress;
        }
    }
    SetBreakPoint(uint breakpoint, uint address)
    {
        breakpoints[breakpoint] = address;  
    }
    bool IsBreakPoint(uint address)
    {
        for (uint i = 0; i < breakpoints.Count; i++)
        {
            if (breakpoints[i] == address) { return true; }
        }
        return false;
    }
    
    ShowDisassembly(uint address, uint instructions)
    {
        PrintLn();
        //<uint,uint> methodSizes;     // <index, length>
        //<uint,uint> methodAddresses; // <address,index>
        uint methodIndex;
        uint methodStart;
        uint methodLength;
        bool found;
        foreach (var kv in methodAddresses)
        {
            methodStart = kv.key + orgROM;
            //PrintLn(methodStart.ToHexString(4));
            if (address >= methodStart)
            {
                methodIndex = kv.value;
                methodLength = methodSizes[methodIndex];
                if (address < methodStart + methodLength)
                {
                    found = true;
                    break;
                }
            }
        }
        if (found)
        {
            <string,variant> methodSymbols = Code.GetMethodSymbols(methodIndex);
            <string,string> debugInfo;
            string src;
            string srcName;
            if (methodSymbols.Count != 0)
            {
                src = methodSymbols["source"];
                srcName = Path.GetFileName(src);
                string ln = methodSymbols["line"];
                string nm = methodSymbols["name"];
                debugInfo = methodSymbols["debug"];
            }

            //PrintLn(methodIndex.ToString() + " " +
            //        methodStart.ToHexString(4) + " " + 
            //       (methodStart + methodLength-1).ToHexString(4) + " " +
            //       (debugInfo.Count).ToString() +
            //        " : " + address.ToHexString(4));
            
            bool firstLine = true;
            loop
            {
                if (instructions == 0) { break; }
                if (address > methodStart + methodLength-1) { break; }
                OpCode instruction = OpCode(W65C02.GetMemory(address));
                uint length      = Asm6502.GetInstructionLength(instruction);
                
                uint operand;
                string operandString;
                if (length == 2)
                {
                    operand = W65C02.GetMemory(address+1);
                }
                else if (length == 3)
                {
                    operand = W65C02.GetMemory(address+1) + (W65C02.GetMemory(address+2) << 8); 
                }
                
                string debugAddress = (address - methodStart).ToString();
                //PrintLn("debugAddress=" + debugAddress);
                string comment;
                if (debugInfo.Contains(debugAddress))
                {
                    string debugLine = debugInfo[debugAddress];
                    string sourceLine = getSourceLine(src, debugLine);
                    if (sourceLine.Length != 0)
                    {
                        comment = "// " + sourceLine.Trim();
                        if (comment.Length < 34)
                        {
                            comment = comment.Pad(' ', 34);
                            comment = comment + srcName + ":" + debugLine;
                        }
                    }
                    else
                    {
                        comment = "// " + src + ":" + debugLine;  
                    }
                }
                
                uint colour = Colour.MatrixBlue;
                if (firstLine)
                {
                    colour = Colour.Ocean;
                }
                string disassembly = Asm6502.Disassemble(address, instruction, operand);
                if (address == W65C02.PC)
                {
                    string location = disassembly.Substring(0,6);
                    disassembly = disassembly.Substring(6);
                    Print("PC -> ", Colour.MatrixRed, Colour.Black);
                    Print(location, Colour.LightestGray, Colour.Black);
                    Print(disassembly.Pad(' ', 42), colour, Colour.Black); // disassembly
                }
                else
                {
                    Print("      " + disassembly.Pad(' ', 48), colour, Colour.Black); // disassembly
                }
                PrintLn(comment, Colour.MatrixGreen, Colour.Black); // comment
                
                address += length;
                instructions--;
                firstLine = false;
            }
        }
    }

    ShowCurrentInstruction(uint instructions)
    {
        ShowDisassembly(W65C02.PC, instructions);
    }
       
       
    DoReset()
    {
        ACIA.Initialize();
        W65C02.Reset();
    }
    
    MemoryDump(string hexpage)
    {
        uint page;
        _ = UInt.TryParse("0x" + hexpage, ref page);
        
        page = page << 8;
        
        PrintLn();
        Print("      ");
        for (byte i = 0; i < 16; i++)
        {
           Print("x" + i.ToHex() + " ");  
           if (i == 7)
           {
               Print(' ');
           }  
        }
        
        for (uint i = 0; i < 256; i++)
        {
            uint address = page + i;
            if (i % 16 == 0)
            {
                PrintLn();
                Print((address).ToHexString(4));
            }
            if (i % 8 == 0)
            {
                Print(" ");
            }
            Print(" " + (W65C02.GetMemory(address)).ToHexString(2), Colour.LightestGray, Colour.Black);
        }
        PrintLn();
    }
    ShowZeroPage()
    {
        MemoryDump("00");
    }
    ShowCallStack()
    {
        PrintLn();
        W65C02.ShowStack();
    }
    ShowRegisters()
    {
        PrintLn();
        string names = W65C02.GetRegisterNames();
        string registers = W65C02.GetRegisters();
        PrintLn(names);
        Print(registers, Colour.LightestGray, Colour.Black);
        if (showStringVariables)
        {
            GetRAMByteDelegate getRAMByte = W65C02.GetMemory;
            ShowHopperStringVariables(getRAMByte);
        }
        PrintLn();
    }
    
    string pathLoaded;
    <string> sourceLines;
    string getSourceLine(string path, string lnum)
    {
        if (pathLoaded != path)
        {
            file sourceFile = File.Open(path);
            if (sourceFile.IsValid())
            {
                sourceLines.Clear();
                pathLoaded = path;
                loop
                {
                    string ln = sourceFile.ReadLine();
                    if (ln.Length == 0)
                    {
                        if (!sourceFile.IsValid())
                        {
                            break;
                        }
                    }
                    sourceLines.Append(ln);
                }
            }
        }
        string sourceLine;
        uint iline;
        if (UInt.TryParse(lnum, ref iline))
        {
            if (iline > 0)
            {
                iline--;
            }
            if (sourceLines.Count > iline)
            {
                sourceLine = sourceLines[iline];
            }
        }
        return sourceLine;
    }

    <byte> readIHex(file hexFile, ref uint loadAddress)
    {
        <byte> code;
        bool first = true;
        loop
        {
            string ln = hexFile.ReadLine();
            if (!hexFile.IsValid()) { break; }
            string len = ln.Substring(1,2);
            uint length;
            _ = UInt.TryParse("0x" + len, ref length);
            if (length == 0) { continue; }
            if (first)
            {
                string location = ln.Substring(3,4);
                _ = UInt.TryParse("0x" + location, ref loadAddress);
            }
            ln = ln.Substring(9);
            while (length > 0)
            {
                string br = ln.Substring(0, 2);
                ln = ln.Substring(2);
                uint b;
                _ = UInt.TryParse("0x" + br, ref b);
                code.Append(byte(b));
                length--;
            }
            first = false;
        }
        return code;
    }
    bool ValidateHexPage(ref string hexpage)
    {
        bool valid = false;
        hexpage = hexpage.ToUpper();
    
        uint returnValue = 0;
        if (UInt.TryParse("0x" + hexpage, ref returnValue))
        {
            if ((returnValue >= 0x00) && (returnValue <= 0xFF))
            {
                valid = true;
                if (hexpage.Length == 1)
                {
                    hexpage = "0" + hexpage;
                }
            }
        }
        
        return valid;
    }
    PrintPad(string ln, uint padding)
    {
        while (padding > 0)
        {
            String.BuildFront(ref ln, ' ');
            padding--;
        }
        PrintLn(ln);
    }
    Help()
    {
        PrintLn();
        PrintPad("Commands:", 2);
        PrintPad("?        - this", 4);
        PrintPad("Q        - exit, also <alt><F4>", 4);
        PrintLn();
        PrintPad("D        - debug program, also <F5>", 4);
        PrintPad("X        - execute program, also <ctrl><F5>", 4);
        PrintPad("W        - warm restart of loaded 6502 program (RESET)", 4);
        PrintPad("N        - trigger non-maskable interrupt (NMI)", 4);
        PrintPad("O        - step over, also <F10>", 4);
        PrintPad("I        - step into, also <F11>", 4);
        PrintPad("B X      - clear all breakpoints", 4);
        PrintPad("B x xxxx - set breakpoint 1..F", 4);
        PrintLn();
        PrintPad("C        - show stack", 4);
        PrintPad("R        - show registers", 4);
        PrintPad("S        - show source listing at PC", 4);
        PrintPad("M <page> - dump a 256 byte page of memory", 4);
    }
    
    Hopper()
    {
        string filePath;
        bool showHelp;
        
        <string> rawArgs = System.Arguments;
        <string> args;
        
        for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
        {
          string arg = rawArgs[iArg];
          if ((arg.Length == 2) && (arg[0] == '-'))
          {
              arg = arg.ToLower();
              switch (arg)
              {
                  default:
                  {
                      args.Clear();
                      break;
                  }
              }
          }
          else
          {
              args.Append(arg);
          }
        }
        if (args.Count > 1)
        {
            showHelp = true;
        }
        else if (args.Count == 1)
        {
            filePath = args[0];
        }
        
        if (filePath.Length == 0)
        {
            showHelp = true;
        }
        
        loop
        {
            if (!showHelp)
            {
                loop
                {
                    // check the file
                    string fullPath;
                    if (File.Exists(filePath))
                    {
                        break;
                    }
                    fullPath = Path.Combine(System.CurrentDirectory, filePath);
                    if (File.Exists(fullPath))
                    {
                        filePath = fullPath;
                        break;
                    }
                    string extension = Path.GetExtension(filePath);
                    if (extension == ".")
                    {
                        string filePathExt = filePath + ".asm";
                        if (File.Exists(filePathExt))
                        {
                            filePath = filePathExt;
                            break;
                        }
                        string fullPathExt = Path.Combine(System.CurrentDirectory, filePathExt);
                        if (File.Exists(fullPathExt))
                        {
                            filePath = fullPathExt;
                            break;
                        }
                    }
                    if (!File.Exists(fullPath))
                    {
                        showHelp = true;
                    }
                    break;
                } // loop
            }
            string ihexPath;
            string symbolsPath;
            if (!showHelp && (filePath.Length != 0))
            {
                ihexPath = Path.GetFileName(filePath);
                string extension = Path.GetExtension(filePath);
                ihexPath = ihexPath.Replace(extension, ".hex");
                ihexPath = Path.Combine("/bin", ihexPath);
                
                symbolsPath = Path.GetFileName(filePath);
                symbolsPath = symbolsPath.Replace(extension, ".code");
                symbolsPath = Path.GetFileName(symbolsPath);
                symbolsPath = Path.Combine("/Debug/Obj", symbolsPath);
                if (!File.Exists(ihexPath))
                {
                    showHelp = true;
                }                
                if (!File.Exists(symbolsPath))
                {
                    showHelp = true;
                }
            }
            
            if (showHelp)
            {
                PrintLn("6502 <.asm filepath>");
                if ((ihexPath.Length != 0) && !File.Exists(ihexPath))
                {
                    PrintLn("    '" + ihexPath + "' not found");
                }
                if ((symbolsPath.Length != 0) && !File.Exists(symbolsPath))
                {
                    PrintLn("    '" + symbolsPath + "' not found");
                }
                break;
            }
            
            Screen.Clear();
            
            // load the ihex and symbols
            
            if (!ParseCode(symbolsPath, false, true))
            {
                PrintLn("Failed to load '" + symbolsPath + "'");
                break;
            }
            PrintLn();
            file hexFile = File.Open(ihexPath);
            <byte> code = readIHex(hexFile, ref orgROM);
            if (code.Count == 0)
            {
                PrintLn("Failed to load '" + ihexPath + "'");
                break;
            }
            
            // find the method address ranges for disassembly
            methodSizes = Code.GetMethodSizes();
            uint indexMax = 0;
            foreach (var sz in methodSizes)
            {
                if (sz.key > indexMax)
                {
                    indexMax = sz.key;
                }
            }
            uint methodAddress = 0;
            for (uint index = 0; index <= indexMax; index++)
            {
                if (!methodSizes.Contains(index)) { continue; }   
                uint methodSize = methodSizes[index];
                methodAddresses[methodAddress] = index;
                methodAddress += methodSize;
            }
            
            uint length = code.Count;
            
            uint vectorUse    = 6;
            W65C02.NMI   = code[length-6] + (code[length-5] << 8);
            W65C02.Reset = code[length-4] + (code[length-3] << 8);
            W65C02.IRQ   = code[length-2] + (code[length-1] << 8);
            
            DoReset();
            for (uint i = 0; i < length-vectorUse; i++)
            {
                W65C02.SetMemory(orgROM+i, code[i]);
            }
            
            //PrintLn(orgROM.ToHexString(4));
            //PrintLn(vectorNMI.ToHexString(4));
            //PrintLn(vectorReset.ToHexString(4));
            //PrintLn(vectorIRQ.ToHexString(4));
            
            char currentCommand = ' ';
            string commandLine = "";
            bool refresh = true;
            bool firstRun = false;
            loop
            {
                if (refresh)
                {
                    SetCursor(0, Screen.CursorY);
                    string ln = ">" + commandLine;
                    uint cursorX = ln.Length;
                    ln = ln.Pad(' ', Screen.Columns-1);
                    Print(ln);
                    SetCursor(cursorX, Screen.CursorY);
                    refresh = false;
                }
                
                Key key;
                if (firstRun)
                {
                    key = Key.F5;
                    firstRun = false;
                }
                else
                {
                    key = ReadKey();
                }
                
                char ch = key.ToChar();
                ch = ch.ToUpper();
                uint clength = commandLine.Length;
                
                // shortcut keys
                bool doShortcut = false;
                if (key == (Key.Alt | Key.F4))
                {
                    commandLine = "Q";
                    doShortcut = true;
                }
                else if (key == Key.F5)
                {
                    commandLine = "D";
                    doShortcut = true;
                }
                else if (key == (Key.Control | Key.F5))
                {
                    commandLine = "X";
                    doShortcut = true;
                }
                else if (key == Key.F11)
                {
                    commandLine = "I";
                    doShortcut = true;
                }
                else if (key == Key.F10)
                {
                    commandLine = "O";
                    doShortcut = true;
                }
                if (doShortcut && (commandLine.Length != 0))
                {
                    currentCommand = commandLine[0];
                    Print(commandLine);
                    key = Key.Enter;
                }
                if (key == Key.Enter)
                {
                    // execute commandLine
                    if (currentCommand == 'Q') // exit monitor UI
                    {
                        PrintLn();
                        break; 
                    }
                    else if (currentCommand == '?') // help
                    {
                        Help();
                        refresh = true;
                    }
                    else if (currentCommand == 'Z') // zero page variables
                    {
                        ShowZeroPage();
                        refresh = true;
                    }
                    else if (currentCommand == 'C') // show call stack
                    {
                        ShowCallStack();
                        refresh = true;
                    }
                    else if (currentCommand == 'H') // show Hopper heap
                    {
                        GetRAMByteDelegate getRAMByte = W65C02.GetMemory;
                        ShowHopperHeap(getRAMByte);
                        refresh = true;
                    }
                    else if (currentCommand == 'V') // show Hopper heap
                    {
                        GetRAMByteDelegate getRAMByte = W65C02.GetMemory;
                        ShowHopperValueStack(getRAMByte);
                        refresh = true;
                    }
                    else if (currentCommand == 'M') // memory dump
                    {
                        string hexpage = "";
                        if (commandLine.Length > 2)
                        {
                            if (commandLine == "M S")
                            {
                                showStringVariables = !showStringVariables;
                                refresh = true;
                            }
                            else
                            {
                                hexpage = commandLine.Substring(2, commandLine.Length-2);
                                if (ValidateHexPage(ref hexpage))
                                {
                                    MemoryDump(hexpage);
                                    refresh = true;
                                }
                            }
                        }
                    } // case 'M'
                                  
                    else if (currentCommand == 'B') // breakpoints
                    {
                        if (commandLine == "B X")
                        {
                            ClearBreakPoints();
                            refresh = true;
                        }
                        else if (commandLine.Length > 4)
                        {
                            string hex = "0x" + commandLine.Substring(2,1);
                            uint breakpoint;
                            if (UInt.TryParse(hex, ref breakpoint) && (breakpoint > 0))
                            {
                                hex = "0x" + commandLine.Substring(4);
                                uint breakAddress;
                                if (UInt.TryParse(hex, ref breakAddress) && (breakAddress > 0) && (breakAddress < 0xFFFF))
                                {
                                    SetBreakPoint(breakpoint, breakAddress);
                                    refresh = true;
                                }
                            }
                        }
                    } // case 'B'
                
                    else if (currentCommand == 'X') // Execute (run with Warp)
                    {
                        Run();
                        refresh = true;
                    }
                    else if (currentCommand == 'D') // Debug (run with !Warp)
                    {
                        Debug();
                        uint pc = W65C02.PC;
                        if (pc != InvalidAddress)
                        {
                            ShowRegisters();
                            ShowCurrentInstruction(3);
                        }
                        refresh = true;
                    }
                    else if (currentCommand == 'I') // Step (single / into / F11)
                    {
                        StepInto();
                        uint pc = W65C02.PC;
                        if (pc != InvalidAddress)
                        {
                            ShowRegisters();
                            ShowCurrentInstruction(3);
                        }
                        refresh = true;
                    }
                    else if (currentCommand == 'O') // Step (next / over / F10)
                    {
                        StepOver();
                        uint pc = W65C02.PC;
                        if (pc != InvalidAddress)
                        {
                            ShowRegisters();
                            ShowCurrentInstruction(3);
                        }
                        refresh = true;
                    }
                    else if (currentCommand == 'S') // Source
                    {
                        ShowCurrentInstruction(15);
                        refresh = true;
                    }
                    else if (currentCommand == 'W') // Warm Restart (keep program, reset data)
                    {
                        W65C02.Reset();
                        refresh = true;
                    }
                    else if (currentCommand == 'R') // Registers
                    {
                        ShowRegisters();
                        refresh = true;
                    }
                    else if (currentCommand == 'U') // dUmp profile data
                    {
                        DumpProfile();
                        refresh = true;
                    }
                    if (refresh)
                    {
                        commandLine = "";
                        currentCommand = ' ';
                        PrintLn();
                    }
                } // if (key == Key.Enter)
                
                
                else if (key == Key.Escape)
                {
                    // cancel commandline
                    commandLine = "";
                    refresh = true;
                }
                else if (key == Key.ControlC)
                {
                    // cancel commandline
                    commandLine = "";
                    //Monitor.EmptyCommand();
                    PrintLn("<ctrl><C>");
                    refresh = true;
                }
                else if (key == Key.Backspace)
                {
                    // back up one
                    if (commandLine.Length != 0)
                    {
                        commandLine = commandLine.Substring(0, commandLine.Length-1);
                        SetCursor(0, Screen.CursorY);
                        refresh = true;
                    }
                }
                else
                { 
                    // alphanumeric
                    if (clength < Screen.Columns-1)
                    {
                        if (clength == 0)
                        {
                            // first character must be command key
                            if (String.Contains("?BCDHIMOQRSUVWXZ", ch))
                            {
                                currentCommand = ch;
                            }
                            else
                            {
                                continue;
                            }
                        } // clength == 0
                        else if (clength == 1)
                        {
                            if (ch != ' ') // 2nd character must be ' '
                            {
                                continue;
                            }
                            if (currentCommand == 'L')
                            {
                                // has arguments
                            }
                            else if (currentCommand == 'M')
                            {
                                // has arguments
                            }
                            else if (currentCommand == 'F')
                            {
                                // has arguments
                            }
                            else if (currentCommand == 'B')
                            {
                                // has arguments
                            }
                            else
                            {
                                continue; // no arguments
                            }
                        } // clength == 1
                        else
                        {   // clength > 1
                            // arguments
                            if (currentCommand == 'L')
                            {
                                // L <ihex path>
                            }
                            else if (currentCommand == 'T')
                            {
                                // T <local file path> <remote folder>
                            }
                            else if (currentCommand == 'M')
                            {
                                // M n or nn (MSB hex for page)
                            }
                            else if (currentCommand == 'F')
                            {
                                // F n or nn (MSB hex for page)
                            }
                            else if (currentCommand == 'B')
                            {
                                // B X or B n nnnn
                            }
                            else
                            {
                                continue; // should never get here
                            }
                        } // clength > 1
                        
                        if (ch != char(0))
                        {
                            commandLine = commandLine + ch;
                            refresh = true;
                        }
                    }  // if (commandLine.Length < Screen.Columns-1)
                } // alphanumeric
                
            } // loop
            
            break;
        } // loop
        ACIA.Close();
    }
}
