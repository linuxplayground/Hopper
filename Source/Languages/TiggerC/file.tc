// Tigger C File API Prototypes
#include "system.tc"
#include "string.tc"
#include "i2c.tc"
/*
File System Structure:
-----------------------
1. ChainLists:
   - Contains chains of blocks for files and directories that span multiple blocks.
   - Located at page 0.
2. Root Directory:
   - The starting point of the file system, storing the root directory entries.
   - Located at page 1.

Descriptor Record Structure (within Directory Pages):
-----------------------------------------------------
- Filename:           Offset 0, 12 bytes (null-terminated if shorter)
- File Type:          Offset 12, 1 byte (high nibble: type, low nibble: name length)
                      - 0x00: File
                      - 0x10: Directory
- Start Block:        Offset 13, 1 byte (block number where the file/directory starts, 1 if empty or end of chain)
- File Size:          Offset 14, 2 bytes (size of the file in bytes)

File Handle Structure (byte array):
-----------------------------------
   [0] - Directory block number (byte)
   [1] - File descriptor index (0 to 15) (byte)
   [2] - Current position LSB in file (byte)
   [3] - Current position MSB in file (byte)
   Total: 4 bytes

Directory Handle Structure (byte array):
----------------------------------------
   [0] - Directory descriptor index (byte)
   [1] - Current position in directory (byte)
   Total: 2 bytes

Directory Entry Structure (byte array):
---------------------------------------
   [0] - Entry type (0 for file, 1 for directory) (byte)
   [1-12] - Entry name (up to 12 bytes, null-terminated if shorter)
   Total: 13 bytes
*/
const word PageSize   = 256;
const word TotalPages = 256;
const byte ChainBlock = 0;
const byte RootDirStartBlock = 1;
const byte FileTypeDirectory = 0x10;
const byte FileTypeFile = 0x00;
const byte FilenameOffset = 0;
const byte FileTypeOffset = 12;
const byte StartBlockOffset = 13;
const byte FileSizeOffset = 14;
const byte DescriptorSize = 16;
const byte DescriptorsPerBlock = PageSize / DescriptorSize;
byte[DescriptorSize] _dirEntry; // global used by readdir
char[256]            _currentDirectory;
// prototypes
func int closedir(byte[] dirHandle);
func byte[] opendir(const char[] dirname);
func byte findFreePage(byte[] chainBlock);

// Prints the contents of a buffer in hexadecimal format.
func printHex(const byte[] buffer, word length) {
    word i;
    for (i = 0; i < length; i++) {
        writeHex(buffer[i]);
        writeChar(' ');
        if ((i + 1) % 16 == 0) {
            if ((i + 1) % 64 == 0) {
                writeChar('\n');
                break;
            } else {
                writeChar(' ');
            }
        }
    }
    writeChar('\n');
}
// Debugging function to print a byte buffer
func printByteBuffer(const char[] label, byte[] buffer, word length) {
    writeString(label);
    writeString(":\n");
    printHex(buffer, length);
}

// Reads a block from EEPROM.
// blockNum: The block number to read.
// buffer: The buffer to store the read data.
func readBlock(word blockNum, byte[] buffer) {
    readPage(blockNum * PageSize, buffer);
}

// Writes a block to EEPROM.
// blockNum: The block number to write.
// buffer: The buffer containing the data to write.
func writeBlock(word blockNum, const byte[] buffer) {
    writePage(blockNum * PageSize, buffer);
}

// Finds a free page in the ChainList.
// Returns the index of the free page or 0 if no free page is found.
func byte findFreePage(byte[] chainBlock) {
    word i;
    for (i = 2; i < TotalPages; i++) {
        if (chainBlock[i] == 0) {
            return i as byte;
        }
    }
    return 0; // No free page found
}

// Validates a path for correct length and valid characters.
// Returns true if the path is valid, false otherwise.
func bool isValidPath(const char[] path) {
    word i;
    word len = strlen(path);
    if (len == 0 || len > 255) {
        return false; // Invalid length
    }
    for (i = 0; i < len; i++) {
        if (!(isalnum(path[i]) || path[i] == '.' || path[i] == '/')) {
            return false; // Invalid character
        }
    }
    return true;
}

func resolveRelativePath(char[] dest, const char[] path) {
    // Handle the root path separately
    if (strcmp(path, "/") == 0) {
        strcpy(dest, "/");
        return;
    }
    char[] token;
    char[] temp = malloc(256) as char[];
    strcpy(temp, path);
    token = strtok(temp, "/");
    while (token != null) {
        if (strcmp(token, ".") == 0) {
            // Skip
        } else {
            if (strcmp(token, "..") == 0) {
                // Remove last directory in dest
                char[] lastSlash = strrchr(dest, '/');
                if (lastSlash != null && lastSlash != dest) {
                    lastSlash[0] = '\0';
                } else {
                    // Avoid removing the root slash
                    dest[1] = '\0';
                }
            } else {
                if (strlen(dest) > 1) {
                    strcat(dest, "/");
                }
                strcat(dest, token);
            }
        }
        token = strtok(null, "/");
    }
    free(temp as byte[]);
}

func getFullPath(char[] dest, const char[] path) {
    if (_currentDirectory[0] == '\0') {
        strcpy(_currentDirectory, "/"); // initialize before first use
    }
    if (path[0] == '/') {
        // Absolute path
        strcpy(dest, path);
    } else {
        // Relative path
        strcpy(dest, _currentDirectory);
        if (dest[strlen(dest) - 1] != '/') {
            strcat(dest, "/");
        }
        strcat(dest, path);
    }
    // Resolve relative components like '.' and '..'
    char[] resolvedPath = malloc(256) as char[];
    resolveRelativePath(resolvedPath, dest);
    strcpy(dest, resolvedPath);
    free(resolvedPath as byte[]);
    // Ensure the path starts with a root '/'
    if (dest[0] != '/') {
        char[] temp = malloc(256) as char[];
        strcpy(temp, dest);
        strcpy(dest, "/");
        strcat(dest, temp);
        free(temp as byte[]);
    }
}

// Formats the drive, initializing the file system.
// Returns 0 on success, or -1 on error.
func int format() {
    // Initialize global block chain page (no chains yet, 0 and 1 reserved)
    byte[PageSize] blockChainPage;
    blockChainPage[0] = 1;
    blockChainPage[1] = 1;
    writePage(ChainBlock * PageSize, blockChainPage);
    // Initialize the root directory (empty initially)
    byte[PageSize] rootDir;
    writePage(RootDirStartBlock * PageSize, rootDir);
    return 0; // Success
}

// Sets the file position indicator for the file.
// fileHandle: The handle of the file.
// offset: Number of bytes to offset from whence.
// whence: Position from where offset is applied (0: beginning, 1: current position, 2: end of file).
// Returns 0 on success, or -1 on error.
func int fseek(byte[] fileHandle, int offset, byte whence);

// Returns the current file position indicator for the file.
// fileHandle: The handle of the file.
// Returns the current file position as a word, or 0 on error.
func word ftell(byte[] fileHandle);

// Renames a file or directory.
// oldname: Current name of the file or directory.
// newname: New name of the file or directory.
// Returns 0 on success, or -1 on error.
func int rename(const char[] oldname, const char[] newname);

func byte[] readdir(byte[] dirHandle) {
    if (dirHandle[1] == PageSize - DescriptorSize) {
        // Previous entry was the last one in that page
        // Follow the chain to the next page for this directory
        byte[PageSize] chainBlock;
        readBlock(ChainBlock, chainBlock);
        
        dirHandle[0] = chainBlock[dirHandle[0]];
        if (dirHandle[0] == 1) // that was the last page in the chain
        {
            return null;  
        }
        dirHandle[1] = 0;
    }
    
    // Read the block where the current directory entry is
    byte[PageSize] dirBlock;
    readBlock(dirHandle[0], dirBlock);
    
    // Copy the directory entry
    memcpy(_dirEntry, dirBlock + dirHandle[1], DescriptorSize);
    if (_dirEntry[StartBlockOffset] == 0)
    {
        // empty slot
        return null;
    }
        
    // Update the directory handle position for the next iteration
    dirHandle[1] += DescriptorSize;
    return _dirEntry;
}
// Closes an open directory.
// dirHandle: The handle of the directory to close.
// Returns 0 on success, or -1 on error.
func int closedir(byte[] dirHandle) {
    if (null != dirHandle)
    {
        free(dirHandle);
    }
    return 0;
}
func int mkdir(const char[] dirname) {
    byte[PageSize] dirBlock;
    byte[DescriptorSize] descriptor;
    byte[PageSize] chainBlock;
    byte[PageSize] newDirBlock;
    byte newBlock;
    char[256] fullPath;
    word i;
    
    getFullPath(fullPath, dirname);
    
    if (!isValidPath(fullPath)) {
        return -1; // Invalid path
    }
    
    readBlock(ChainBlock, chainBlock);
    // Find a free block for the new directory
    newBlock = findFreePage(chainBlock);
    if (newBlock == 0) {
        return -1; // Disk full (no available pages)
    }
    // Create a local copy of dirname to modify
    char[] localDirname = strdup(fullPath);
    // Initialize the directory descriptor
    memset(descriptor, 0, DescriptorSize);
    char[] lastSlash = strrchr(localDirname, '/');
    if (lastSlash != null) {
        strcpy((descriptor + FilenameOffset) as char[], lastSlash + 1);
        lastSlash[0] = '\0'; // Terminate parent directory string
    } else {
        strcpy((descriptor + FilenameOffset) as char[], localDirname);
    }
    descriptor[FileTypeOffset] = (FileTypeDirectory | (strlen((descriptor + FilenameOffset) as char[]) & 0x0F)) as byte;
    descriptor[StartBlockOffset] = newBlock;
    // Determine the parent directory block
    char[] parentDir = ((lastSlash != null) && (strlen(localDirname) > 0)) ? localDirname : "/";
    
    // Read the parent directory block to find an empty slot
    byte[] parentDirHandle = opendir(parentDir);
    if (parentDirHandle == null) {
        free(localDirname as byte[]);
        return -1; // Failed to open parent directory
    }
    readBlock(parentDirHandle[0], dirBlock);
    byte currentBlock = parentDirHandle[0];
    closedir(parentDirHandle);
    
    while (true) {
        for (i = 0; i < PageSize; i += DescriptorSize) {
            if (dirBlock[i + FilenameOffset] == 0) {
                memcpy(dirBlock + i, descriptor, DescriptorSize);
                writeBlock(currentBlock, dirBlock);
                // Create new empty block for the directory and update ChainBlock
                memset(newDirBlock, 0, PageSize);
                writeBlock(newBlock, newDirBlock);
                chainBlock[newBlock] = 1; // Mark as end of chain
                writeBlock(ChainBlock, chainBlock);
                free(localDirname as byte[]);
                return 0; // Success
            }
        }
        // If no empty slot found in the current block, follow the chain
        if (chainBlock[currentBlock] == 1) {
            // No more blocks in the chain, add a new block
            byte newDirBlockInChain = findFreePage(chainBlock);
            if (newDirBlockInChain == 0) {
                free(localDirname as byte[]);
                return -1; // Disk full (no available pages)
            }
            chainBlock[currentBlock] = newDirBlockInChain;
            chainBlock[newDirBlockInChain] = 1; // Mark as end of chain
            writeBlock(ChainBlock, chainBlock);
            // Initialize the new directory block
            memset(newDirBlock, 0, PageSize);
            writeBlock(newDirBlockInChain, newDirBlock);
            currentBlock = newDirBlockInChain;
            readBlock(currentBlock, dirBlock);
        } else {
            // Move to the next block in the chain
            currentBlock = chainBlock[currentBlock];
            readBlock(currentBlock, dirBlock);
        }
    }
    free(localDirname as byte[]);
    return -1; // No empty slot found
}
func byte[] opendir(const char[] dirname) {
    byte[] dirHandle = malloc(2);
    byte[PageSize] dirBlock;
    byte[PageSize] chainBlock;
    char[256] fullPath;
    char[] pathCopy;
    char[] token;
    byte currentBlock;
    bool found;
    word i;
    
    getFullPath(fullPath, dirname);
    if (!isValidPath(fullPath)) {
        free(dirHandle);
        return null; // Invalid path
    }
    
    readBlock(ChainBlock, chainBlock);
    
    if (strcmp(fullPath, "/") == 0) {
        dirHandle[0] = RootDirStartBlock;  // Root directory descriptor index
        dirHandle[1] = 0;  // Current position in directory
        return dirHandle;
    }
    
    // Split the path into components
    pathCopy = strdup(fullPath);
    token = strtok(pathCopy, "/");
    currentBlock = RootDirStartBlock;
    
    while (token != null) {
        found = false;
        readBlock(currentBlock, dirBlock);
        while (true) {
            for (i = 0; i < PageSize; i += DescriptorSize) {
                if (strncmp((dirBlock + i + FilenameOffset) as char[], token, strlen(token)) == 0 &&
                    (dirBlock[i + FileTypeOffset] & 0xF0) == FileTypeDirectory) {
                    currentBlock = dirBlock[i + StartBlockOffset];
                    found = true;
                    break;
                }
            }
            if (found || chainBlock[currentBlock] == 1) {
                break;
            }
            currentBlock = chainBlock[currentBlock];
            readBlock(currentBlock, dirBlock);
        }
        
        if (!found) {
            free(dirHandle);
            free(pathCopy as byte[]);
            return null; // Directory not found
        }
        token = strtok(null, "/");
    }
    
    dirHandle[0] = currentBlock;
    dirHandle[1] = 0;
    free(pathCopy as byte[]);
    return dirHandle;
}
func int chdir(const char[] path) {
    if (!isValidPath(path)) {
        return -1; // Invalid path
    }
    byte[] dirHandle = opendir(path);
    if (dirHandle == null) {
        return -1; // Directory not found
    }
    closedir(dirHandle);
    strcpy(_currentDirectory, path);
    return 0; // Success
}
func int rmdir(const char[] dirname) {
    byte[PageSize] dirBlock;
    byte[PageSize] chainBlock;
    byte[DescriptorSize] descriptor;
    char[256] fullPath;
    byte[] dirHandle;
    byte currentBlock;
    word i;
    
    getFullPath(fullPath, dirname);
    
    if (!isValidPath(fullPath)) {
        return -1; // Invalid path
    }
    
    // Open the directory to ensure it exists
    dirHandle = opendir(fullPath);
    if (dirHandle == null) {
        return -1; // Directory not found
    }
    
    // Check if the directory is empty
    readBlock(dirHandle[0], dirBlock);
    for (i = 0; i < PageSize; i += DescriptorSize) {
        if (dirBlock[i + FilenameOffset] != 0) {
            closedir(dirHandle);
            return -1; // Directory not empty
        }
    }
    currentBlock = dirHandle[0];
    closedir(dirHandle);
    
    // Free the blocks used by the directory
    readBlock(ChainBlock, chainBlock);
    while (currentBlock != 1) {
        byte nextBlock = chainBlock[currentBlock];
        chainBlock[currentBlock] = 0;
        currentBlock = nextBlock;
    }
    writeBlock(ChainBlock, chainBlock);
    
    // Find and clear the directory descriptor in the parent directory
    char[] parentDir = strdup(fullPath);
    char[] lastSlash = strrchr(parentDir, '/');
    if (lastSlash != null && lastSlash != parentDir) {
        lastSlash[0] = '\0'; // Terminate parent directory string
    } else {
        strcpy(parentDir, "/"); // It's a root-level directory
    }
    
    dirHandle = opendir(parentDir);
    if (dirHandle == null) {
        free(parentDir as byte[]);
        return -1; // Failed to open parent directory
    }
    
    readBlock(dirHandle[0], dirBlock);
    while (true) {
        for (i = 0; i < PageSize; i += DescriptorSize) {
            memcpy(descriptor, dirBlock + i, DescriptorSize);
            if (strncmp((descriptor + FilenameOffset) as char[], lastSlash + 1, strlen(lastSlash + 1)) == 0 &&
                (descriptor[FileTypeOffset] & 0xF0) == FileTypeDirectory) {
                memset(dirBlock + i, 0, DescriptorSize); // Clear the descriptor
                writeBlock(dirHandle[0], dirBlock);
                free(parentDir as byte[]);
                closedir(dirHandle);
                return 0; // Success
            }
        }
        // Follow the chain if no descriptor found in current block
        if (chainBlock[dirHandle[0]] == 1) {
            break; // No more blocks in the chain
        }
        dirHandle[0] = chainBlock[dirHandle[0]];
        readBlock(dirHandle[0], dirBlock);
    }
    
    free(parentDir as byte[]);
    closedir(dirHandle);
    return -1; // Directory descriptor not found
}
// Closes an open file or directory.
// fileHandle: The handle of the file or directory to close.
// Returns 0 on success, or -1 on error.
func int fclose(byte[] fileHandle) {
    if (fileHandle != null) {
        free(fileHandle);
        return 0; // Success
    }
    return -1; // Invalid handle
}

func word fwrite(const byte[] buffer, word size, word count, byte[] fileHandle) {
    byte[PageSize] fileBlock;
    byte[PageSize] chainBlock;
    byte[PageSize] dirBlock;
    word bytesToWrite = size * count;
    word bytesWritten = 0;
    word position = (fileHandle[1] << 8) | fileHandle[2];
    byte currentBlock = fileHandle[0];
    readBlock(ChainBlock, chainBlock);
    while (bytesToWrite > 0) {
        word offset = position % PageSize;
        word toWrite = (bytesToWrite < (PageSize - offset)) ? bytesToWrite : (PageSize - offset);
        readBlock(currentBlock, fileBlock);
        memcpy(fileBlock + offset, buffer + bytesWritten, toWrite);
        writeBlock(currentBlock, fileBlock);
        position += toWrite;
        bytesWritten += toWrite;
        bytesToWrite -= toWrite;
        if (bytesToWrite > 0) {
            if (chainBlock[currentBlock] == 1) {
                // Allocate a new block
                byte newBlock = findFreePage(chainBlock);
                if (newBlock == 0) {
                    return bytesWritten / size; // Disk full, return number of elements written
                }
                chainBlock[currentBlock] = newBlock;
                chainBlock[newBlock] = 1; // Mark as end of chain
                writeBlock(ChainBlock, chainBlock);
                currentBlock = newBlock;
            } else {
                currentBlock = chainBlock[currentBlock];
            }
        }
    }
    fileHandle[1] = ((position >> 8) & 0xFF) as byte;
    fileHandle[2] = (position & 0xFF) as byte;
    // Update the file size in the directory entry
    readBlock(fileHandle[0], dirBlock);
    word fileSize = (dirBlock[fileHandle[1] * DescriptorSize + FileSizeOffset] << 8) |
                    dirBlock[fileHandle[1] * DescriptorSize + FileSizeOffset + 1];
    fileSize += bytesWritten;
    dirBlock[fileHandle[1] * DescriptorSize + FileSizeOffset] = ((fileSize >> 8) & 0xFF) as byte;
    dirBlock[fileHandle[1] * DescriptorSize + FileSizeOffset + 1] = (fileSize & 0xFF) as byte;
    writeBlock(fileHandle[0], dirBlock);
    return bytesWritten / size;
}
func word fread(byte[] buffer, word size, word count, byte[] fileHandle) {
    byte[PageSize] fileBlock;
    byte[PageSize] chainBlock;
    byte currentBlock = fileHandle[0];
    word position = (fileHandle[1] << 8) | fileHandle[2];
    word bytesToRead = size * count;
    word bytesRead = 0;
    
    readBlock(ChainBlock, chainBlock);
    
    while (bytesToRead > 0) {
        word offset = position % PageSize;
        word toRead = (bytesToRead < (PageSize - offset)) ? bytesToRead : (PageSize - offset);
        
        readBlock(currentBlock, fileBlock);
        memcpy(buffer + bytesRead, fileBlock + offset, toRead);
        
        bytesToRead -= toRead;
        bytesRead += toRead;
        position += toRead;
        
        if (position % PageSize == 0) {
            if (chainBlock[currentBlock] == 1) {
                break; // End of file
            } else {
                currentBlock = chainBlock[currentBlock];
            }
        }
    }
    
    fileHandle[0] = currentBlock;
    fileHandle[1] = ((position >> 8) & 0xFF) as byte;
    fileHandle[2] = (position & 0xFF) as byte;
    return bytesRead / size;
}
func int remove(const char[] filename) {
    byte[PageSize] dirBlock;
    byte[PageSize] chainBlock;
    byte[DescriptorSize] descriptor;
    char[256] fullPath;
    byte[] dirHandle;
    byte currentBlock;
    word i;
    byte fileBlock;
    byte nextBlock;
    
    getFullPath(fullPath, filename);
    
    if (!isValidPath(fullPath)) {
        writeString("Invalid path for file: ");
        writeString(filename);
        writeString("\n");
        return -1; // Invalid path
    }
    
    // Open the directory to ensure it exists
    char[] parentDir = strdup(fullPath);
    char[] lastSlash = strrchr(parentDir, '/');
    if (lastSlash != null && lastSlash != parentDir) {
        lastSlash[0] = '\0'; // Terminate parent directory string
    } else {
        strcpy(parentDir, "/"); // It's a root-level directory
    }
    
    dirHandle = opendir(parentDir);
    if (dirHandle == null) {
        free(parentDir as byte[]);
        writeString("Failed to open parent directory: ");
        writeString(parentDir);
        writeString("\n");
        return -1; // Failed to open parent directory
    }
    
    // Locate the file descriptor
    while (true) {
        readBlock(dirHandle[0], dirBlock);
        for (i = 0; i < PageSize; i += DescriptorSize) {
            memcpy(descriptor, dirBlock + i, DescriptorSize);
            if (strncmp((descriptor + FilenameOffset) as char[], lastSlash + 1, strlen(lastSlash + 1)) == 0 &&
                (descriptor[FileTypeOffset] & 0xF0) == FileTypeFile) {
                
                fileBlock = descriptor[StartBlockOffset];
                // Clear the file descriptor
                memset(descriptor, 0, DescriptorSize); // Clearing the descriptor array itself
                memset(dirBlock + i, 0, DescriptorSize); // Clearing the block position
                
                // Verify the descriptor was actually cleared
                writeString("Cleared descriptor: ");
                printHex(descriptor, DescriptorSize);
                writeString("\n");
                
                writeBlock(dirHandle[0], dirBlock);
                
                // Free the blocks used by the file
                readBlock(ChainBlock, chainBlock);
                while (fileBlock != 1 && fileBlock != 0) {
                    nextBlock = chainBlock[fileBlock];
                    chainBlock[fileBlock] = 0;
                    writeString("Freed block: ");
                    writeHex(fileBlock);
                    writeString("\n");
                    fileBlock = nextBlock;
                }
                writeBlock(ChainBlock, chainBlock);
                
                free(parentDir as byte[]);
                closedir(dirHandle);
                writeString("Successfully deleted file: ");
                writeString(filename);
                writeString("\n");
                return 0; // Success
            }
        }
        // Follow the chain if no descriptor found in current block
        if (chainBlock[dirHandle[0]] == 1) {
            break; // No more blocks in the chain
        }
        dirHandle[0] = chainBlock[dirHandle[0]];
    }
    
    free(parentDir as byte[]);
    closedir(dirHandle);
    writeString("File descriptor not found for: ");
    writeString(filename);
    writeString("\n");
    return -1; // File descriptor not found
}

// Opens a file or directory.
// filename: Name of the file or directory to open.
// mode: Mode in which to open the file (e.g., "r" for read, "w" for write, etc.).
// Returns a file handle if successful, or null if an error occurs.
func byte[] fopen(const char[] filename, const char[] mode) {
    byte[PageSize] dirBlock;
    byte[PageSize] newDirBlock;
    byte[PageSize] chainBlock;
    byte[DescriptorSize] descriptor;
    char[256] fullPath;
    byte currentBlock;
    word i;
    char[] parentDir;
    char[] lastSlash;
    char[] fileName;
    byte[] parentDirHandle;
    byte[] fileHandle;
    byte fileBlock;
    byte nextBlock;
    byte newBlock;
    byte newDirBlockInChain;
    bool found;
    
    getFullPath(fullPath, filename);
    
    if (!isValidPath(fullPath)) {
        return null; // Invalid path
    }
    
    readBlock(ChainBlock, chainBlock);
    
    parentDir = strdup(fullPath);
    lastSlash = strrchr(parentDir, '/');
    if ((lastSlash != null) && (lastSlash != parentDir)) {
        lastSlash[0] = '\0'; // Terminate parent directory string
        fileName = lastSlash+1;
    } else {
        if (lastSlash == null)
        {
            fileName = fullPath;     // no slash
        }
        else
        {
            fileName = fullPath + 1; // / is first character
        }
        strcpy(parentDir, "/"); // It's a root-level directory (no / or first character)
    }
    writeString("\nfileName=");
    writeString(fileName);
    writeString("\nparentDir=");
    writeString(parentDir);
    writeString("\nfullPath=");
    writeString(fullPath);
    
    // Handle opening for write mode
    if (strcmp(mode, "w") == 0) {
        parentDirHandle = opendir(parentDir);
        if (parentDirHandle == null) {
            // Check if the file already exists
            while (true) {
                readBlock(parentDirHandle[0], dirBlock);
                for (i = 0; i < PageSize; i += DescriptorSize) {
                    if (  ((dirBlock[i + StartBlockOffset] & 0xF0) != 0)          // not an empty direntry
                        &&((dirBlock[i + FileTypeOffset] & 0xF0) == FileTypeFile) // file, not directory
                        && (strncmp((dirBlock + i + FilenameOffset) as char[], fileName, strlen(fileName)) == 0)
                       ) 
                    {
                        writeChar('f');
                        // Free the blocks used by the file if it already exists
                        fileBlock = dirBlock[i + StartBlockOffset];
                        while (fileBlock != 1) {
                            writeChar('g');
                            nextBlock = chainBlock[fileBlock];
                            chainBlock[fileBlock] = 0;
                            fileBlock = nextBlock;
                        }
                        // Reset the descriptor
                        dirBlock[i + StartBlockOffset] = 1; // end of chain
                        dirBlock[i + FileSizeOffset]   = 0; // file size to 0
                        dirBlock[i + FileSizeOffset+1] = 0; // file size to 0
                        
                        writeBlock(parentDirHandle[0], dirBlock);
                        writeBlock(ChainBlock, chainBlock);
                        
                        fileHandle = malloc(4);
                        fileHandle[0] = parentDirHandle[0]; // Directory block number
                        fileHandle[1] = (i / DescriptorSize) as byte; // File descriptor index
                        fileHandle[2] = 0; // Current position LSB in file
                        fileHandle[3] = 0; // Current position MSB in file
                        free(parentDir as byte[]);
                        closedir(parentDirHandle);
                        writeString("Reopened existing file: ");
                        writeString(filename);
                        writeString("\n");
                        return fileHandle; // Success
                    }
                }
                writeChar('h');
                // Follow the chain if no descriptor found in current block
                if (chainBlock[parentDirHandle[0]] == 1) {
                    writeChar('i');
                    break; // No more blocks in the chain
                }
                parentDirHandle[0] = chainBlock[parentDirHandle[0]];
                writeChar('j');
            }
            free(parentDir as byte[]);
            closedir(parentDirHandle);
            writeChar('k');
        }
        
        // Create a new file
        // Find a free block for the file
        newBlock = findFreePage(chainBlock);
        writeChar('l');
        if (newBlock == 0) {
            return null; // Disk full (no available pages)
        }
        
        // Initialize the file descriptor
        memset(descriptor, 0, DescriptorSize);
        writeChar('m');
        strcpy((descriptor + FilenameOffset) as char[], fileName);

        descriptor[FileTypeOffset] = (FileTypeFile | (strlen((descriptor + FilenameOffset) as char[]) & 0x0F)) as byte;
        descriptor[StartBlockOffset] = 1; // end of chain
        descriptor[FileSizeOffset]   = 0; // Empty file LSB
        descriptor[FileSizeOffset+1] = 0; // Empty file MSB
        
        // Read the parent directory block to find an empty slot
        parentDirHandle = opendir(parentDir);
        if (parentDirHandle == null) {
            return null; // Failed to open parent directory
        }
        writeChar('p');
        readBlock(parentDirHandle[0], dirBlock);
        currentBlock = parentDirHandle[0];
        closedir(parentDirHandle);
        
        while (true) {
            writeChar('q');
            for (i = 0; i < PageSize; i += DescriptorSize) {
                writeChar('r');
                if (dirBlock[i + FilenameOffset] == 0) {
                    writeChar('s');
                    memcpy(dirBlock + i, descriptor, DescriptorSize);
                    writeBlock(currentBlock, dirBlock);
                    chainBlock[newBlock] = 1; // Mark as end of chain
                    writeBlock(ChainBlock, chainBlock);
                    fileHandle = malloc(4);
                    fileHandle[0] = currentBlock; // Directory block number
                    fileHandle[1] = (i / DescriptorSize) as byte; // File descriptor index
                    fileHandle[2] = 0; // Current position LSB in file
                    fileHandle[3] = 0; // Current position MSB in file
                    writeString("Created new file: ");
                    writeString(filename);
                    writeString("\n");
                    return fileHandle; // Success
                }
            }
            // If no empty slot found in the current block, follow the chain
            if (chainBlock[currentBlock] == 1) {
                writeChar('t');
                // No more blocks in the chain, add a new block
                newDirBlockInChain = findFreePage(chainBlock);
                if (newDirBlockInChain == 0) {
                    return null; // Disk full (no available pages)
                }
                chainBlock[currentBlock] = newDirBlockInChain;
                chainBlock[newDirBlockInChain] = 1; // Mark as end of chain
                writeBlock(ChainBlock, chainBlock);
                // Initialize the new directory block
                memset(newDirBlock, 0, PageSize);
                writeBlock(newDirBlockInChain, newDirBlock);
                currentBlock = newDirBlockInChain;
                readBlock(currentBlock, dirBlock);
            } else {
                writeChar('u');
                // Move to the next block in the chain
                currentBlock = chainBlock[currentBlock];
                readBlock(currentBlock, dirBlock);
            }
        }
    } else 
    {
        if (strcmp(mode, "r") == 0) {
            // Handle opening for read mode
            parentDirHandle = opendir(parentDir);
            if (parentDirHandle == null) {
                return null; // File not found
            }
    
            // Locate the file descriptor
            readBlock(parentDirHandle[0], dirBlock);
            for (i = 0; i < PageSize; i += DescriptorSize) {
                if (strncmp((dirBlock + i + FilenameOffset) as char[], fileName, strlen(fileName)) == 0 &&
                    (dirBlock[i + FileTypeOffset] & 0xF0) == FileTypeFile) {
                    fileHandle = malloc(4);
                    fileHandle[0] = parentDirHandle[0]; // Directory block number
                    fileHandle[1] = (i / DescriptorSize) as byte; // File descriptor index
                    fileHandle[2] = 0; // Current position LSB in file
                    fileHandle[3] = 0; // Current position MSB in file
                    closedir(parentDirHandle);
                    return fileHandle; // Success
                }
            }
            closedir(parentDirHandle);
        }
    }
    return null; // Failed to open file
}
