// Tigger C File API Prototypes
#include "system.tc"
#include "string.tc"
#include "i2c.tc"
/*
File System Structure:
-----------------------
1. ChainLists:
   - Contains chains of blocks for files and directories that span multiple blocks.
   - Located at page 0.
2. Root Directory:
   - The starting point of the file system, storing the root directory entries.
   - Located at page 1.
   
Descriptor Record Structure (within Directory Pages):
-----------------------------------------------------
- Filename:           Offset 0, 12 bytes (null-terminated if shorter)
- File Type:          Offset 12, 1 byte (high nibble: type, low nibble: name length)
                      - 0x00: File
                      - 0x10: Directory
- Start Block:        Offset 13, 1 byte (block number where the file/directory starts)
- File Size:          Offset 14, 2 bytes (size of the file in bytes)
File Handle Structure (byte array):
-----------------------------------
   [0] - File descriptor index (byte)
   [1] - Current position in file (word, 2 bytes)
   Total: 3 bytes
   
Directory Handle Structure (byte array):
----------------------------------------
   [0] - Directory descriptor index (byte)
   [1] - Current position in directory (byte)
   Total: 2 bytes
   
Directory Entry Structure (byte array):
---------------------------------------
   [0] - Entry type (0 for file, 1 for directory) (byte)
   [1-12] - Entry name (up to 12 bytes, null-terminated if shorter)
   Total: 13 bytes
*/
const word PageSize   = 256;
const word TotalPages = 256;
const byte ChainBlock = 0;
const byte RootDirStartBlock = 1;
const byte FileTypeDirectory = 0x10;
const byte FileTypeFile = 0x00;
const byte FilenameOffset = 0;
const byte FileSizeOffset = 12;
const byte FileTypeOffset = 14;
const byte StartBlockOffset = 15;
const byte DescriptorSize = 16;
const byte DescriptorsPerBlock = PageSize / DescriptorSize;
byte[DescriptorSize] _dirEntry; // global used by readdir
char[256]            _currentDirectory;
// prototypes
func int closedir(byte[] dirHandle);
func byte[] opendir(const char[] dirname);
func byte findFreePage(byte[] chainBlock);
// Prints the contents of a buffer in hexadecimal format.
func printHex(const byte[] buffer, word length) {
    word i;
    for (i = 0; i < length; i++) {
        writeHex(buffer[i]);
        writeChar(' ');
        if ((i + 1) % 16 == 0) {
            if ((i + 1) % 64 == 0) {
                writeChar('\n');
            } else {
                writeChar(' ');
            }
        }
    }
    writeChar('\n');
}
// Debugging function to print a byte buffer
func printByteBuffer(const char[] label, byte[] buffer, word length) {
    writeString(label);
    writeString(":\n");
    printHex(buffer, length);
}
// Reads a block from EEPROM.
// blockNum: The block number to read.
// buffer: The buffer to store the read data.
func readBlock(word blockNum, byte[] buffer) {
    readPage(blockNum * PageSize, buffer);
}
// Writes a block to EEPROM.
// blockNum: The block number to write.
// buffer: The buffer containing the data to write.
func writeBlock(word blockNum, const byte[] buffer) {
    writePage(blockNum * PageSize, buffer);
}
// Finds a free page in the ChainList.
// Returns the index of the free page or 0 if no free page is found.
func byte findFreePage(byte[] chainBlock) {
    word i;
    for (i = 2; i < TotalPages; i++) {
        if (chainBlock[i] == 0) {
            return i as byte;
        }
    }
    return 0; // No free page found
}
// Validates a path for correct length and valid characters.
// Returns true if the path is valid, false otherwise.
func bool isValidPath(const char[] path) {
    word i;
    word len = strlen(path);
    if (len == 0 || len > 255) {
        return false; // Invalid length
    }
    for (i = 0; i < len; i++) {
        if (!(isalnum(path[i]) || path[i] == '.' || path[i] == '/')) {
            return false; // Invalid character
        }
    }
    return true;
}
func resolveRelativePath(char[] dest, const char[] path) {
    // Handle the root path separately
    if (strcmp(path, "/") == 0) {
        strcpy(dest, "/");
        return;
    }

    char[] token;
    char[] temp = malloc(256) as char[];
    strcpy(temp, path);
    token = strtok(temp, "/");

    while (token != null) {
        if (strcmp(token, ".") == 0) {
            // Skip
        } else
        {
            if (strcmp(token, "..") == 0) {
            // Remove last directory in dest
            char[] lastSlash = strrchr(dest, '/');
            if (lastSlash != null && lastSlash != dest) {
                lastSlash[0] = '\0';
            } else {
                // Avoid removing the root slash
                dest[1] = '\0';
            }
            } else {
                if (strlen(dest) > 1) {
                    strcat(dest, "/");
                }
                strcat(dest, token);
            }
        }
        token = strtok(null, "/");
    }

    free(temp as byte[]);
}

func getFullPath(char[] dest, const char[] path) {
    if (_currentDirectory[0] == '\0') {
        strcpy(_currentDirectory, "/"); // initialize before first use
    }
    if (path[0] == '/') {
        // Absolute path
        strcpy(dest, path);
    } else {
        // Relative path
        strcpy(dest, _currentDirectory);
        if (dest[strlen(dest) - 1] != '/') {
            strcat(dest, "/");
        }
        strcat(dest, path);
    }
    // Resolve relative components like '.' and '..'
    char[] resolvedPath = malloc(256) as char[];
    resolveRelativePath(resolvedPath, dest);
    strcpy(dest, resolvedPath);
    free(resolvedPath as byte[]);

    // Ensure the path starts with a root '/'
    if (dest[0] != '/') {
        char[] temp = malloc(256) as char[];
        strcpy(temp, dest);
        strcpy(dest, "/");
        strcat(dest, temp);
        free(temp as byte[]);
    }
}

// Formats the drive, initializing the file system.
// Returns 0 on success, or -1 on error.
func int format() {
    // Initialize global block chain page (no chains yet, 0 and 1 reserved)
    byte[PageSize] blockChainPage;
    blockChainPage[0] = 1;
    blockChainPage[1] = 1;
    writePage(ChainBlock * PageSize, blockChainPage);
    // Initialize the root directory (empty initially)
    byte[PageSize] rootDir;
    writePage(RootDirStartBlock * PageSize, rootDir);
    return 0; // Success
}

// Reads data from a file.
// buffer: Buffer to store the read data.
// size: Size of each element to read.
// count: Number of elements to read.
// fileHandle: The handle of the file to read from.
// Returns the number of elements successfully read.
func word fread(byte[] buffer, word size, word count, byte[] fileHandle);
// Writes data to a file.
// buffer: Buffer containing the data to write.
// size: Size of each element to write.
// count: Number of elements to write.
// fileHandle: The handle of the file to write to.
// Returns the number of elements successfully written.
func word fwrite(const byte[] buffer, word size, word count, byte[] fileHandle);
// Sets the file position indicator for the file.
// fileHandle: The handle of the file.
// offset: Number of bytes to offset from whence.
// whence: Position from where offset is applied (0: beginning, 1: current position, 2: end of file).
// Returns 0 on success, or -1 on error.
func int fseek(byte[] fileHandle, int offset, byte whence);
// Returns the current file position indicator for the file.
// fileHandle: The handle of the file.
// Returns the current file position as a word, or 0 on error.
func word ftell(byte[] fileHandle);
// Deletes a file.
// filename: Name of the file to delete.
// Returns 0 on success, or -1 on error.
func int remove(const char[] filename);
// Renames a file or directory.
// oldname: Current name of the file or directory.
// newname: New name of the file or directory.
// Returns 0 on success, or -1 on error.
func int rename(const char[] oldname, const char[] newname);

func byte[] readdir(byte[] dirHandle) {
    if (dirHandle[1] == PageSize - DescriptorSize) {
        // Previous entry was the last one in that page
        // Follow the chain to the next page for this directory
        byte[PageSize] chainBlock;
        readBlock(ChainBlock, chainBlock);
        
        dirHandle[0] = chainBlock[dirHandle[0]];
        if (dirHandle[0] == 1) // that was the last page in the chain
        {
            return null;  
        }
        dirHandle[1] = 0;
    }
    
    // Read the block where the current directory entry is
    byte[PageSize] dirBlock;
    readBlock(dirHandle[0], dirBlock);
    
    // Copy the directory entry
    memcpy(_dirEntry, dirBlock + dirHandle[1], DescriptorSize);
    if (_dirEntry[StartBlockOffset] == 0)
    {
        // empty slot
        return null;
    }
        
    // Update the directory handle position for the next iteration
    dirHandle[1] += DescriptorSize;
    return _dirEntry;
}
// Closes an open directory.
// dirHandle: The handle of the directory to close.
// Returns 0 on success, or -1 on error.
func int closedir(byte[] dirHandle) {
    if (null != dirHandle)
    {
        free(dirHandle);
    }
    return 0;
}

func int mkdir(const char[] dirname) {
    byte[PageSize] dirBlock;
    byte[DescriptorSize] descriptor;
    byte[PageSize] chainBlock;
    byte[PageSize] newDirBlock;
    byte newBlock;
    char[256] fullPath;
    word i;
    
    getFullPath(fullPath, dirname);
    
    if (!isValidPath(fullPath)) {
        return -1; // Invalid path
    }
    
    readBlock(ChainBlock, chainBlock);
    // Find a free block for the new directory
    newBlock = findFreePage(chainBlock);
    if (newBlock == 0) {
        return -1; // Disk full (no available pages)
    }
    // Create a local copy of dirname to modify
    char[] localDirname = strdup(fullPath);
    // Initialize the directory descriptor
    memset(descriptor, 0, DescriptorSize);
    char[] lastSlash = strrchr(localDirname, '/');
    if (lastSlash != null) {
        strcpy((descriptor + FilenameOffset) as char[], lastSlash + 1);
        lastSlash[0] = '\0'; // Terminate parent directory string
    } else {
        strcpy((descriptor + FilenameOffset) as char[], localDirname);
    }
    descriptor[FileTypeOffset] = (FileTypeDirectory | (strlen((descriptor + FilenameOffset) as char[]) & 0x0F)) as byte;
    descriptor[StartBlockOffset] = newBlock;
    // Determine the parent directory block
    char[] parentDir = ((lastSlash != null) && (strlen(localDirname) > 0)) ? localDirname : "/";
    
    // Read the parent directory block to find an empty slot
    byte[] parentDirHandle = opendir(parentDir);
    if (parentDirHandle == null) {
        free(localDirname as byte[]);
        return -1; // Failed to open parent directory
    }
    readBlock(parentDirHandle[0], dirBlock);
    byte currentBlock = parentDirHandle[0];
    closedir(parentDirHandle);
    
    while (true) {
        for (i = 0; i < PageSize; i += DescriptorSize) {
            if (dirBlock[i + FilenameOffset] == 0) {
                memcpy(dirBlock + i, descriptor, DescriptorSize);
                writeBlock(currentBlock, dirBlock);
                // Create new empty block for the directory and update ChainBlock
                memset(newDirBlock, 0, PageSize);
                writeBlock(newBlock, newDirBlock);
                chainBlock[newBlock] = 1; // Mark as end of chain
                writeBlock(ChainBlock, chainBlock);
                free(localDirname as byte[]);
                return 0; // Success
            }
        }
        // If no empty slot found in the current block, follow the chain
        if (chainBlock[currentBlock] == 1) {
            // No more blocks in the chain, add a new block
            byte newDirBlockInChain = findFreePage(chainBlock);
            if (newDirBlockInChain == 0) {
                free(localDirname as byte[]);
                return -1; // Disk full (no available pages)
            }
            chainBlock[currentBlock] = newDirBlockInChain;
            chainBlock[newDirBlockInChain] = 1; // Mark as end of chain
            writeBlock(ChainBlock, chainBlock);
            // Initialize the new directory block
            memset(newDirBlock, 0, PageSize);
            writeBlock(newDirBlockInChain, newDirBlock);
            currentBlock = newDirBlockInChain;
            readBlock(currentBlock, dirBlock);
        } else {
            // Move to the next block in the chain
            currentBlock = chainBlock[currentBlock];
            readBlock(currentBlock, dirBlock);
        }
    }
    free(localDirname as byte[]);
    return -1; // No empty slot found
}

func byte[] opendir(const char[] dirname) {
    byte[] dirHandle = malloc(2);
    byte[PageSize] dirBlock;
    byte[PageSize] chainBlock;
    char[256] fullPath;
    char[] pathCopy;
    char[] token;
    byte currentBlock;
    bool found;
    word i;
    
    getFullPath(fullPath, dirname);

    if (!isValidPath(fullPath)) {
        free(dirHandle);
        return null; // Invalid path
    }
    
    readBlock(ChainBlock, chainBlock);
    
    if (strcmp(fullPath, "/") == 0) {
        dirHandle[0] = RootDirStartBlock;  // Root directory descriptor index
        dirHandle[1] = 0;  // Current position in directory
        return dirHandle;
    }
    
    // Split the path into components
    pathCopy = strdup(fullPath);
    token = strtok(pathCopy, "/");
    currentBlock = RootDirStartBlock;
    
    while (token != null) {
        found = false;
        readBlock(currentBlock, dirBlock);
        while (true) {
            for (i = 0; i < PageSize; i += DescriptorSize) {
                if (strncmp((dirBlock + i + FilenameOffset) as char[], token, strlen(token)) == 0 &&
                    (dirBlock[i + FileTypeOffset] & 0xF0) == FileTypeDirectory) {
                    currentBlock = dirBlock[i + StartBlockOffset];
                    found = true;
                    break;
                }
            }
            if (found || chainBlock[currentBlock] == 1) {
                break;
            }
            currentBlock = chainBlock[currentBlock];
            readBlock(currentBlock, dirBlock);
        }
        
        if (!found) {
            free(dirHandle);
            free(pathCopy as byte[]);
            return null; // Directory not found
        }
        token = strtok(null, "/");
    }
    
    dirHandle[0] = currentBlock;
    dirHandle[1] = 0;
    free(pathCopy as byte[]);
    return dirHandle;
}

func int chdir(const char[] path) {
    if (!isValidPath(path)) {
        return -1; // Invalid path
    }
    byte[] dirHandle = opendir(path);
    if (dirHandle == null) {
        return -1; // Directory not found
    }
    closedir(dirHandle);
    strcpy(_currentDirectory, path);
    return 0; // Success
}

func int rmdir(const char[] dirname) {
    byte[PageSize] dirBlock;
    byte[PageSize] chainBlock;
    byte[DescriptorSize] descriptor;
    char[256] fullPath;
    byte[] dirHandle;
    byte currentBlock;
    word i;
    
    getFullPath(fullPath, dirname);
    
    if (!isValidPath(fullPath)) {
        return -1; // Invalid path
    }
    
    // Open the directory to ensure it exists
    dirHandle = opendir(fullPath);
    if (dirHandle == null) {
        return -1; // Directory not found
    }
    
    // Check if the directory is empty
    readBlock(dirHandle[0], dirBlock);
    for (i = 0; i < PageSize; i += DescriptorSize) {
        if (dirBlock[i + FilenameOffset] != 0) {
            closedir(dirHandle);
            return -1; // Directory not empty
        }
    }
    currentBlock = dirHandle[0];
    closedir(dirHandle);
    
    // Free the blocks used by the directory
    readBlock(ChainBlock, chainBlock);
    while (currentBlock != 1) {
        byte nextBlock = chainBlock[currentBlock];
        chainBlock[currentBlock] = 0;
        currentBlock = nextBlock;
    }
    writeBlock(ChainBlock, chainBlock);
    
    // Find and clear the directory descriptor in the parent directory
    char[] parentDir = strdup(fullPath);
    char[] lastSlash = strrchr(parentDir, '/');
    if (lastSlash != null && lastSlash != parentDir) {
        lastSlash[0] = '\0'; // Terminate parent directory string
    } else {
        strcpy(parentDir, "/"); // It's a root-level directory
    }
    
    dirHandle = opendir(parentDir);
    if (dirHandle == null) {
        free(parentDir as byte[]);
        return -1; // Failed to open parent directory
    }
    
    readBlock(dirHandle[0], dirBlock);
    while (true) {
        for (i = 0; i < PageSize; i += DescriptorSize) {
            memcpy(descriptor, dirBlock + i, DescriptorSize);
            if (strncmp((descriptor + FilenameOffset) as char[], lastSlash + 1, strlen(lastSlash + 1)) == 0 &&
                (descriptor[FileTypeOffset] & 0xF0) == FileTypeDirectory) {
                memset(dirBlock + i, 0, DescriptorSize); // Clear the descriptor
                writeBlock(dirHandle[0], dirBlock);
                free(parentDir as byte[]);
                closedir(dirHandle);
                return 0; // Success
            }
        }
        // Follow the chain if no descriptor found in current block
        if (chainBlock[dirHandle[0]] == 1) {
            break; // No more blocks in the chain
        }
        dirHandle[0] = chainBlock[dirHandle[0]];
        readBlock(dirHandle[0], dirBlock);
    }
    
    free(parentDir as byte[]);
    closedir(dirHandle);
    return -1; // Directory descriptor not found
}

// Opens a file or directory.
// filename: Name of the file or directory to open.
// mode: Mode in which to open the file (e.g., "r" for read, "w" for write, etc.).
// Returns a file handle if successful, or null if an error occurs.
func byte[] fopen(const char[] filename, const char[] mode) {
    byte[PageSize] dirBlock;
    byte[PageSize] chainBlock;
    byte[DescriptorSize] descriptor;
    char[256] fullPath;
    byte currentBlock;
    word i;
    
    getFullPath(fullPath, filename);
    
    if (!isValidPath(fullPath)) {
        return null; // Invalid path
    }
    
    readBlock(ChainBlock, chainBlock);
    
    // Handle opening for write mode
    if (strcmp(mode, "w") == 0) {
        // Check if the file already exists
        byte[] parentDirHandle = opendir(fullPath);
        if (parentDirHandle != null) {
            closedir(parentDirHandle);
            return null; // File already exists
        }
        
        // Create a new file
        // Find a free block for the file
        byte newBlock = findFreePage(chainBlock);
        if (newBlock == 0) {
            return null; // Disk full (no available pages)
        }
        
        // Initialize the file descriptor
        memset(descriptor, 0, DescriptorSize);
        char[] lastSlash = strrchr(fullPath, '/');
        if (lastSlash != null) {
            strcpy((descriptor + FilenameOffset) as char[], lastSlash + 1);
            lastSlash[0] = '\0'; // Terminate parent directory string
        } else {
            strcpy((descriptor + FilenameOffset) as char[], fullPath);
        }
        descriptor[FileTypeOffset] = (FileTypeFile | (strlen((descriptor + FilenameOffset) as char[]) & 0x0F)) as byte;
        descriptor[StartBlockOffset] = newBlock;
        descriptor[FileSizeOffset] = 0; // Empty file
        
        // Determine the parent directory block
        char[] parentDir = ((lastSlash != null) && (strlen(fullPath) > 0)) ? fullPath : "/";
        
        // Read the parent directory block to find an empty slot
        parentDirHandle = opendir(parentDir);
        if (parentDirHandle == null) {
            return null; // Failed to open parent directory
        }
        readBlock(parentDirHandle[0], dirBlock);
        byte currentBlock = parentDirHandle[0];
        closedir(parentDirHandle);
        
        while (true) {
            for (i = 0; i < PageSize; i += DescriptorSize) {
                if (dirBlock[i + FilenameOffset] == 0) {
                    memcpy(dirBlock + i, descriptor, DescriptorSize);
                    writeBlock(currentBlock, dirBlock);
                    chainBlock[newBlock] = 1; // Mark as end of chain
                    writeBlock(ChainBlock, chainBlock);
                    byte[] fileHandle = malloc(3);
                    fileHandle[0] = (i / DescriptorSize) as byte; // File descriptor index
                    fileHandle[1] = 0; // Current position in file
                    return fileHandle; // Success
                }
            }
            // If no empty slot found in the current block, follow the chain
            if (chainBlock[currentBlock] == 1) {
                // No more blocks in the chain, add a new block
                byte newDirBlockInChain = findFreePage(chainBlock);
                if (newDirBlockInChain == 0) {
                    return null; // Disk full (no available pages)
                }
                chainBlock[currentBlock] = newDirBlockInChain;
                chainBlock[newDirBlockInChain] = 1; // Mark as end of chain
                writeBlock(ChainBlock, chainBlock);
                // Initialize the new directory block
                memset(newDirBlock, 0, PageSize);
                writeBlock(newDirBlockInChain, newDirBlock);
                currentBlock = newDirBlockInChain;
                readBlock(currentBlock, dirBlock);
            } else {
                // Move to the next block in the chain
                currentBlock = chainBlock[currentBlock];
                readBlock(currentBlock, dirBlock);
            }
        }
    } else if (strcmp(mode, "r") == 0) {
        // Handle opening for read mode
        byte[] parentDirHandle = opendir(fullPath);
        if (parentDirHandle == null) {
            return null; // File not found
        }
        
        // Locate the file descriptor
        readBlock(parentDirHandle[0], dirBlock);
        for (i = 0; i < PageSize; i += DescriptorSize) {
            if (strncmp((dirBlock + i + FilenameOffset) as char[], fullPath, strlen(fullPath)) == 0 &&
                (dirBlock[i + FileTypeOffset] & 0xF0) == FileTypeFile) {
                byte[] fileHandle = malloc(3);
                fileHandle[0] = (i / DescriptorSize) as byte; // File descriptor index
                fileHandle[1] = 0; // Current position in file
                closedir(parentDirHandle);
                return fileHandle; // Success
            }
        }
        closedir(parentDirHandle);
    }
    
    return null; // Failed to open file
}

// Closes an open file or directory.
// fileHandle: The handle of the file or directory to close.
// Returns 0 on success, or -1 on error.
func int fclose(byte[] fileHandle) {
    if (fileHandle != null) {
        free(fileHandle);
        return 0; // Success
    }
    return -1; // Invalid handle
}

