// Tigger C File API Prototypes
#include "system.tc"
#include "string.tc"
#include "i2c.tc"
/*
File System Structure:
-----------------------
1. ChainLists:
   - Contains chains of blocks for files and directories that span multiple blocks.
   - Located at page 0.
2. Root Directory:
   - The starting point of the file system, storing the root directory entries.
   - Located at page 1.
   
Descriptor Record Structure (within Directory Pages):
-----------------------------------------------------
- Filename:           Offset 0, 12 bytes (null-terminated if shorter)
- File Type:          Offset 12, 1 byte (high nibble: type, low nibble: name length)
                      - 0x00: File
                      - 0x10: Directory
- Start Block:        Offset 13, 1 byte (block number where the file/directory starts)
- File Size:          Offset 14, 2 bytes (size of the file in bytes)
File Handle Structure (byte array):
-----------------------------------
   [0] - File descriptor index (byte)
   [1] - Current position in file (word, 2 bytes)
   Total: 3 bytes
   
Directory Handle Structure (byte array):
----------------------------------------
   [0] - Directory descriptor index (byte)
   [1] - Current position in directory (byte)
   Total: 2 bytes
   
Directory Entry Structure (byte array):
---------------------------------------
   [0] - Entry type (0 for file, 1 for directory) (byte)
   [1-12] - Entry name (up to 12 bytes, null-terminated if shorter)
   Total: 13 bytes
*/
const word PageSize   = 256;
const word TotalPages = 256;
const byte ChainBlock = 0;
const byte RootDirStartBlock = 1;
const byte FileTypeDirectory = 0x10;
const byte FileTypeFile = 0x00;
const byte FilenameOffset = 0;
const byte FileSizeOffset = 12;
const byte FileTypeOffset = 14;
const byte StartBlockOffset = 15;
const byte DescriptorSize = 16;
const byte DescriptorsPerBlock = PageSize / DescriptorSize;
byte[DescriptorSize] _dirEntry; // global used by readdir

// prototypes
func int closedir(byte[] dirHandle);
func byte[] opendir(const char[] dirname);
func byte findFreePage(byte[] chainBlock);

// Prints the contents of a buffer in hexadecimal format.
func printHex(const byte[] buffer, word length) {
    for (word i = 0; i < length; i++) {
        writeHex(buffer[i]);
        writeChar(' ');
        if ((i + 1) % 16 == 0) {
            if ((i + 1) % 64 == 0) {
                writeChar('\n');
            } else {
                writeChar(' ');
            }
        }
    }
    writeChar('\n');
}

// Debugging function to print a byte buffer
func printByteBuffer(const char[] label, byte[] buffer, word length) {
    writeString(label);
    writeString(":\n");
    printHex(buffer, length);
}

// Reads a block from EEPROM.
// blockNum: The block number to read.
// buffer: The buffer to store the read data.
func readBlock(word blockNum, byte[] buffer) {
    readPage(blockNum * PageSize, buffer);
}

// Writes a block to EEPROM.
// blockNum: The block number to write.
// buffer: The buffer containing the data to write.
func writeBlock(word blockNum, const byte[] buffer) {
    writePage(blockNum * PageSize, buffer);
}

// Finds a free page in the ChainList.
// Returns the index of the free page or 0 if no free page is found.
func byte findFreePage(byte[] chainBlock) {
    word i;
    for (i = 2; i < TotalPages; i++) {
        if (chainBlock[i] == 0) {
            return i as byte;
        }
    }
    return 0; // No free page found
}

// Validates a path for correct length and valid characters.
// Returns true if the path is valid, false otherwise.
func bool isValidPath(const char[] path) {
    word len = strlen(path);
    if (len == 0 || len > 255) {
        return false; // Invalid length
    }
    for (word i = 0; i < len; i++) {
        if (!(isalnum(path[i]) || path[i] == '.' || path[i] == '/')) {
            return false; // Invalid character
        }
    }
    return true;
}

// Formats the drive, initializing the file system.
// Returns 0 on success, or -1 on error.
func int format() {
    // Initialize global block chain page (no chains yet, 0 and 1 reserved)
    byte[PageSize] blockChainPage;
    blockChainPage[0] = 1;
    blockChainPage[1] = 1;
    writePage(ChainBlock * PageSize, blockChainPage);
    // Initialize the root directory (empty initially)
    byte[PageSize] rootDir;
    writePage(RootDirStartBlock * PageSize, rootDir);
    return 0; // Success
}

// Opens a file or directory.
// filename: Name of the file or directory to open.
// mode: Mode in which to open the file (e.g., "r" for read, "w" for write, etc.).
// Returns a file handle if successful, or null if an error occurs.
func byte[] fopen(const char[] filename, const char[] mode);

// Closes an open file or directory.
// fileHandle: The handle of the file or directory to close.
// Returns 0 on success, or -1 on error.
func int fclose(byte[] fileHandle);

// Reads data from a file.
// buffer: Buffer to store the read data.
// size: Size of each element to read.
// count: Number of elements to read.
// fileHandle: The handle of the file to read from.
// Returns the number of elements successfully read.
func word fread(byte[] buffer, word size, word count, byte[] fileHandle);

// Writes data to a file.
// buffer: Buffer containing the data to write.
// size: Size of each element to write.
// count: Number of elements to write.
// fileHandle: The handle of the file to write to.
// Returns the number of elements successfully written.
func word fwrite(const byte[] buffer, word size, word count, byte[] fileHandle);

// Sets the file position indicator for the file.
// fileHandle: The handle of the file.
// offset: Number of bytes to offset from whence.
// whence: Position from where offset is applied (0: beginning, 1: current position, 2: end of file).
// Returns 0 on success, or -1 on error.
func int fseek(byte[] fileHandle, int offset, byte whence);

// Returns the current file position indicator for the file.
// fileHandle: The handle of the file.
// Returns the current file position as a word, or 0 on error.
func word ftell(byte[] fileHandle);

// Deletes a file.
// filename: Name of the file to delete.
// Returns 0 on success, or -1 on error.
func int remove(const char[] filename);

// Renames a file or directory.
// oldname: Current name of the file or directory.
// newname: New name of the file or directory.
// Returns 0 on success, or -1 on error.
func int rename(const char[] oldname, const char[] newname);

// Removes a directory.
// dirname: Name of the directory to remove.
// Returns 0 on success, or -1 on error.
func int rmdir(const char[] dirname) {
    word i;
    byte[PageSize] dirBlock;
    byte[DescriptorSize] descriptor;
    
    if (!isValidPath(dirname)) {
        return -1; // Invalid path
    }
    
    // Read the root directory block to find the directory descriptor
    readBlock(RootDirStartBlock, dirBlock);
    for (i = 0; i < PageSize; i += DescriptorSize) {
        memcpy(descriptor, dirBlock + i, DescriptorSize);
        if (strncmp((descriptor + FilenameOffset) as char[], dirname, strlen(dirname)) == 0 &&
            (descriptor[FileTypeOffset] & 0xF0) == FileTypeDirectory) {
            memset(dirBlock + i, 0, DescriptorSize); // Clear the descriptor
            writeBlock(RootDirStartBlock, dirBlock);
            return 0; // Success
        }
    }
    return -1; // Directory not found
}

func byte[] readdir(byte[] dirHandle) {
    if (dirHandle[1] == PageSize - DescriptorSize) {
        // Previous entry was the last one in that page
        // Follow the chain to the next page for this directory
        byte[PageSize] chainBlock;
        readBlock(ChainBlock, chainBlock);
        
        dirHandle[0] = chainBlock[dirHandle[0]];
        if (dirHandle[0] == 1) // that was the last page in the chain
        {
            return null;  
        }
        dirHandle[1] = 0;
    }
    
    // Read the block where the current directory entry is
    byte[PageSize] dirBlock;
    readBlock(dirHandle[0], dirBlock);
    
    // Copy the directory entry
    memcpy(_dirEntry, dirBlock + dirHandle[1], DescriptorSize);
    if (_dirEntry[StartBlockOffset] == 0)
    {
        // empty slot
        return null;
    }
        
    // Update the directory handle position for the next iteration
    dirHandle[1] += DescriptorSize;
    return _dirEntry;
}

// Closes an open directory.
// dirHandle: The handle of the directory to close.
// Returns 0 on success, or -1 on error.
func int closedir(byte[] dirHandle) {
    if (null != dirHandle)
    {
        free(dirHandle);
    }
    return 0;
}

func int mkdir(const char[] dirname) {
    byte[PageSize] dirBlock;
    byte[DescriptorSize] descriptor;
    byte[PageSize] chainBlock;
    byte[PageSize] newDirBlock;
    byte newBlock;
    word i;
    
    if (!isValidPath(dirname)) {
        return -1; // Invalid path
    }
    
    readBlock(ChainBlock, chainBlock);
    // Find a free block for the new directory
    newBlock = findFreePage(chainBlock);
    if (newBlock == 0) {
        return -1; // Disk full (no available pages)
    }
    // Create a local copy of dirname to modify
    char[] localDirname = strdup(dirname);
    // Initialize the directory descriptor
    memset(descriptor, 0, DescriptorSize);
    char[] lastSlash = strrchr(localDirname, '/');
    if (lastSlash != null) {
        strcpy((descriptor + FilenameOffset) as char[], lastSlash + 1);
        lastSlash[0] = '\0'; // Terminate parent directory string
    } else {
        strcpy((descriptor + FilenameOffset) as char[], localDirname);
    }
    descriptor[FileTypeOffset] = (FileTypeDirectory | (strlen((descriptor + FilenameOffset) as char[]) & 0x0F)) as byte;
    descriptor[StartBlockOffset] = newBlock;
    // Determine the parent directory block
    char[] parentDir = (lastSlash != null) ? localDirname : "/";
    // Read the parent directory block to find an empty slot
    byte[] parentDirHandle = opendir(parentDir);
    if (parentDirHandle == null) {
        free(localDirname as byte[]);
        return -1; // Failed to open parent directory
    }
    readBlock(parentDirHandle[0], dirBlock);
    byte currentBlock = parentDirHandle[0];
    closedir(parentDirHandle);
    
    while (true) {
        for (i = 0; i < PageSize; i += DescriptorSize) {
            if (dirBlock[i + FilenameOffset] == 0) {
                memcpy(dirBlock + i, descriptor, DescriptorSize);
                writeBlock(currentBlock, dirBlock);
                // Create new empty block for the directory and update ChainBlock
                memset(newDirBlock, 0, PageSize);
                writeBlock(newBlock, newDirBlock);
                chainBlock[newBlock] = 1; // Mark as end of chain
                writeBlock(ChainBlock, chainBlock);
                free(localDirname as byte[]);
                return 0; // Success
            }
        }
        // If no empty slot found in the current block, follow the chain
        if (chainBlock[currentBlock] == 1) {
            // No more blocks in the chain, add a new block
            byte newDirBlockInChain = findFreePage(chainBlock);
            if (newDirBlockInChain == 0) {
                free(localDirname as byte[]);
                return -1; // Disk full (no available pages)
            }
            chainBlock[currentBlock] = newDirBlockInChain;
            chainBlock[newDirBlockInChain] = 1; // Mark as end of chain
            writeBlock(ChainBlock, chainBlock);
            // Initialize the new directory block
            memset(newDirBlock, 0, PageSize);
            writeBlock(newDirBlockInChain, newDirBlock);
            currentBlock = newDirBlockInChain;
            readBlock(currentBlock, dirBlock);
        } else {
            // Move to the next block in the chain
            currentBlock = chainBlock[currentBlock];
            readBlock(currentBlock, dirBlock);
        }
    }
    free(localDirname as byte[]);
    return -1; // No empty slot found
}

func byte[] opendir(const char[] dirname) {
    byte[] dirHandle = malloc(2);
    byte[PageSize] dirBlock;
    byte[PageSize] chainBlock;
    char[] pathCopy;
    char[] token;
    byte currentBlock;
    bool found;
    word i;
    
    if (!isValidPath(dirname)) {
        free(dirHandle);
        return null; // Invalid path
    }
    
    readBlock(ChainBlock, chainBlock);
    
    if (strcmp(dirname, "/") == 0) {
        dirHandle[0] = RootDirStartBlock;  // Root directory descriptor index
        dirHandle[1] = 0;  // Current position in directory
        return dirHandle;
    }
    
    // Split the path into components
    pathCopy     = strdup(dirname);
    token        = strtok(pathCopy, "/");
    currentBlock = RootDirStartBlock;
    
    while (token != null) {
        found = false;
        readBlock(currentBlock, dirBlock);
        while (true) {
            for (i = 0; i < PageSize; i += DescriptorSize) {
                if (strncmp((dirBlock + i + FilenameOffset) as char[], token, strlen(token)) == 0 &&
                    (dirBlock[i + FileTypeOffset] & 0xF0) == FileTypeDirectory) {
                    currentBlock = dirBlock[i + StartBlockOffset];
                    found = true;
                    break;
                }
            }
            if (found || chainBlock[currentBlock] == 1) {
                break;
            }
            currentBlock = chainBlock[currentBlock];
            readBlock(currentBlock, dirBlock);
        }
        
        if (!found) {
            free(dirHandle);
            free(pathCopy as byte[]);
            return null; // Directory not found
        }
        token = strtok(null, "/");
    }
    
    dirHandle[0] = currentBlock;
    dirHandle[1] = 0;
    free(pathCopy as byte[]);
    return dirHandle;
}

