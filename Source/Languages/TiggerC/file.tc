// Tigger C File API Prototypes
#include "system.tc"
#include "string.tc"
#include "i2c.tc"

/*
File System Structure:
-----------------------
1. FAT (File Allocation Table):
   - Used to keep track of the allocation status of blocks.
   - Located at FATStartBlock and spans FATBlocks blocks.

2. Directory Blocks:
   - Store metadata for files and directories directly within directory blocks.
   - Each entry includes filename, file type, start block, and other attributes.

3. ChainBlock:
   - Contains chains of blocks for files that span multiple blocks.
   - Located at ChainBlock.

4. Root Directory:
   - The starting point of the file system, storing the root directory entries.
   - Located at RootDirStartBlock.
   
   
 File Handle Structure (byte array):
   [0] - File descriptor index (byte)
   [1] - Current position in file (word, 2 bytes)
   Total: 3 bytes
 
 Directory Handle Structure (byte array):
   [0] - Directory descriptor index (byte)
   [1] - Current position in directory (byte)
   Total: 2 bytes
 
 Directory Entry Structure (byte array):
   [0] - Entry type (0 for file, 1 for directory) (byte)
   [1-12] - Entry name (up to 12 bytes, null-terminated if shorter)
   Total: 13 bytes
   
*/

// Constants
const word PageSize = 256;
const byte FATStartBlock = 1;
const byte FATBlocks = 2;
const byte ChainBlock = 3;
const byte RootDirStartBlock = 4;
const byte FileTypeDirectory = 0x10;
const byte FileTypeFile = 0x00;
const byte FilenameOffset = 0;
const byte FileSizeOffset = 12;
const byte FileTypeOffset = 14;
const byte StartBlockOffset = 15;
const byte DescriptorSize = 16;
const byte DescriptorsPerBlock = PageSize / DescriptorSize;

// Prints the contents of a buffer in hexadecimal format.
func printHex(const byte[] buffer, word length) {
    for (word i = 0; i < length; i++) {
        writeHex(buffer[i]);
        writeChar(' ');
        if ((i + 1) % 16 == 0) {
            if ((i + 1) % 32 == 0) {
                writeChar('\n');
            } else {
                writeChar(' ');
            }
        }
    }
    writeChar('\n');
}

// Debugging function to print a byte buffer
func printByteBuffer(const char[] label, byte[] buffer, byte length) {
    writeString(label);
    writeString(": ");
    for (byte i = 0; i < length; i++) {
        writeHex(buffer[i]);
        writeString(" ");
    }
    writeString("\n");
}

 Reads a block from EEPROM.
// blockNum: The block number to read.
// buffer: The buffer to store the read data.
func readBlock(word blockNum, byte[] buffer) {
    readPage(blockNum * PageSize, buffer);
}

// Writes a block to EEPROM.
// blockNum: The block number to write.
// buffer: The buffer containing the data to write.
func writeBlock(word blockNum, const byte[] buffer) {
    writePage(blockNum * PageSize, buffer);
}

// Formats the drive, initializing the file system.
// Returns 0 on success, or -1 on error.
func int format() {
    word i;
    // Initialize FAT (all blocks free)
    byte[PageSize] fatBlock;
    for (i = FATStartBlock; i < FATStartBlock + FATBlocks; i++) {
        writePage(i * PageSize, fatBlock);
    }
    // Initialize global block chain page (no chains yet)
    byte[PageSize] blockChainPage;
    writePage(ChainBlock * PageSize, blockChainPage);
    // Initialize the root directory (empty initially)
    byte[PageSize] rootDir;
    for (i = 0; i < PageSize; i++) {
        rootDir[i] = 0;
    }
    writePage(RootDirStartBlock * PageSize, rootDir);
    return 0; // Success
}

// Opens a file or directory.
// filename: Name of the file or directory to open.
// mode: Mode in which to open the file (e.g., "r" for read, "w" for write, etc.).
// Returns a file handle if successful, or null if an error occurs.
func byte[] fopen(const char[] filename, const char[] mode);

// Closes an open file or directory.
// fileHandle: The handle of the file or directory to close.
// Returns 0 on success, or -1 on error.
func int fclose(byte[] fileHandle);

// Reads data from a file.
// buffer: Buffer to store the read data.
// size: Size of each element to read.
// count: Number of elements to read.
// fileHandle: The handle of the file to read from.
// Returns the number of elements successfully read.
func word fread(byte[] buffer, word size, word count, byte[] fileHandle);

// Writes data to a file.
// buffer: Buffer containing the data to write.
// size: Size of each element to write.
// count: Number of elements to write.
// fileHandle: The handle of the file to write to.
// Returns the number of elements successfully written.
func word fwrite(const byte[] buffer, word size, word count, byte[] fileHandle);

// Sets the file position indicator for the file.
// fileHandle: The handle of the file.
// offset: Number of bytes to offset from whence.
// whence: Position from where offset is applied (0: beginning, 1: current position, 2: end of file).
// Returns 0 on success, or -1 on error.
func int fseek(byte[] fileHandle, int offset, byte whence);

// Returns the current file position indicator for the file.
// fileHandle: The handle of the file.
// Returns the current file position as a word, or 0 on error.
func word ftell(byte[] fileHandle);

// Deletes a file.
// filename: Name of the file to delete.
// Returns 0 on success, or -1 on error.
func int remove(const char[] filename);

// Renames a file or directory.
// oldname: Current name of the file or directory.
// newname: New name of the file or directory.
// Returns 0 on success, or -1 on error.
func int rename(const char[] oldname, const char[] newname);

// Creates a directory.
// dirname: Name of the directory to create.
// Returns 0 on success, or -1 on error.
func int mkdir(const char[] dirname) {
    byte[PageSize] dirBlock;
    byte[DescriptorSize] descriptor;
    byte newBlock = 7; // New directory block (for simplicity, always use block 7)
    
    // Initialize the directory descriptor
    memset(descriptor, 0, DescriptorSize);
    strcpy((descriptor + FilenameOffset) as char[], dirname);
    descriptor[FileTypeOffset] = (FileTypeDirectory | (strlen(dirname) & 0x0F)) as byte;
    descriptor[StartBlockOffset] = newBlock;
    
    writeString("Creating directory: ");
    writeString(dirname);
    writeString("\nDescriptor: ");
    printByteBuffer("", descriptor, DescriptorSize);

    // Read the root directory block to find an empty slot
    readBlock(RootDirStartBlock, dirBlock);
    for (word i = 0; i < PageSize; i += DescriptorSize) {
        if (dirBlock[i + FilenameOffset] == 0) {
            memcpy(dirBlock + i, descriptor, DescriptorSize);
            writeBlock(RootDirStartBlock, dirBlock);
            writeString("Directory created successfully.\n");
            return 0; // Success
        }
    }
    writeString("No empty slot found in root directory.\n");
    return -1; // No empty slot found
}

// Removes a directory.
// dirname: Name of the directory to remove.
// Returns 0 on success, or -1 on error.
func int rmdir(const char[] dirname) {
    byte[PageSize] dirBlock;
    byte[DescriptorSize] descriptor;
    
    // Read the root directory block to find the directory descriptor
    readBlock(RootDirStartBlock, dirBlock);
    for (word i = 0; i < PageSize; i += DescriptorSize) {
        memcpy(descriptor, dirBlock + i, DescriptorSize);
        if (strncmp((descriptor + FilenameOffset) as char[], dirname, strlen(dirname)) == 0 &&
            (descriptor[FileTypeOffset] & 0xF0) == FileTypeDirectory) {
            memset(dirBlock + i, 0, DescriptorSize); // Clear the descriptor
            writeBlock(RootDirStartBlock, dirBlock);
            return 0; // Success
        }
    }
    return -1; // Directory not found
}

// Opens a directory for reading.
// dirname: Name of the directory to open.
// Returns a directory handle if successful, or null if an error occurs.
func byte[] opendir(const char[] dirname) {
    if (strcmp(dirname, "/") == 0) {
        byte[2] dirHandle;
        dirHandle[0] = RootDirStartBlock;  // Root directory descriptor index
        dirHandle[1] = 0;  // Current position in directory
        return dirHandle;
    }
    return null; // Only root directory is supported in this example
}

// Reads an entry from a directory.
// dirHandle: The handle of the directory to read from.
// Returns a directory entry structure, or null if no more entries are available or an error occurs.
func byte[] readdir(byte[] dirHandle) {
    byte[DescriptorSize] dirent;
    byte[PageSize] dirBlock;
    byte offset = dirHandle[1];
    // Read the block where the current directory entry is
    readBlock(dirHandle[0], dirBlock);
    // Check if there are more entries
    if (dirBlock[offset + FilenameOffset] == 0) {
        return null;  // No more entries
    }
    // Copy the directory entry
    memcpy(dirent, dirBlock + offset, DescriptorSize);
    // Update the directory handle position
    dirHandle[1] += DescriptorSize;
    // Ensure we do not exceed the single byte limit
    if (dirHandle[1] >= PageSize) {
        return null;  // No more entries
    }
    return dirent;
}

// Closes an open directory.
// dirHandle: The handle of the directory to close.
// Returns 0 on success, or -1 on error.
func int closedir(byte[] dirHandle) {
    // In this simple implementation, there's no resource to free
    // Just return success
    return 0;
}

