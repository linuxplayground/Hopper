// Pin Modes
const byte INPUT = 0;
const byte OUTPUT = 1;
const byte INPUT_PULLUP = 2;

// assuming the W65C22 VIA for now:
const byte PORTB = 0xF0;
const byte PORTA = 0xF1;
const byte DDRB = 0xF2;
const byte DDRA = 0xF3;

const char[] hexChars = "0123456789ABCDEF";

// Memory Management
func byte[] malloc(word size); // System function to allocate memory
func free([] ptr);             // System function to free allocated memory
func word heapfree();          // System function to report free heap space in bytes
func word heapmax();           // System function to report largest available block from heap in bytes

// Serial Communication
func putc(char c); // System function to write a single character
func char getc();
func bool kbhit();

func puts(const char[] str) {
    // Function to write a null-terminated string to the serial output using putc
    word i;
    while (str[i] != (0 as char)) {
        putc(str[i]);
        i++;
    }
}

func writeWord(word num) {
    // Function to write a word as a string to the serial output buffer using putc
    if (num == 0) {
        putc('0');
        return;
    }
    byte i;
    char[5] digits; // Maximum 5 digits for a word
    while (num != 0) {
        digits[i++] = ((num % 10) + 48) as char;
        num /= 10;
    }
    // Write the digits in reverse order
    while (i != 0) {
        putc(digits[--i]);
    }
}

func writeInt(int num) {
    word w;
    if (num < 0) {
        num = -num;
        putc('-');
    }
    w = num as word;
    writeWord(w);
}

func writeHex(byte value) {
    // Function to write a byte as two hexadecimal characters
    byte highNibble;
    byte lowNibble;
    
    // Write the high nibble
    highNibble = (value >> 4) & 0x0F;
    putc(hexChars[highNibble]);
    
    // Write the low nibble
    lowNibble = value & 0x0F;
    putc(hexChars[lowNibble]);
}

// GPIO (Pin) Control
func pinSet(byte pin, bool value) { // System function to set the value of a pin
    byte port;
    if (pin <= 7) {
        port = PORTA;
    } else {
        port = PORTB;
    }
    pin = 1 << (pin & 0x07);
    if (value) {
        mem[port] = (mem[port] | pin);
    } else {
        mem[port] = (mem[port] & ~pin);
    }
}

func bool pinRead(byte pin) { // System function to read the value of a pin
    byte port;
    if (pin <= 7) {
        port = PORTA;
    } else {
        port = PORTB;
    }
    pin = 1 << (pin & 0x07);
    return ((mem[port] & pin) != 0);
}

func pinMode(byte pin, byte mode) { // System function to set the mode of a pin
    byte ddr;
    byte currentValue;
    if (pin <= 7) {
        ddr = DDRA;
    } else {
        ddr = DDRB;
    }
    pin = (1 << pin) & 0x07;
    currentValue = mem[ddr];
    if (mode == INPUT) {
        currentValue = currentValue & ~pin;
    } else {
        currentValue = currentValue | pin;
    }
    mem[ddr] = currentValue;
}

