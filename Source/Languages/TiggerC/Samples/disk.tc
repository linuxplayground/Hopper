#define EXPERIMENTAL
#define ZEROPAGEGLOBALS
func dumpRootDirectory();
func dumpChainLists();
#include "../system.tc"
#include "../file.tc"

func dumpRootDirectoryStructured(byte startBlock, byte indent);

// Prints the contents of a buffer in hexadecimal format.
func printHex(const byte[] buffer, word length) {
    word i;
    for (i = 0; i < length; i++) {
        writeHex(buffer[i]);
        writeChar(' ');
        if ((i + 1) % 16 == 0) {
            if ((i + 1) % 64 == 0) {
                writeChar('\n');
                break;
            } else {
                writeChar(' ');
            }
        }
    }
    writeChar('\n');
}
// Debugging function to print a byte buffer
func printByteBuffer(const char[] label, byte[] buffer, word length) {
    writeString(label);
    writeString(":\n");
    printHex(buffer, length);
}
// Dumps the contents of the ChainLists block.
func dumpChainLists() {
    byte[PageSize] buffer;
    writeString("ChainLists Block:\n");
    _readBlock(ChainBlock, buffer);
    printHex(buffer, PageSize);
}
// Dumps the contents of the root directory block.
func dumpRootDirectory() {
    byte[PageSize] buffer;
    writeString("Root Directory Block:\n");
    _readBlock(RootDirStartBlock, buffer);
    printHex(buffer, PageSize);
}
// Prints a message and dumps the root directory and chain lists if a test fails, then halts execution.
func handleTestFailure(const char[] message) {
    writeString(message);
    dumpRootDirectory();
    dumpChainLists();
}
// Appends an integer to a string.
func writeFileN(char[] name, word n) {
    itoa(n as int, name + strlen(name), 10); // Append the number to the name
}
// Creates multiple files in the given directory.
func createMultipleFiles(const char[] dir, word count) {
    char[256] filename;
    word i;
    for (i = 0; i < count; i++) {
        strcpy(filename, dir);
        strcat(filename, "/file");
        writeFileN(filename, i);
        byte[] fileHandle = fopen(filename, "w");
        if (fileHandle == null) {
            handleTestFailure("Failed to create file '");
            writeString(filename);
            writeString("'.\n");
            while (true) {}
        }
        fclose(fileHandle);
        writeString("Created file '");
        writeString(filename);
        writeString("'.\n");
    }
}
// Removes multiple files from the given directory.
func removeMultipleFiles(const char[] dir, word count) {
    char[256] filename;
    word i;
    for (i = 0; i < count; i++) {
        strcpy(filename, dir);
        strcat(filename, "/file");
        writeFileN(filename, i);
        if (remove(filename) != 0) {
            handleTestFailure("Failed to remove file '");
            writeString(filename);
            writeString("'.\n");
            while (true) {}
        }
        byte[] fileHandle = fopen(filename, "r");
        if (fileHandle != null) {
            handleTestFailure("Incorrectly opened removed file '");
            writeString(filename);
            writeString("'.\n");
            while (true) {}
        }
        writeString("Removed file '");
        writeString(filename);
        writeString("'.\n");
        dumpRootDirectoryStructured(RootDirStartBlock, 0);
    }
}
// Verifies that the given directory is empty.
func verifyDirectoryEmpty(const char[] dir) {
    byte[] dirHandle = opendir(dir);
    if (dirHandle == null) {
        handleTestFailure("Failed to open directory '");
        writeString(dir);
        writeString("'.\n");
        while (true) {}
    }
    byte[] dirEntry;
    while ((dirEntry = readdir(dirHandle)) != null) {
        handleTestFailure("Directory '");
        writeString(dir);
        writeString("' is not empty.\n");
        closedir(dirHandle);
        while (true) {}
    }
    closedir(dirHandle);
}
// Creates and verifies a file with the maximum allowed filename length in the given directory.
func createAndVerifyMaxFilenameLength(const char[] dir) {
    char[256] filename;
    strcpy(filename, dir);
    strcat(filename, "/");
    memset((filename + strlen(filename)) as byte[], 'A' as byte, 12);
    filename[strlen(filename) + 12] = '\0';
    byte[] fileHandle = fopen(filename, "w");
    if (fileHandle == null) {
        handleTestFailure("Failed to create file with max filename length in '");
        writeString(dir);
        writeString("'.\n");
        while (true) {}
    }
    fclose(fileHandle);
    writeString("Created file with max filename length in '");
    writeString(dir);
    writeString("'.\n");
    fileHandle = fopen(filename, "r");
    if (fileHandle == null) {
        handleTestFailure("Failed to verify file with max filename length in '");
        writeString(dir);
        writeString("'.\n");
        while (true) {}
    }
    fclose(fileHandle);
    writeString("Verified file with max filename length in '");
    writeString(dir);
    writeString("'.\n");
    if (remove(filename) != 0) {
        handleTestFailure("Failed to remove file with max filename length in '");
        writeString(dir);
        writeString("'.\n");
        while (true) {}
    }
    writeString("Removed file with max filename length in '");
    writeString(dir);
    writeString("'.\n");
}
// Creates and verifies nested directories.
func createAndVerifyNestedDirs() {
    if (mkdir("/dir1") != 0) {
        handleTestFailure("Failed to create directory '/dir1'.\n");
        while (true) {}
    }
    writeString("Created directory '/dir1'.\n");
    if (mkdir("/dir1/dir2") != 0) {
        handleTestFailure("Failed to create directory '/dir1/dir2'.\n");
        while (true) {}
    }
    writeString("Created directory '/dir1/dir2'.\n");
    if (mkdir("/dir1/dir2/dir3") != 0) {
        handleTestFailure("Failed to create directory '/dir1/dir2/dir3'.\n");
        while (true) {}
    }
    writeString("Created directory '/dir1/dir2/dir3'.\n");
    
    dumpRootDirectoryStructured(RootDirStartBlock, 0);
    
    if (rmdir("/dir1/dir2/dir3") != 0) {
        handleTestFailure("Failed to remove directory '/dir1/dir2/dir3'.\n");
        while (true) {}
    }
    writeString("Removed directory '/dir1/dir2/dir3'.\n");
    
    dumpRootDirectoryStructured(RootDirStartBlock, 0);
    
    if (rmdir("/dir1/dir2") != 0) {
        handleTestFailure("Failed to remove directory '/dir1/dir2'.\n");
        while (true) {}
    }
    writeString("Removed directory '/dir1/dir2'.\n");
    
    dumpRootDirectoryStructured(RootDirStartBlock, 0);
    
    if (rmdir("/dir1") != 0) {
        handleTestFailure("Failed to remove directory '/dir1'.\n");
        while (true) {}
    }
    
    writeString("Removed directory '/dir1'.\n");
    dumpRootDirectoryStructured(RootDirStartBlock, 0);
}
func writeSpaces(byte indent)
{
    while (indent != 0)
    {
        writeChar(' ');
        indent--;
    }
}
// Diagnostic function to output the current root directory contents in a structured way
func dumpRootDirectoryStructured(byte startBlock, byte indent) {
    byte[PageSize] buffer;
    byte[PageSize] chainBuffer;
    byte nextBlock;
    word i;
    byte entryType;
    byte entryLength;
    char[13] entryName;
    word entrySize;
    byte fileBlock;
    byte currentBlock = startBlock;
    
    // Read the chain list
    _readBlock(ChainBlock, chainBuffer);
    // Iterate through the directory blocks
    while (true) {
        
        _readBlock(currentBlock, buffer);
        writeSpaces(indent);
        writeString("Block ");
        writeHex(currentBlock);
        writeString(" -> ");
        writeHex(chainBuffer[currentBlock]);
        writeString(":\n");
        // Iterate through directory entries in the block
        for (i = 0; i < PageSize; i += DescriptorSize) {
            entryType = buffer[i + FileTypeOffset];
            entryLength = entryType & 0x0F;
            entryType = entryType & 0xF0;
            entryName[0] = '\0';
            fileBlock = buffer[i + StartBlockOffset];
            if (fileBlock != 0) {
                strncpy(entryName, (buffer + i + FilenameOffset) as char[], entryLength);
                entryName[entryLength] = '\0';
                entrySize = (buffer[i + FileSizeOffset] << 8) | buffer[i + FileSizeOffset + 1];
                writeSpaces(indent);
                writeString("  ");
                writeHex((i / DescriptorSize) as byte);
                writeString(entryType == FileTypeFile ? " File:      " : " Directory: ");
                writeString(entryName);
                writeString(", Size: ");
                writeWord(entrySize);
                writeString(" bytes, block=");
                writeWord(fileBlock);
                writeChar('\n');
                if ((entryType == FileTypeDirectory) && (fileBlock != 1))
                {
                    dumpRootDirectoryStructured(fileBlock, indent+4);
                }
            } else {
                //writeString("  Empty Slot\n");
            }
        }
        currentBlock = chainBuffer[currentBlock];
        if (currentBlock == 1) { break; }
    }
}
func main() {
    writeString("\nScanning:\n");
    if (i2cScan(SerialEEPROMAddress)) {
        writeString("EEPROM Found\n");
    } else {
        writeString("EEPROM Not Found\n");
        return;
    }
    chdir("/");
    if (format() != 0) {
        writeString("Format failed.\n");
        return;
    }
    writeString("Format succeeded.\n");
    
    dumpRootDirectoryStructured(RootDirStartBlock, 0);
    
    // Create and verify a file with the maximum allowed filename length.
    createAndVerifyMaxFilenameLength("/");
    
    dumpRootDirectoryStructured(RootDirStartBlock, 0);
    
    // Create and verify nested directories.
    createAndVerifyNestedDirs();
    
    writeString("All tests passed successfully.\n");
    
    dumpRootDirectory();
    dumpChainLists();
}

