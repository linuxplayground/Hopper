#define EXPERIMENTAL
#define ZEROPAGEGLOBALS
#include "../system.tc"
#include "../file.tc"

// Dumps the contents of the ChainLists block.
func dumpChainLists() {
    byte[PageSize] buffer;
    writeString("ChainLists Block:\n");
    readBlock(ChainBlock, buffer);
    printHex(buffer, PageSize);
}

// Dumps the contents of the root directory block.
func dumpRootDirectory() {
    byte[PageSize] buffer;
    writeString("Root Directory Block:\n");
    readBlock(RootDirStartBlock, buffer);
    printHex(buffer, PageSize);
}

// Dumps the contents of a specified directory block.
func dumpDirectoryBlock(byte block) {
    byte[PageSize] buffer;
    writeString("Directory Block (");
    writeHex(block);
    writeString("):\n");
    readBlock(block, buffer);
    printHex(buffer, PageSize);
}

// Creates a directory and dumps relevant information.
func createAndVerifyDir(const char[] dirname) {
    if (mkdir(dirname) == 0) {
        writeString("Created directory '");
        writeString(dirname);
        writeString("'.\n");
    } else {
        writeString("Failed to create directory '");
        writeString(dirname);
        writeString("'.\n");
    }
    dumpRootDirectory();
    dumpChainLists();
}

// Opens a directory, lists its contents, and closes it.
func listDirectory(const char[] dirname) {
    byte[] dirHandle = opendir(dirname);
    if (dirHandle == null) {
        writeString("Failed to open directory '");
        writeString(dirname);
        writeString("'.\n");
        return;
    }
    writeString("Opened directory '");
    writeString(dirname);
    writeString("'.\n");

    byte[] dirEntry;
    while ((dirEntry = readdir(dirHandle)) != null) {
        writeString("Entry: ");
        writeString((dirEntry + FilenameOffset) as char[]);
        writeString("\n");
    }
    writeString("No more entries in directory '");
    writeString(dirname);
    writeString("'.\n");

    if (closedir(dirHandle) != 0) {
        writeString("Failed to close directory '");
        writeString(dirname);
        writeString("'.\n");
        return;
    }
    writeString("Closed directory '");
    writeString(dirname);
    writeString("'.\n");
}

func main() {
    writeString("\nScanning:\n");
    if (i2cScan(SerialEEPROMAddress)) {
        writeString("EEPROM Found\n");
    } else {
        writeString("EEPROM Not Found\n");
        return;
    }
    
    if (format() != 0) {
        writeString("Format failed.\n");
        return;
    }
    writeString("Format succeeded.\n");
    
    // FAT, ChainLists, and Root Directory blocks
    dumpChainLists();
    dumpRootDirectory();
    
    byte[] rootDir = opendir("/");
    if (rootDir == null) {
        writeString("Failed to open root directory.\n");
        return;
    }
    writeString("Opened root directory.\n");
    
    createAndVerifyDir("newdir1");
    createAndVerifyDir("newdir2");

    // Dump Root Directory blocks again
    //dumpChainLists();
    //dumpRootDirectory();
    
    // List directories
    listDirectory("/");
    
    // Create subdirectory inside newdir1
    if (mkdir("newdir1/subdir1") == 0) {
        writeString("Created subdirectory 'newdir1/subdir1'.\n");
    } else {
        writeString("Failed to create subdirectory 'newdir1/subdir1'.\n");
    }
    
    // List contents of newdir1
    listDirectory("newdir1");

    if (closedir(rootDir) != 0) {
        writeString("Failed to close root directory.\n");
        return;
    }
    writeString("Closed root directory.\n");
}


