#define EXPERIMENTAL
#define ZEROPAGEGLOBALS
#include "../system.tc"
#include "../file.tc"

// Dumps the contents of the ChainLists block.
func dumpChainLists() {
    byte[PageSize] buffer;
    writeString("ChainLists Block:\n");
    readBlock(ChainBlock, buffer);
    printHex(buffer, PageSize);
}

// Dumps the contents of the root directory block.
func dumpRootDirectory() {
    byte[PageSize] buffer;
    writeString("Root Directory Block:\n");
    readBlock(RootDirStartBlock, buffer);
    printHex(buffer, PageSize);
}

// Dumps the contents of a specified directory block.
func dumpDirectoryBlock(byte block) {
    byte[PageSize] buffer;
    writeString("Directory Block (");
    writeHex(block);
    writeString("):\n");
    readBlock(block, buffer);
    printHex(buffer, PageSize);
}

// Dumps the contents of a directory.
func dumpDirectory(const char[] dirname) {
    byte[] dirHandle = opendir(dirname);
    if (dirHandle != null) {
        dumpDirectoryBlock(dirHandle[0]);
        closedir(dirHandle);
    } else {
        writeString("Failed to open directory '");
        writeString(dirname);
        writeString("'.\n");
    }
}

// Creates a file and verifies its creation.
func createAndVerifyFile(const char[] filename) {
    byte[] fileHandle = fopen(filename, "w");
    if (fileHandle != null) {
        writeString("Created file '");
        writeString(filename);
        writeString("'.\n");
        if (fclose(fileHandle) != 0) {
            writeString("Failed to close file '");
            writeString(filename);
            writeString("'.\n");
        } else {
            writeString("Closed file '");
            writeString(filename);
            writeString("'.\n");
        }
    } else {
        writeString("Failed to create file '");
        writeString(filename);
        writeString("'.\n");
    }
    dumpRootDirectory();
    dumpChainLists();
}

// Opens a file and verifies its opening.
func openAndVerifyFile(const char[] filename) {
    byte[] fileHandle = fopen(filename, "r");
    if (fileHandle != null) {
        writeString("Opened file '");
        writeString(filename);
        writeString("'.\n");
        if (fclose(fileHandle) != 0) {
            writeString("Failed to close file '");
            writeString(filename);
            writeString("'.\n");
        } else {
            writeString("Closed file '");
            writeString(filename);
            writeString("'.\n");
        }
    } else {
        writeString("Failed to open file '");
        writeString(filename);
        writeString("'.\n");
    }
    dumpRootDirectory();
    dumpChainLists();
}

// Deletes a file and verifies its deletion.
func deleteAndVerifyFile(const char[] filename) {
    if (remove(filename) == 0) {
        writeString("Deleted file '");
        writeString(filename);
        writeString("'.\n");
    } else {
        writeString("Failed to delete file '");
        writeString(filename);
        writeString("'.\n");
    }
    dumpRootDirectory();
    dumpChainLists();
}

// Tests writing to and reading from a file.
func testWriteAndReadFile(const char[] filename, const byte[] data, word size) {
    byte[] fileHandle = fopen(filename, "w");
    if (fileHandle == null) {
        writeString("Failed to open file for writing: ");
        writeString(filename);
        writeString("\n");
        return;
    }
    if (fwrite(data, 1, size, fileHandle) != size) {
        writeString("Failed to write data to file: ");
        writeString(filename);
        writeString("\n");
    }
    fclose(fileHandle);
    fileHandle = fopen(filename, "r");
    if (fileHandle == null) {
        writeString("Failed to open file for reading: ");
        writeString(filename);
        writeString("\n");
        return;
    }
    byte[] readData = malloc(size);
    if (fread(readData, 1, size, fileHandle) != size) {
        writeString("Failed to read data from file: ");
        writeString(filename);
        writeString("\n");
    }
    fclose(fileHandle);
    // Compare readData with the original data
    if (memcmp(data, readData, size) == 0) {
        writeString("Write and read test passed for file: ");
    } else {
        writeString("Write and read test failed for file: ");
    }
    free(readData);
    writeString(filename);
    writeString("\n");
}

// Create and verify a directory
func createAndVerifyDir(const char[] dirname) {
    if (mkdir(dirname) == 0) {
        writeString("Created directory '");
        writeString(dirname);
        writeString("'.\n");
    } else {
        writeString("Failed to create directory '");
        writeString(dirname);
        writeString("'.\n");
    }
    dumpRootDirectory();
    dumpChainLists();
}

// List the contents of a directory
func listDirectory(const char[] dirname) {
    byte[] dirHandle = opendir(dirname);
    if (dirHandle == null) {
        writeString("Failed to open directory '");
        writeString(dirname);
        writeString("'.\n");
        return;
    }
    writeString("Opened directory '");
    writeString(dirname);
    writeString("'.\n");
    byte[] dirEntry;
    while ((dirEntry = readdir(dirHandle)) != null) {
        writeString("Entry: ");
        writeString((dirEntry + FilenameOffset) as char[]);
        writeString("\n");
    }
    writeString("No more entries in directory '");
    writeString(dirname);
    writeString("'.\n");
    if (closedir(dirHandle) != 0) {
        writeString("Failed to close directory '");
        writeString(dirname);
        writeString("'.\n");
        return;
    }
    writeString("Closed directory '");
    writeString(dirname);
    writeString("'.\n");
}

// Remove and verify a directory
func removeAndVerifyDir(const char[] dirname) {
    if (rmdir(dirname) == 0) {
        writeString("Removed directory '");
        writeString(dirname);
        writeString("'.\n");
    } else {
        writeString("Failed to remove directory '");
        writeString(dirname);
        writeString("'.\n");
    }
    dumpRootDirectory();
    dumpChainLists();
}

func main() {
    writeString("\nScanning:\n");
    if (i2cScan(SerialEEPROMAddress)) {
        writeString("EEPROM Found\n");
    } else {
        writeString("EEPROM Not Found\n");
        return;
    }
    chdir("/");
    
    if (format() != 0) {
        writeString("Format failed.\n");
        return;
    }
    writeString("Format succeeded.\n");
    
    // FAT, ChainLists, and Root Directory blocks
    dumpChainLists();
    dumpRootDirectory();
    
    createAndVerifyFile("/file1");
    createAndVerifyFile("/file2");
    char[] testData = "Hello, TiggerC!";
    testWriteAndReadFile("/file1", testData as byte[], strlen(testData));
    deleteAndVerifyFile("/file1");
    deleteAndVerifyFile("/file2");
    
    dumpChainLists();
    dumpRootDirectory();
    
    /*
    
    // Create a directory and some files within it
    createAndVerifyDir("/mydir");
    dumpDirectory("/mydir");  // Dump directory block after creating directory

    createAndVerifyFile("/mydir/file1");
    createAndVerifyFile("/mydir/file2");
    dumpDirectory("/mydir");  // Dump directory block after creating files

    // List the directory contents
    listDirectory("/mydir");
    
    // Write and read test in the subdirectory
    testWriteAndReadFile("/mydir/file1", testData as byte[], strlen(testData));
    dumpDirectory("/mydir");  // Dump directory block after write/read test

    // Delete files in the subdirectory
    deleteAndVerifyFile("/mydir/file1");
    deleteAndVerifyFile("/mydir/file2");
    dumpDirectory("/mydir");  // Dump directory block after deleting files

    // Remove the directory
    removeAndVerifyDir("/mydir");
    */
}

