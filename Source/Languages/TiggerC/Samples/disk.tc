#define EXPERIMENTAL
#define ZEROPAGEGLOBALS

func dumpRootDirectory();
func dumpChainLists();
#include "../system.tc"
#include "../file.tc"
func dumpDirectoryStructured(byte startBlock, byte indent);

func writeSpaces(byte indent)
{
    while (indent != 0)
    {
        writeChar(' ');
        indent--;
    }
}

// Prints the contents of a buffer in hexadecimal format.
func printHex(const byte[] buffer, word length) {
    word i;
    for (i = 0; i < length; i++) {
        writeHex(buffer[i]);
        writeChar(' ');
        if ((i + 1) % 16 == 0) {
            if ((i + 1) % 64 == 0) {
                writeChar('\n');
                break;
            } else {
                writeChar(' ');
            }
        }
    }
    writeChar('\n');
}

// Debugging function to print a byte buffer
func printByteBuffer(const char[] label, byte[] buffer, word length) {
    writeString(label);
    writeString(":\n");
    printHex(buffer, length);
}

// Dumps the contents of the ChainLists block.
func dumpChainLists() {
    byte[PageSize] buffer;
    writeString("ChainLists Block:\n");
    _readBlock(ChainBlock, buffer);
    printHex(buffer, PageSize);
}

// Dumps the contents of the root directory block.
func dumpRootDirectory() {
    byte[PageSize] buffer;
    writeString("Root Directory Block:\n");
    _readBlock(RootDirStartBlock, buffer);
    printHex(buffer, PageSize);
}

// Prints a message and dumps the root directory and chain lists if a test fails, then halts execution.
func handleTestFailure(const char[] message) {
    writeString(message);
    dumpRootDirectory();
    dumpChainLists();
    while (true) {}
}

// Writes data to a file and reads it back to verify correctness.
func testWriteReadFile(const char[] filename, const byte[] writeData, word writeSize) {
    byte[256] readData;
    byte[] fileHandle;

    // Write data to the file
    fileHandle = fopen(filename, "w");
    if (fileHandle == null) {
        handleTestFailure("Failed to open file for writing: ");
        writeString(filename);
        writeChar('\n');
    }
    word written = fwrite(writeData, 1, writeSize, fileHandle);
    if (written != writeSize) {
        handleTestFailure("Failed to write data to file: ");
        writeString(filename);
        writeChar('\n');
    }
    fclose(fileHandle);
    
    dumpDirectoryStructured(RootDirStartBlock, 0);

    // Read data back from the file
    fileHandle = fopen(filename, "r");
    if (fileHandle == null) {
        handleTestFailure("Failed to open file for reading: ");
        writeString(filename);
        writeChar('\n');
    }
    word read = fread(readData, 1, writeSize, fileHandle);
    if (read != writeSize) {
        handleTestFailure("Failed to read data from file: ");
        writeString(filename);
        writeChar('\n');
    }
    fclose(fileHandle);

    // Verify the read data matches the written data
    if (memcmp(writeData, readData, writeSize) != 0) {
        handleTestFailure("Data read does not match data written in file: ");
        writeString(filename);
        writeChar('\n');
    }

    writeString("Successfully verified file: ");
    writeString(filename);
    writeChar('\n');
}

func dumpDirectoryStructured(byte startBlock, byte indent) {
    byte[PageSize] buffer;
    byte[PageSize] chainBuffer;
    byte nextBlock;
    word i;
    byte entryType;
    byte entryLength;
    char[13] entryName;
    word entrySize;
    byte fileBlock;
    byte currentBlock = startBlock;
    
    // Read the chain list
    _readBlock(ChainBlock, chainBuffer);
    // Iterate through the directory blocks
    while (true) {
        
        _readBlock(currentBlock, buffer);
        writeSpaces(indent);
        writeString("Block ");
        writeHex(currentBlock);
        writeString(" -> ");
        writeHex(chainBuffer[currentBlock]);
        writeString(":\n");
        // Iterate through directory entries in the block
        for (i = 0; i < PageSize; i += DescriptorSize) {
            entryType = buffer[i + FileTypeOffset];
            entryLength = entryType & 0x0F;
            entryType = entryType & 0xF0;
            entryName[0] = '\0';
            fileBlock = buffer[i + StartBlockOffset];
            if (fileBlock != 0) {
                strncpy(entryName, (buffer + i + FilenameOffset) as char[], entryLength);
                entryName[entryLength] = '\0';
                entrySize = (buffer[i + FileSizeOffset] << 8) | buffer[i + FileSizeOffset + 1];
                writeSpaces(indent);
                writeString("  ");
                writeHex((i / DescriptorSize) as byte);
                writeString(entryType == FileTypeFile ? " File:      " : " Directory: ");
                writeString(entryName);
                writeString(", Size: ");
                writeWord(entrySize);
                writeString(" bytes, block=");
                writeWord(fileBlock);
                writeChar('\n');
                if ((entryType == FileTypeDirectory) && (fileBlock != 1))
                {
                    dumpDirectoryStructured(fileBlock, indent+4);
                }
            } else {
                //writeString("  Empty Slot\n");
            }
        }
        currentBlock = chainBuffer[currentBlock];
        if (currentBlock == 1) { break; }
    }
}

func main() {
    byte[256] writeData1;
    byte[256] writeData2;
    word i;
    
    writeString("\nScanning:\n");
    if (i2cScan(SerialEEPROMAddress)) {
        writeString("EEPROM Found\n");
    } else {
        writeString("EEPROM Not Found\n");
        return;
    }
    chdir("/");
    if (format() != 0) {
        writeString("Format failed.\n");
        return;
    }
    writeString("Format succeeded.\n");
    
    dumpDirectoryStructured(RootDirStartBlock, 0);
    
    // Create test data for writing and reading
    for (i = 0; i < 256; i++) {
        writeData1[i] = i as byte;
        writeData2[i] = (255 - i) as byte;
    }
    
    writeString("Data Created.\n");

    // Test fwrite and fread with two small files
    testWriteReadFile("/file1", writeData1, 256);
    testWriteReadFile("/file2", writeData2, 256);
    
    dumpDirectoryStructured(RootDirStartBlock, 0);
    
    writeString("All tests passed successfully.\n");
}

