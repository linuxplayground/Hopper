#define EXPERIMENTAL
#define ZEROPAGEGLOBALS
func dumpRootDirectory();
func dumpChainLists();
#include "../system.tc"
#include "../file.tc"

// Prints the contents of a buffer in hexadecimal format.
func printHex(const byte[] buffer, word length) {
    word i;
    for (i = 0; i < length; i++) {
        writeHex(buffer[i]);
        writeChar(' ');
        if ((i + 1) % 16 == 0) {
            if ((i + 1) % 64 == 0) {
                writeChar('\n');
                break;
            } else {
                writeChar(' ');
            }
        }
    }
    writeChar('\n');
}

// Debugging function to print a byte buffer
func printByteBuffer(const char[] label, byte[] buffer, word length) {
    writeString(label);
    writeString(":\n");
    printHex(buffer, length);
}

// Dumps the contents of the ChainLists block.
func dumpChainLists() {
    byte[PageSize] buffer;
    writeString("ChainLists Block:\n");
    _readBlock(ChainBlock, buffer);
    printHex(buffer, PageSize);
}

// Dumps the contents of the root directory block.
func dumpRootDirectory() {
    byte[PageSize] buffer;
    writeString("Root Directory Block:\n");
    _readBlock(RootDirStartBlock, buffer);
    printHex(buffer, PageSize);
}

// Prints a message and dumps the root directory and chain lists if a test fails, then halts execution.
func handleTestFailure(const char[] message) {
    writeString(message);
    dumpRootDirectory();
    dumpChainLists();
}

// Appends an integer to a string.
func writeFileN(char[] name, word n) {
    itoa(n as int, name + strlen(name), 10); // Append the number to the name
}

// Creates multiple files in the root directory.
func createMultipleFiles(word count) {
    char[256] filename;
    word i;
    for (i = 0; i < count; i++) {
        strcpy(filename, "/file");
        writeFileN(filename, i);
        byte[] fileHandle = fopen(filename, "w");
        if (fileHandle == null) {
            handleTestFailure("Failed to create file '");
            writeString(filename);
            writeString("'.\n");
            while (true) {}
        }
        fclose(fileHandle);
        writeString("Created file '");
        writeString(filename);
        writeString("'.\n");
    }
}

// Removes multiple files from the root directory.
func removeMultipleFiles(word count) {
    char[256] filename;
    word i;
    for (i = 0; i < count; i++) {
        strcpy(filename, "/file");
        writeFileN(filename, i);
        if (remove(filename) != 0) {
            handleTestFailure("Failed to remove file '");
            writeString(filename);
            writeString("'.\n");
            while (true) {}
        }
        byte[] fileHandle = fopen(filename, "w");
        if (fileHandle != null) {
            handleTestFailure("Incorrectly opened removed file '");
            writeString(filename);
            writeString("'.\n");
            while (true) {}
        }
        writeString("Removed file '");
        writeString(filename);
        writeString("'.\n");
    }
}

// Verifies that the root directory is empty.
func verifyRootDirectoryEmpty() {
    byte[] dirHandle = opendir("/");
    if (dirHandle == null) {
        handleTestFailure("Failed to open root directory.\n");
        while (true) {}
    }
    byte[] dirEntry;
    while ((dirEntry = readdir(dirHandle)) != null) {
        handleTestFailure("Root directory is not empty.\n");
        closedir(dirHandle);
        while (true) {}
    }
    closedir(dirHandle);
}

// Creates and verifies a file with the maximum allowed filename length.
func createAndVerifyMaxFilenameLength() {
    char[13] filename;
    memset(filename as byte[], 'A' as byte, 12);
    filename[12] = '\0';
    byte[] fileHandle = fopen(filename, "w");
    if (fileHandle == null) {
        handleTestFailure("Failed to create file with max filename length.\n");
        while (true) {}
    }
    fclose(fileHandle);
    writeString("Created file with max filename length.\n");
    fileHandle = fopen(filename, "r");
    if (fileHandle == null) {
        handleTestFailure("Failed to verify file with max filename length.\n");
        while (true) {}
    }
    fclose(fileHandle);
    writeString("Verified file with max filename length.\n");
    if (remove(filename) != 0) {
        handleTestFailure("Failed to remove file with max filename length.\n");
        while (true) {}
    }
    writeString("Removed file with max filename length.\n");
}

// Creates and verifies nested directories.
func createAndVerifyNestedDirs() {
    if (mkdir("/dir1") != 0) {
        handleTestFailure("Failed to create directory '/dir1'.\n");
        while (true) {}
    }
    writeString("Created directory '/dir1'.\n");
    if (mkdir("/dir1/dir2") != 0) {
        handleTestFailure("Failed to create directory '/dir1/dir2'.\n");
        while (true) {}
    }
    writeString("Created directory '/dir1/dir2'.\n");
    if (mkdir("/dir1/dir2/dir3") != 0) {
        handleTestFailure("Failed to create directory '/dir1/dir2/dir3'.\n");
        while (true) {}
    }
    writeString("Created directory '/dir1/dir2/dir3'.\n");
    if (rmdir("/dir1/dir2/dir3") != 0) {
        handleTestFailure("Failed to remove directory '/dir1/dir2/dir3'.\n");
        while (true) {}
    }
    writeString("Removed directory '/dir1/dir2/dir3'.\n");
    if (rmdir("/dir1/dir2") != 0) {
        handleTestFailure("Failed to remove directory '/dir1/dir2'.\n");
        while (true) {}
    }
    writeString("Removed directory '/dir1/dir2'.\n");
    if (rmdir("/dir1") != 0) {
        handleTestFailure("Failed to remove directory '/dir1'.\n");
        while (true) {}
    }
    writeString("Removed directory '/dir1'.\n");
}

func main() {
    writeString("\nScanning:\n");
    if (i2cScan(SerialEEPROMAddress)) {
        writeString("EEPROM Found\n");
    } else {
        writeString("EEPROM Not Found\n");
        return;
    }
    chdir("/");
    if (format() != 0) {
        writeString("Format failed.\n");
        return;
    }
    writeString("Format succeeded.\n");
    // Determine the number of files needed to exceed one directory block.
    word filesPerBlock = PageSize / DescriptorSize;
    word extraFiles = filesPerBlock + 10; // Creating 10 more files than would fit in one block.
    // Create more files than would fit into one directory block.
    createMultipleFiles(extraFiles);
    // Verify the files were created.
    char[256] filename;
    for (word i = 0; i < extraFiles; i++) {
        strcpy(filename, "/file");
        writeFileN(filename, i);
        byte[] fileHandle = fopen(filename, "r");
        if (fileHandle == null) {
            handleTestFailure("Failed to verify file '");
            writeString(filename);
            writeString("'.\n");
            while (true) {}
        }
        fclose(fileHandle);
        writeString("Verified file '");
        writeString(filename);
        writeString("'.\n");
    }
    // Remove all the files.
    removeMultipleFiles(extraFiles);
    // Verify the root directory is empty.
    verifyRootDirectoryEmpty();
    // Create and verify a file with the maximum allowed filename length.
    createAndVerifyMaxFilenameLength();
    // Create and verify nested directories.
    createAndVerifyNestedDirs();
    writeString("All tests passed successfully.\n");
    dumpRootDirectory();
    dumpChainLists();
}

