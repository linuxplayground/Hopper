#define EXPERIMENTAL
#define ZEROPAGEGLOBALS

func dumpRootDirectory();
func dumpChainLists();

#include "../system.tc"
#include "../file.tc"

// Dumps the contents of the ChainLists block.
func dumpChainLists() {
    byte[PageSize] buffer;
    writeString("ChainLists Block:\n");
    readBlock(ChainBlock, buffer);
    printHex(buffer, PageSize);
}

// Dumps the contents of the root directory block.
func dumpRootDirectory() {
    byte[PageSize] buffer;
    writeString("Root Directory Block:\n");
    readBlock(RootDirStartBlock, buffer);
    printHex(buffer, PageSize);
}

// Dumps the contents of a specified directory block.
func dumpDirectoryBlock(byte block) {
    byte[PageSize] buffer;
    writeString("Directory Block (");
    writeHex(block);
    writeString("):\n");
    readBlock(block, buffer);
    printHex(buffer, PageSize);
}

// Dumps the contents of a directory.
func dumpDirectory(const char[] dirname) {
    byte[] dirHandle = opendir(dirname);
    if (dirHandle != null) {
        dumpDirectoryBlock(dirHandle[0]);
        closedir(dirHandle);
    } else {
        writeString("Failed to open directory '");
        writeString(dirname);
        writeString("'.\n");
    }
}

func dumpBlocksForFile(const char[] filename) {
    byte[PageSize] chainBlock;
    byte[PageSize] fileBlock;
    byte[PageSize] dirBlock; 
    byte[DescriptorSize] descriptor;
    char[256] fullPath;
    byte[] dirHandle;
    byte currentBlock;
    word i;
    byte fileBlockNum;
    
    getFullPath(fullPath, filename);
    
    dirHandle = opendir("/");
    if (dirHandle == null) {
        writeString("Failed to open root directory.\n");
        return;
    }
    
    while (true) {
        readBlock(dirHandle[0], dirBlock);
        for (i = 0; i < PageSize; i += DescriptorSize) {
            memcpy(descriptor, dirBlock + i, DescriptorSize);
            if (strncmp((descriptor + FilenameOffset) as char[], filename + 1, strlen(filename + 1)) == 0 &&
                (descriptor[FileTypeOffset] & 0xF0) == FileTypeFile) {
                
                fileBlockNum = descriptor[StartBlockOffset];
                while (fileBlockNum != 1) {
                    writeString("Block ");
                    writeHex(fileBlockNum);
                    writeString(":\n");
                    readBlock(fileBlockNum, fileBlock);
                    printHex(fileBlock, PageSize);
                    
                    readBlock(ChainBlock, chainBlock);
                    fileBlockNum = chainBlock[fileBlockNum];
                }
                closedir(dirHandle);
                return;
            }
        }
        if (chainBlock[dirHandle[0]] == 1) {
            break; // No more blocks in the chain
        }
        dirHandle[0] = chainBlock[dirHandle[0]];
    }
    
    writeString("File not found.\n");
    closedir(dirHandle);
}


// Creates a file and verifies its creation.
func createAndVerifyFile(const char[] filename) {
    byte[] fileHandle = fopen(filename, "w");
    if (fileHandle != null) {
        writeString("Created file '");
        writeString(filename);
        writeString("'.\n");
        if (fclose(fileHandle) != 0) {
            writeString("Failed to close file '");
            writeString(filename);
            writeString("'.\n");
        } else {
            writeString("Closed file '");
            writeString(filename);
            writeString("'.\n");
        }
    } else {
        writeString("Failed to create file '");
        writeString(filename);
        writeString("'.\n");
    }
    dumpRootDirectory();
    dumpChainLists();
}

// Opens a file and verifies its opening.
func openAndVerifyFile(const char[] filename) {
    byte[] fileHandle = fopen(filename, "r");
    if (fileHandle != null) {
        writeString("Opened file '");
        writeString(filename);
        writeString("'.\n");
        if (fclose(fileHandle) != 0) {
            writeString("Failed to close file '");
            writeString(filename);
            writeString("'.\n");
        } else {
            writeString("Closed file '");
            writeString(filename);
            writeString("'.\n");
        }
    } else {
        writeString("Failed to open file '");
        writeString(filename);
        writeString("'.\n");
    }
    dumpRootDirectory();
    dumpChainLists();
}

// Deletes a file and verifies its deletion.
func deleteAndVerifyFile(const char[] filename) {
    if (remove(filename) == 0) {
        writeString("Deleted file '");
        writeString(filename);
        writeString("'.\n");
    } else {
        writeString("Failed to delete file '");
        writeString(filename);
        writeString("'.\n");
    }
    dumpRootDirectory();
    dumpChainLists();
}

// Tests writing to and reading from a file.
func testWriteAndReadFile(const char[] filename, const byte[] data, word size) {
    byte[] fileHandle = fopen(filename, "w");
    if (fileHandle == null) {
        writeString("Failed to open file for writing: ");
        writeString(filename);
        writeString("\n");
        return;
    }
    if (fwrite(data, 1, size, fileHandle) != size) {
        writeString("Failed to write data to file: ");
        writeString(filename);
        writeString("\n");
    }
    fclose(fileHandle);
    fileHandle = fopen(filename, "r");
    if (fileHandle == null) {
        writeString("Failed to open file for reading: ");
        writeString(filename);
        writeString("\n");
        return;
    }
    byte[] readData = malloc(size);
    if (fread(readData, 1, size, fileHandle) != size) {
        writeString("Failed to read data from file: ");
        writeString(filename);
        writeString("\n");
    }
    fclose(fileHandle);
    // Compare readData with the original data
    if (memcmp(data, readData, size) == 0) {
        writeString("Write and read test passed for file: ");
    } else {
        writeString("Write and read test failed for file: ");
    }
    free(readData);
    writeString(filename);
    writeString("\n");
}

// Create and verify a directory
func createAndVerifyDir(const char[] dirname) {
    if (mkdir(dirname) == 0) {
        writeString("Created directory '");
        writeString(dirname);
        writeString("'.\n");
    } else {
        writeString("Failed to create directory '");
        writeString(dirname);
        writeString("'.\n");
    }
    dumpRootDirectory();
    dumpChainLists();
}

// List the contents of a directory
func listDirectory(const char[] dirname) {
    byte[] dirHandle = opendir(dirname);
    if (dirHandle == null) {
        writeString("Failed to open directory '");
        writeString(dirname);
        writeString("'.\n");
        return;
    }
    writeString("Opened directory '");
    writeString(dirname);
    writeString("'.\n");
    byte[] dirEntry;
    while ((dirEntry = readdir(dirHandle)) != null) {
        writeString("Entry: ");
        writeString((dirEntry + FilenameOffset) as char[]);
        writeString("\n");
    }
    writeString("No more entries in directory '");
    writeString(dirname);
    writeString("'.\n");
    if (closedir(dirHandle) != 0) {
        writeString("Failed to close directory '");
        writeString(dirname);
        writeString("'.\n");
        return;
    }
    writeString("Closed directory '");
    writeString(dirname);
    writeString("'.\n");
}

// Remove and verify a directory
func removeAndVerifyDir(const char[] dirname) {
    if (rmdir(dirname) == 0) {
        writeString("Removed directory '");
        writeString(dirname);
        writeString("'.\n");
    } else {
        writeString("Failed to remove directory '");
        writeString(dirname);
        writeString("'.\n");
    }
    dumpRootDirectory();
    dumpChainLists();
}

func main() {
    writeString("\nScanning:\n");
    if (i2cScan(SerialEEPROMAddress)) {
        writeString("EEPROM Found\n");
    } else {
        writeString("EEPROM Not Found\n");
        return;
    }
    chdir("/");
    
    if (format() != 0) {
        writeString("Format failed.\n");
        return;
    }
    writeString("Format succeeded.\n");
    
    // FAT, ChainLists, and Root Directory blocks
    dumpChainLists();
    dumpRootDirectory();
    
    createAndVerifyFile("/file1");
    createAndVerifyFile("/file2");
    
    openAndVerifyFile("/file2");
    openAndVerifyFile("/file1");
    
    /*
    // Dump before write
    writeString("Before write:\n");
    dumpChainLists();
    dumpRootDirectory();
    
    char[] testData = "Hello, TiggerC!";
    
    // Write data to the file
    byte[] fileHandle = fopen("/file1", "w");
    if (fileHandle == null) {
        writeString("Failed to open file for writing: /file1\n");
        return;
    }
    if (fwrite(testData as byte[], 1, strlen(testData), fileHandle) != strlen(testData)) {
        writeString("Failed to write data to file: /file1\n");
    }
    fclose(fileHandle);
    
    // Dump after write
    writeString("\nAfter write:\n");
    dumpChainLists();
    dumpRootDirectory();
    
    // Dump blocks used by the file
    dumpBlocksForFile("/file1");
    mkdir("test");
    rmdir("test");
    */
}

