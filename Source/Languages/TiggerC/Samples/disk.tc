#define EXPERIMENTAL
#define ZEROPAGEGLOBALS
func dumpRootDirectory();
func dumpChainLists();
#include "../system.tc"
#include "../file.tc"

// Prints the contents of a buffer in hexadecimal format.
func printHex(const byte[] buffer, word length) {
    word i;
    for (i = 0; i < length; i++) {
        writeHex(buffer[i]);
        writeChar(' ');
        if ((i + 1) % 16 == 0) {
            if ((i + 1) % 64 == 0) {
                writeChar('\n');
                break;
            } else {
                writeChar(' ');
            }
        }
    }
    writeChar('\n');
}

// Debugging function to print a byte buffer
func printByteBuffer(const char[] label, byte[] buffer, word length) {
    writeString(label);
    writeString(":\n");
    printHex(buffer, length);
}

// Dumps the contents of the ChainLists block.
func dumpChainLists() {
    byte[PageSize] buffer;
    writeString("ChainLists Block:\n");
    _readBlock(ChainBlock, buffer);
    printHex(buffer, PageSize);
}

// Dumps the contents of the root directory block.
func dumpRootDirectory() {
    byte[PageSize] buffer;
    writeString("Root Directory Block:\n");
    _readBlock(RootDirStartBlock, buffer);
    printHex(buffer, PageSize);
}

// Prints a message and dumps the root directory and chain lists if a test fails, then halts execution.
func handleTestFailure(const char[] message) {
    writeString(message);
    dumpRootDirectory();
    dumpChainLists();
}

// Appends an integer to a string.
func writeFileN(char[] name, word n) {
    itoa(n as int, name + strlen(name), 10); // Append the number to the name
}

// Creates multiple files in the root directory.
func createMultipleFiles(word count) {
    char[256] filename;
    word i;
    for (i = 0; i < count; i++) {
        strcpy(filename, "/file");
        writeFileN(filename, i);
        byte[] fileHandle = fopen(filename, "w");
        if (fileHandle == null) {
            handleTestFailure("Failed to create file '");
            writeString(filename);
            writeString("'.\n");
            while (true) {}
        }
        fclose(fileHandle);
        writeString("Created file '");
        writeString(filename);
        writeString("'.\n");
    }
}

// Removes multiple files from the root directory.
func removeMultipleFiles(word count) {
    char[256] filename;
    word i;
    for (i = 0; i < count; i++) {
        strcpy(filename, "/file");
        writeFileN(filename, i);
        if (remove(filename) != 0) {
            handleTestFailure("Failed to remove file '");
            writeString(filename);
            writeString("'.\n");
            while (true) {}
        }
        byte[] fileHandle = fopen(filename, "r");
        if (fileHandle != null) {
            handleTestFailure("Incorrectly opened removed file '");
            writeString(filename);
            writeString("'.\n");
            while (true) {}
        }
        writeString("Removed file '");
        writeString(filename);
        writeString("'.\n");
    }
}

// Verifies that the root directory is empty.
func verifyRootDirectoryEmpty() {
    byte[] dirHandle = opendir("/");
    if (dirHandle == null) {
        handleTestFailure("Failed to open root directory.\n");
        while (true) {}
    }
    byte[] dirEntry;
    while ((dirEntry = readdir(dirHandle)) != null) {
        handleTestFailure("Root directory is not empty.\n");
        closedir(dirHandle);
        while (true) {}
    }
    closedir(dirHandle);
}

// Creates and verifies a file with the maximum allowed filename length.
func createAndVerifyMaxFilenameLength() {
    char[13] filename;
    memset(filename as byte[], 'A' as byte, 12);
    filename[12] = '\0';
    byte[] fileHandle = fopen(filename, "w");
    if (fileHandle == null) {
        handleTestFailure("Failed to create file with max filename length.\n");
        while (true) {}
    }
    fclose(fileHandle);
    writeString("Created file with max filename length.\n");
    fileHandle = fopen(filename, "r");
    if (fileHandle == null) {
        handleTestFailure("Failed to verify file with max filename length.\n");
        while (true) {}
    }
    fclose(fileHandle);
    writeString("Verified file with max filename length.\n");
    if (remove(filename) != 0) {
        handleTestFailure("Failed to remove file with max filename length.\n");
        while (true) {}
    }
    writeString("Removed file with max filename length.\n");
}

// Creates and verifies nested directories.
func createAndVerifyNestedDirs() {
    if (mkdir("/dir1") != 0) {
        handleTestFailure("Failed to create directory '/dir1'.\n");
        while (true) {}
    }
    writeString("Created directory '/dir1'.\n");
    if (mkdir("/dir1/dir2") != 0) {
        handleTestFailure("Failed to create directory '/dir1/dir2'.\n");
        while (true) {}
    }
    writeString("Created directory '/dir1/dir2'.\n");
    if (mkdir("/dir1/dir2/dir3") != 0) {
        handleTestFailure("Failed to create directory '/dir1/dir2/dir3'.\n");
        while (true) {}
    }
    writeString("Created directory '/dir1/dir2/dir3'.\n");
    if (rmdir("/dir1/dir2/dir3") != 0) {
        handleTestFailure("Failed to remove directory '/dir1/dir2/dir3'.\n");
        while (true) {}
    }
    writeString("Removed directory '/dir1/dir2/dir3'.\n");
    if (rmdir("/dir1/dir2") != 0) {
        handleTestFailure("Failed to remove directory '/dir1/dir2'.\n");
        while (true) {}
    }
    writeString("Removed directory '/dir1/dir2'.\n");
    if (rmdir("/dir1") != 0) {
        handleTestFailure("Failed to remove directory '/dir1'.\n");
        while (true) {}
    }
    writeString("Removed directory '/dir1'.\n");
}

// Diagnostic function to output the current root directory contents in a structured way
func dumpRootDirectoryStructured() {
    byte[PageSize] buffer;
    byte[PageSize] chainBuffer;
    byte nextBlock;
    word i;
    byte entryType;
    byte entryLength;
    char[13] entryName;
    word entrySize;
    byte fileBlock;
    byte currentBlock = RootDirStartBlock;
    
    // Read the chain list
    _readBlock(ChainBlock, chainBuffer);

    // Iterate through the directory blocks
    while (true) {
        
        _readBlock(currentBlock, buffer);
        writeString("Block ");
        writeHex(currentBlock);
        writeString(" -> ");
        writeHex(chainBuffer[currentBlock]);
        writeString(":\n");

        // Iterate through directory entries in the block
        for (i = 0; i < PageSize; i += DescriptorSize) {
            entryType = buffer[i + FileTypeOffset];
            entryLength = entryType & 0x0F;
            entryType = entryType & 0xF0;
            entryName[0] = '\0';
            fileBlock = buffer[i + StartBlockOffset];

            if (fileBlock != 0) {
                strncpy(entryName, (buffer + i + FilenameOffset) as char[], entryLength);
                entryName[entryLength] = '\0';
                entrySize = (buffer[i + FileSizeOffset] << 8) | buffer[i + FileSizeOffset + 1];
                writeString("  ");
                writeHex((i / DescriptorSize) as byte);
                writeString(entryType == FileTypeFile ? " File:      " : " Directory: ");
                writeString(entryName);
                writeString(", Size: ");
                writeWord(entrySize);
                writeString(" bytes, block=");
                writeWord(fileBlock);
                writeChar('\n');
            } else {
                //writeString("  Empty Slot\n");
            }
        }
        currentBlock = chainBuffer[currentBlock];
        if (currentBlock == 1) { break; }
    }
}

func main() {
    writeString("\nScanning:\n");
    if (i2cScan(SerialEEPROMAddress)) {
        writeString("EEPROM Found\n");
    } else {
        writeString("EEPROM Not Found\n");
        return;
    }
    chdir("/");
    if (format() != 0) {
        writeString("Format failed.\n");
        return;
    }
    writeString("Format succeeded.\n");
    // Determine the number of files needed to exceed one directory block.
    word filesPerBlock = PageSize / DescriptorSize;
    word extraFiles = filesPerBlock + 10; // Creating 10 more files than would fit in one block.
    // Create more files than would fit into one directory block.
    createMultipleFiles(extraFiles);
    // Verify the files were created.
    char[256] filename;
    for (word i = 0; i < extraFiles; i++) {
        strcpy(filename, "/file");
        writeFileN(filename, i);
        byte[] fileHandle = fopen(filename, "r");
        if (fileHandle == null) {
            handleTestFailure("Failed to verify file '");
            writeString(filename);
            writeString("'.\n");
            while (true) {}
        }
        fclose(fileHandle);
        writeString("Verified file '");
        writeString(filename);
        writeString("'.\n");
    }
    
    dumpRootDirectoryStructured();
    writeString("Remove /file0../file8:\n");
    
    remove("/file4");
    remove("/file3");
    remove("/file8");
    remove("/file0");
    remove("/file7");
    remove("/file1");
    remove("/file5");
    remove("/file2");
    remove("/file6");
    dumpChainLists();
    remove("/file11");
    dumpChainLists();
    dumpRootDirectoryStructured();
    
    //remove("/file12");
    //dumpRootDirectoryStructured();
    
    /*
    writeString("Remove /file8:\n");
    remove("/file8");
    dumpRootDirectoryStructured();
    */
    /*
    // Remove all the files.
    removeMultipleFiles(extraFiles);
    // Verify the root directory is empty.
    verifyRootDirectoryEmpty();
    // Create and verify a file with the maximum allowed filename length.
    createAndVerifyMaxFilenameLength();
    // Create and verify nested directories.
    createAndVerifyNestedDirs();
    writeString("All tests passed successfully.\n");
    */
    dumpRootDirectory();
    dumpChainLists();
    
}

