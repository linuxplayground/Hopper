#define EXPERIMENTAL
#define ZEROPAGEGLOBALS
func dumpRootDirectory();
func dumpChainLists();
#include "../system.tc"
#include "../file.tc"

// Prints the contents of a buffer in hexadecimal format.
func printHex(const byte[] buffer, word length) {
    word i;
    for (i = 0; i < length; i++) {
        writeHex(buffer[i]);
        writeChar(' ');
        if ((i + 1) % 16 == 0) {
            if ((i + 1) % 64 == 0) {
                writeChar('\n');
                break;
            } else {
                writeChar(' ');
            }
        }
    }
    writeChar('\n');
}
// Debugging function to print a byte buffer
func printByteBuffer(const char[] label, byte[] buffer, word length) {
    writeString(label);
    writeString(":\n");
    printHex(buffer, length);
}

// Dumps the contents of the ChainLists block.
func dumpChainLists() {
    byte[PageSize] buffer;
    writeString("ChainLists Block:\n");
    _readBlock(ChainBlock, buffer);
    printHex(buffer, PageSize);
}

// Dumps the contents of the root directory block.
func dumpRootDirectory() {
    byte[PageSize] buffer;
    writeString("Root Directory Block:\n");
    _readBlock(RootDirStartBlock, buffer);
    printHex(buffer, PageSize);
}

// Prints a message and dumps the root directory and chain lists if a test fails.
func handleTestFailure(const char[] message) {
    writeString(message);
    dumpRootDirectory();
    dumpChainLists();
}

func writeFileN(char[] name, word n)
{
    writeString(name); writeWord(n);
}

// Creates multiple files in the root directory.
func createMultipleFiles(word count) {
    char[256] filename;
    word i;
    for (i = 0; i < count; i++) {
        writeFileN("/file", i );
        byte[] fileHandle = fopen(filename, "w");
        if (fileHandle == null) {
            handleTestFailure("Failed to create file '");
            writeString(filename);
            writeString("'.\n");
            return;
        }
        fclose(fileHandle);
    }
}

// Removes multiple files from the root directory.
func removeMultipleFiles(word count) {
    char[256] filename;
    word i;
    for (i = 0; i < count; i++) {
        writeFileN("/file", i );
        if (remove(filename) != 0) {
            handleTestFailure("Failed to remove file '");
            writeString(filename);
            writeString("'.\n");
            return;
        }
    }
}

// Verifies that the root directory is empty.
func verifyRootDirectoryEmpty() {
    byte[] dirHandle = opendir("/");
    if (dirHandle == null) {
        handleTestFailure("Failed to open root directory.\n");
        return;
    }
    byte[] dirEntry;
    while ((dirEntry = readdir(dirHandle)) != null) {
        handleTestFailure("Root directory is not empty.\n");
        closedir(dirHandle);
        return;
    }
    closedir(dirHandle);
}

func main() {
    writeString("\nScanning:\n");
    if (i2cScan(SerialEEPROMAddress)) {
        writeString("EEPROM Found\n");
    } else {
        writeString("EEPROM Not Found\n");
        return;
    }
    chdir("/");
    
    if (format() != 0) {
        writeString("Format failed.\n");
        return;
    }
    writeString("Format succeeded.\n");
    
    // Determine the number of files needed to exceed one directory block.
    word filesPerBlock = PageSize / DescriptorSize;
    word extraFiles = filesPerBlock + 10; // Creating 10 more files than would fit in one block.

    // Create more files than would fit into one directory block.
    createMultipleFiles(extraFiles);

    // Verify the files were created.
    char[256] filename;
    for (word i = 0; i < extraFiles; i++) {
        writeFileN("/file", i );
        byte[] fileHandle = fopen(filename, "r");
        if (fileHandle == null) {
            handleTestFailure("Failed to verify file '");
            writeString(filename);
            writeString("'.\n");
            return;
        }
        fclose(fileHandle);
    }

    // Remove all the files.
    removeMultipleFiles(extraFiles);

    // Verify the root directory is empty.
    verifyRootDirectoryEmpty();

    writeString("All tests passed successfully.\n");
}

