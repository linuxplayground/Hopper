#define EXPERIMENTAL
#define ZEROPAGEGLOBALS
#include "../system.tc"
#include "../file.tc"

// Dumps the contents of the ChainLists block.
func dumpChainLists() {
    byte[PageSize] buffer;
    writeString("ChainLists Block:\n");
    readBlock(ChainBlock, buffer);
    printHex(buffer, PageSize);
}

// Dumps the contents of the root directory block.
func dumpRootDirectory() {
    byte[PageSize] buffer;
    writeString("Root Directory Block:\n");
    readBlock(RootDirStartBlock, buffer);
    printHex(buffer, PageSize);
}



func main() {
    writeString("\nScanning:\n");
    if (i2cScan(SerialEEPROMAddress)) {
        writeString("EEPROM Found\n");
    } else {
        writeString("EEPROM Not Found\n");
        return;
    }
    
    if (format() != 0) {
        writeString("Format failed.\n");
        return;
    }
    writeString("Format succeeded.\n");
    
    // FAT, ChainLists, and Root Directory blocks
    dumpChainLists();
    dumpRootDirectory();
    
    byte[] rootDir = opendir("/");
    if (rootDir == null) {
        writeString("Failed to open root directory.\n");
        return;
    }
    writeString("Opened root directory.\n");
    
    if (mkdir("newdir1") == -1)
    {
        writeString("FAILED to create directory '");
        writeString("newdir1");
        writeString("'.\n");
    }
    if (mkdir("newdir2") == -1)
    {
        writeString("FAILED to create directory '");
        writeString("newdir2");
        writeString("'.\n");
    }
    
    // Dump Root Directory blocks again
    dumpChainLists();
    dumpRootDirectory();
    
    // List directories
    byte[] dirEntry;
    while ((dirEntry = readdir(rootDir)) != null) {
        writeString("Entry: ");
        writeString((dirEntry + FilenameOffset) as char[]);
        writeString("\n");
    }
    writeString("No more entries in root directory.\n");
    
    if (closedir(rootDir) != 0) {
        writeString("Failed to close root directory.\n");
        return;
    }
    writeString("Closed root directory.\n");
}

